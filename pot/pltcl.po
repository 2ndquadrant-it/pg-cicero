msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2011-08-28 06:59+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: /tmp/cicero-EpGA/pltcl.xml:6(title) 
msgid "PL/Tcl - Tcl Procedural Language"
msgstr ""

#: /tmp/cicero-EpGA/pltcl.xml:9(primary) 
msgid "PL/Tcl"
msgstr ""

#: /tmp/cicero-EpGA/pltcl.xml:13(primary) 
msgid "Tcl"
msgstr ""

#: /tmp/cicero-EpGA/pltcl.xml:16(para) 
msgid "PL/Tcl is a loadable procedural language for the <productname>PostgreSQL</productname> database system that enables the <ulink url=\"http://www.tcl.tk/\"> Tcl language</ulink> to be used to write functions and trigger procedures."
msgstr ""

#: /tmp/cicero-EpGA/pltcl.xml:27(title) 
msgid "Overview"
msgstr ""

#: /tmp/cicero-EpGA/pltcl.xml:29(para) 
msgid "PL/Tcl offers most of the capabilities a function writer has in the C language, with a few restrictions, and with the addition of the powerful string processing libraries that are available for Tcl."
msgstr ""

#: /tmp/cicero-EpGA/pltcl.xml:35(para) 
msgid "One compelling <emphasis>good</emphasis> restriction is that everything is executed from within the safety of the context of a Tcl interpreter. In addition to the limited command set of safe Tcl, only a few commands are available to access the database via SPI and to raise messages via <function>elog()</function>. PL/Tcl provides no way to access internals of the database server or to gain OS-level access under the permissions of the <productname>PostgreSQL</productname> server process, as a C function can do. Thus, unprivileged database users can be trusted to use this language; it does not give them unlimited authority."
msgstr ""

#: /tmp/cicero-EpGA/pltcl.xml:47(para) 
msgid "The other notable implementation restriction is that Tcl functions cannot be used to create input/output functions for new data types."
msgstr ""

#: /tmp/cicero-EpGA/pltcl.xml:52(para) 
msgid "Sometimes it is desirable to write Tcl functions that are not restricted to safe Tcl. For example, one might want a Tcl function that sends email. To handle these cases, there is a variant of <application>PL/Tcl</application> called <literal>PL/TclU</literal> (for untrusted Tcl). This is the exact same language except that a full Tcl interpreter is used. <emphasis>If <application>PL/TclU</application> is used, it must be installed as an untrusted procedural language</emphasis> so that only database superusers can create functions in it. The writer of a <application>PL/TclU</application> function must take care that the function cannot be used to do anything unwanted, since it will be able to do anything that could be done by a user logged in as the database administrator."
msgstr ""

#: /tmp/cicero-EpGA/pltcl.xml:64(para) 
msgid "The shared object code for the <application>PL/Tcl</application> and <application>PL/TclU</application> call handlers is automatically built and installed in the <productname>PostgreSQL</productname> library directory if Tcl support is specified in the configuration step of the installation procedure. To install <application>PL/Tcl</application> and/or <application>PL/TclU</application> in a particular database, use the <command>CREATE EXTENSION</command> command or the <command>createlang</command> program, for example <literal>createlang pltcl <replaceable>dbname</replaceable></literal> or <literal>createlang pltclu <replaceable>dbname</replaceable></literal>."
msgstr ""

#: /tmp/cicero-EpGA/pltcl.xml:81(title) 
msgid "PL/Tcl Functions and Arguments"
msgstr ""

#: /tmp/cicero-EpGA/pltcl.xml:87(programlisting) 
#, no-wrap
msgid "\nCREATE FUNCTION <replaceable>funcname</replaceable> (<replaceable>argument-types</replaceable>) RETURNS <replaceable>return-type</replaceable> AS $$\n    # PL/Tcl function body\n$$ LANGUAGE pltcl;\n"
msgstr ""

#: /tmp/cicero-EpGA/pltcl.xml:83(para) 
msgid "To create a function in the <application>PL/Tcl</application> language, use the standard <xref linkend=\"sql-createfunction\"/> syntax: <placeholder-1/><application>PL/TclU</application> is the same, except that the language has to be specified as <literal>pltclu</literal>."
msgstr ""

#: /tmp/cicero-EpGA/pltcl.xml:97(para) 
msgid "The body of the function is simply a piece of Tcl script. When the function is called, the argument values are passed as variables <literal>$1</literal> ... <literal>$<replaceable>n</replaceable></literal> to the Tcl script. The result is returned from the Tcl code in the usual way, with a <literal>return</literal> statement."
msgstr ""

#: /tmp/cicero-EpGA/pltcl.xml:110(programlisting) 
#, no-wrap
msgid "\nCREATE FUNCTION tcl_max(integer, integer) RETURNS integer AS $$\n    if {$1 &gt; $2} {return $1}\n    return $2\n$$ LANGUAGE pltcl STRICT;\n"
msgstr ""

#: /tmp/cicero-EpGA/pltcl.xml:106(para) 
msgid "For example, a function returning the greater of two integer values could be defined as: <placeholder-1/> Note the clause <literal>STRICT</literal>, which saves us from having to think about null input values: if a null value is passed, the function will not be called at all, but will just return a null result automatically."
msgstr ""

#: /tmp/cicero-EpGA/pltcl.xml:132(programlisting) 
#, no-wrap
msgid "\nCREATE FUNCTION tcl_max(integer, integer) RETURNS integer AS $$\n    if {[argisnull 1]} {\n        if {[argisnull 2]} { return_null }\n        return $2\n    }\n    if {[argisnull 2]} { return $1 }\n    if {$1 &gt; $2} {return $1}\n    return $2\n$$ LANGUAGE pltcl;\n"
msgstr ""

#: /tmp/cicero-EpGA/pltcl.xml:123(para) 
msgid "In a nonstrict function, if the actual value of an argument is null, the corresponding <literal>$<replaceable>n</replaceable></literal> variable will be set to an empty string. To detect whether a particular argument is null, use the function <literal>argisnull</literal>. For example, suppose that we wanted <function>tcl_max</function> with one null and one nonnull argument to return the nonnull argument, rather than null: <placeholder-1/>"
msgstr ""

#: /tmp/cicero-EpGA/pltcl.xml:145(para) 
msgid "As shown above, to return a null value from a PL/Tcl function, execute <literal>return_null</literal>. This can be done whether the function is strict or not."
msgstr ""

#: /tmp/cicero-EpGA/pltcl.xml:158(programlisting) 
#, no-wrap
msgid "\nCREATE TABLE employee (\n    name text,\n    salary integer,\n    age integer\n);\n\nCREATE FUNCTION overpaid(employee) RETURNS boolean AS $$\n    if {200000.0 &lt; $1(salary)} {\n        return \"t\"\n    }\n    if {$1(age) &lt; 30 &amp;&amp; 100000.0 &lt; $1(salary)} {\n        return \"t\"\n    }\n    return \"f\"\n$$ LANGUAGE pltcl;\n"
msgstr ""

#: /tmp/cicero-EpGA/pltcl.xml:152(para) 
msgid "Composite-type arguments are passed to the function as Tcl arrays. The element names of the array are the attribute names of the composite type. If an attribute in the passed row has the null value, it will not appear in the array. Here is an example: <placeholder-1/>"
msgstr ""

#: /tmp/cicero-EpGA/pltcl.xml:177(para) 
msgid "There is currently no support for returning a composite-type result value, nor for returning sets."
msgstr ""

#: /tmp/cicero-EpGA/pltcl.xml:182(para) 
msgid "<application>PL/Tcl</application> does not currently have full support for domain types: it treats a domain the same as the underlying scalar type. This means that constraints associated with the domain will not be enforced. This is not an issue for function arguments, but it is a hazard if you declare a <application>PL/Tcl</application> function as returning a domain type."
msgstr ""

#: /tmp/cicero-EpGA/pltcl.xml:194(title) 
msgid "Data Values in PL/Tcl"
msgstr ""

#: /tmp/cicero-EpGA/pltcl.xml:196(para) 
msgid "The argument values supplied to a PL/Tcl function's code are simply the input arguments converted to text form (just as if they had been displayed by a <command>SELECT</command> statement). Conversely, the <literal>return</literal> command will accept any string that is acceptable input format for the function's declared return type. So, within the PL/Tcl function, all values are just text strings."
msgstr ""

#: /tmp/cicero-EpGA/pltcl.xml:209(title) 
msgid "Global Data in PL/Tcl"
msgstr ""

#: /tmp/cicero-EpGA/pltcl.xml:212(primary) 
msgid "global data"
msgstr ""

#: /tmp/cicero-EpGA/pltcl.xml:213(secondary) /tmp/cicero-EpGA/pltcl.xml:485(secondary) /tmp/cicero-EpGA/pltcl.xml:523(secondary) 
msgid "in PL/Tcl"
msgstr ""

#: /tmp/cicero-EpGA/pltcl.xml:216(para) 
msgid "Sometimes it is useful to have some global data that is held between two calls to a function or is shared between different functions. This is easily done in PL/Tcl, but there are some restrictions that must be understood."
msgstr ""

#: /tmp/cicero-EpGA/pltcl.xml:224(para) 
msgid "For security reasons, PL/Tcl executes functions called by any one SQL role in a separate Tcl interpreter for that role. This prevents accidental or malicious interference by one user with the behavior of another user's PL/Tcl functions. Each such interpreter will have its own values for any <quote>global</quote> Tcl variables. Thus, two PL/Tcl functions will share the same global variables if and only if they are executed by the same SQL role. In an application wherein a single session executes code under multiple SQL roles (via <literal>SECURITY DEFINER</literal> functions, use of <command>SET ROLE</command>, etc) you may need to take explicit steps to ensure that PL/Tcl functions can share data. To do that, make sure that functions that should communicate are owned by the same user, and mark them <literal>SECURITY DEFINER</literal>. You must of course take care that such functions can't be used to do anything unintended."
msgstr ""

#: /tmp/cicero-EpGA/pltcl.xml:241(para) 
msgid "All PL/TclU functions used in a session execute in the same Tcl interpreter, which of course is distinct from the interpreter(s) used for PL/Tcl functions. So global data is automatically shared between PL/TclU functions. This is not considered a security risk because all PL/TclU functions execute at the same trust level, namely that of a database superuser."
msgstr ""

#: /tmp/cicero-EpGA/pltcl.xml:250(para) 
msgid "To help protect PL/Tcl functions from unintentionally interfering with each other, a global array is made available to each function via the <function>upvar</function> command. The global name of this variable is the function's internal name, and the local name is <literal>GD</literal>. It is recommended that <literal>GD</literal> be used for persistent private data of a function. Use regular Tcl global variables only for values that you specifically intend to be shared among multiple functions. (Note that the <literal>GD</literal> arrays are only global within a particular interpreter, so they do not bypass the security restrictions mentioned above.)"
msgstr ""

#: /tmp/cicero-EpGA/pltcl.xml:264(para) 
msgid "An example of using <literal>GD</literal> appears in the <function>spi_execp</function> example below."
msgstr ""

#: /tmp/cicero-EpGA/pltcl.xml:271(title) 
msgid "Database Access from PL/Tcl"
msgstr ""

#: /tmp/cicero-EpGA/pltcl.xml:280(function) 
msgid "spi_exec"
msgstr ""

#: /tmp/cicero-EpGA/pltcl.xml:280(replaceable) /tmp/cicero-EpGA/pltcl.xml:370(replaceable) 
msgid "n"
msgstr ""

#: /tmp/cicero-EpGA/pltcl.xml:280(optional) /tmp/cicero-EpGA/pltcl.xml:370(optional) 
msgid "-count <placeholder-1/>"
msgstr ""

#: /tmp/cicero-EpGA/pltcl.xml:280(replaceable) /tmp/cicero-EpGA/pltcl.xml:370(replaceable) 
msgid "name"
msgstr ""

#: /tmp/cicero-EpGA/pltcl.xml:280(optional) /tmp/cicero-EpGA/pltcl.xml:370(optional) 
msgid "-array <placeholder-1/>"
msgstr ""

#: /tmp/cicero-EpGA/pltcl.xml:280(replaceable) 
msgid "command"
msgstr ""

#: /tmp/cicero-EpGA/pltcl.xml:280(replaceable) /tmp/cicero-EpGA/pltcl.xml:370(replaceable) 
msgid "loop-body"
msgstr ""

#: /tmp/cicero-EpGA/pltcl.xml:282(para) 
msgid "Executes an SQL command given as a string. An error in the command causes an error to be raised. Otherwise, the return value of <function>spi_exec</function> is the number of rows processed (selected, inserted, updated, or deleted) by the command, or zero if the command is a utility statement. In addition, if the command is a <command>SELECT</command> statement, the values of the selected columns are placed in Tcl variables as described below."
msgstr ""

#: /tmp/cicero-EpGA/pltcl.xml:291(para) 
msgid "The optional <literal>-count</literal> value tells <function>spi_exec</function> the maximum number of rows to process in the command. The effect of this is comparable to setting up a query as a cursor and then saying <literal>FETCH <replaceable>n</replaceable></literal>."
msgstr ""

#: /tmp/cicero-EpGA/pltcl.xml:297(para) 
msgid "If the command is a <command>SELECT</command> statement, the values of the result columns are placed into Tcl variables named after the columns. If the <literal>-array</literal> option is given, the column values are instead stored into the named associative array, with the column names used as array indexes."
msgstr ""

#: /tmp/cicero-EpGA/pltcl.xml:311(programlisting) 
#, no-wrap
msgid "\nspi_exec \"SELECT count(*) AS cnt FROM pg_proc\"\n"
msgstr ""

#: /tmp/cicero-EpGA/pltcl.xml:304(para) 
msgid "If the command is a <command>SELECT</command> statement and no <replaceable>loop-body</replaceable> script is given, then only the first row of results are stored into Tcl variables; remaining rows, if any, are ignored. No storing occurs if the query returns no rows. (This case can be detected by checking the result of <function>spi_exec</function>.) For example: <placeholder-1/> will set the Tcl variable <literal>$cnt</literal> to the number of rows in the <structname>pg_proc</structname> system catalog."
msgstr ""

#: /tmp/cicero-EpGA/pltcl.xml:325(programlisting) 
#, no-wrap
msgid "\nspi_exec -array C \"SELECT * FROM pg_class\" {\n    elog DEBUG \"have table $C(relname)\"\n}\n"
msgstr ""

#: /tmp/cicero-EpGA/pltcl.xml:318(para) 
msgid "If the optional <replaceable>loop-body</replaceable> argument is given, it is a piece of Tcl script that is executed once for each row in the query result. (<replaceable>loop-body</replaceable> is ignored if the given command is not a <command>SELECT</command>.) The values of the current row's columns are stored into Tcl variables before each iteration. For example: <placeholder-1/> will print a log message for every row of <literal>pg_class</literal>. This feature works similarly to other Tcl looping constructs; in particular <literal>continue</literal> and <literal>break</literal> work in the usual way inside the loop body."
msgstr ""

#: /tmp/cicero-EpGA/pltcl.xml:336(para) 
msgid "If a column of a query result is null, the target variable for it is <quote>unset</quote> rather than being set."
msgstr ""

#: /tmp/cicero-EpGA/pltcl.xml:344(function) 
msgid "spi_prepare"
msgstr ""

#: /tmp/cicero-EpGA/pltcl.xml:344(replaceable) 
msgid "query"
msgstr ""

#: /tmp/cicero-EpGA/pltcl.xml:344(replaceable) 
msgid "typelist"
msgstr ""

#: /tmp/cicero-EpGA/pltcl.xml:346(para) 
msgid "Prepares and saves a query plan for later execution. The saved plan will be retained for the life of the current session.<indexterm><primary>preparing a query</primary><secondary>in PL/Tcl</secondary></indexterm>"
msgstr ""

#: /tmp/cicero-EpGA/pltcl.xml:352(para) 
msgid "The query can use parameters, that is, placeholders for values to be supplied whenever the plan is actually executed. In the query string, refer to parameters by the symbols <literal>$1</literal> ... <literal>$<replaceable>n</replaceable></literal>. If the query uses parameters, the names of the parameter types must be given as a Tcl list. (Write an empty list for <replaceable>typelist</replaceable> if no parameters are used.)"
msgstr ""

#: /tmp/cicero-EpGA/pltcl.xml:361(para) 
msgid "The return value from <function>spi_prepare</function> is a query ID to be used in subsequent calls to <function>spi_execp</function>. See <function>spi_execp</function> for an example."
msgstr ""

#: /tmp/cicero-EpGA/pltcl.xml:370(function) 
msgid "spi_execp"
msgstr ""

#: /tmp/cicero-EpGA/pltcl.xml:370(replaceable) /tmp/cicero-EpGA/pltcl.xml:438(replaceable) 
msgid "string"
msgstr ""

#: /tmp/cicero-EpGA/pltcl.xml:370(optional) 
msgid "-nulls <placeholder-1/>"
msgstr ""

#: /tmp/cicero-EpGA/pltcl.xml:370(replaceable) 
msgid "queryid"
msgstr ""

#: /tmp/cicero-EpGA/pltcl.xml:370(replaceable) 
msgid "value-list"
msgstr ""

#: /tmp/cicero-EpGA/pltcl.xml:372(para) 
msgid "Executes a query previously prepared with <function>spi_prepare</function>. <replaceable>queryid</replaceable> is the ID returned by <function>spi_prepare</function>. If the query references parameters, a <replaceable>value-list</replaceable> must be supplied. This is a Tcl list of actual values for the parameters. The list must be the same length as the parameter type list previously given to <function>spi_prepare</function>. Omit <replaceable>value-list</replaceable> if the query has no parameters."
msgstr ""

#: /tmp/cicero-EpGA/pltcl.xml:382(para) 
msgid "The optional value for <literal>-nulls</literal> is a string of spaces and <literal>'n'</literal> characters telling <function>spi_execp</function> which of the parameters are null values. If given, it must have exactly the same length as the <replaceable>value-list</replaceable>. If it is not given, all the parameter values are nonnull."
msgstr ""

#: /tmp/cicero-EpGA/pltcl.xml:389(para) 
msgid "Except for the way in which the query and its parameters are specified, <function>spi_execp</function> works just like <function>spi_exec</function>. The <literal>-count</literal>, <literal>-array</literal>, and <replaceable>loop-body</replaceable> options are the same, and so is the result value."
msgstr ""

#: /tmp/cicero-EpGA/pltcl.xml:399(programlisting) 
#, no-wrap
msgid "\nCREATE FUNCTION t1_count(integer, integer) RETURNS integer AS $$\n    if {![ info exists GD(plan) ]} {\n        # prepare the saved plan on the first call\n        set GD(plan) [ spi_prepare \\\n                \"SELECT count(*) AS cnt FROM t1 WHERE num &gt;= \\$1 AND num &lt;= \\$2\" \\\n                [ list int4 int4 ] ]\n    }\n    spi_execp -count 1 $GD(plan) [ list $1 $2 ]\n    return $cnt\n$$ LANGUAGE pltcl;\n"
msgstr ""

#: /tmp/cicero-EpGA/pltcl.xml:396(para) 
msgid "Here's an example of a PL/Tcl function using a prepared plan: <placeholder-1/> We need backslashes inside the query string given to <function>spi_prepare</function> to ensure that the <literal>$<replaceable>n</replaceable></literal> markers will be passed through to <function>spi_prepare</function> as-is, and not replaced by Tcl variable substitution."
msgstr ""

#: /tmp/cicero-EpGA/pltcl.xml:424(primary) /tmp/cicero-EpGA/pltcl.xml:426(function) 
msgid "spi_lastoid"
msgstr ""

#: /tmp/cicero-EpGA/pltcl.xml:428(para) 
msgid "Returns the OID of the row inserted by the last <function>spi_exec</function> or <function>spi_execp</function>, if the command was a single-row <command>INSERT</command> and the modified table contained OIDs. (If not, you get zero.)"
msgstr ""

#: /tmp/cicero-EpGA/pltcl.xml:438(function) 
msgid "quote"
msgstr ""

#: /tmp/cicero-EpGA/pltcl.xml:448(programlisting) 
#, no-wrap
msgid "\n\"SELECT '$val' AS ret\"\n"
msgstr ""

#: /tmp/cicero-EpGA/pltcl.xml:456(programlisting) 
#, no-wrap
msgid "\nSELECT 'doesn't' AS ret\n"
msgstr ""

#: /tmp/cicero-EpGA/pltcl.xml:465(programlisting) 
#, no-wrap
msgid "\nSELECT 'doesn''t' AS ret\n"
msgstr ""

#: /tmp/cicero-EpGA/pltcl.xml:471(programlisting) 
#, no-wrap
msgid "\n\"SELECT '[ quote $val ]' AS ret\"\n"
msgstr ""

#: /tmp/cicero-EpGA/pltcl.xml:440(para) 
msgid "Doubles all occurrences of single quote and backslash characters in the given string. This can be used to safely quote strings that are to be inserted into SQL commands given to <function>spi_exec</function> or <function>spi_prepare</function>. For example, think about an SQL command string like: <placeholder-1/> where the Tcl variable <literal>val</literal> actually contains <literal>doesn't</literal>. This would result in the final command string: <placeholder-2/> which would cause a parse error during <function>spi_exec</function> or <function>spi_prepare</function>. To work properly, the submitted command should contain: <placeholder-3/> which can be formed in PL/Tcl using: <placeholder-4/> One advantage of <function>spi_execp</function> is that you don't have to quote parameter values like this, since the parameters are never parsed as part of an SQL command string."
msgstr ""

#: /tmp/cicero-EpGA/pltcl.xml:484(primary) /tmp/cicero-EpGA/pltcl.xml:487(function) 
msgid "elog"
msgstr ""

#: /tmp/cicero-EpGA/pltcl.xml:487(replaceable) 
msgid "level"
msgstr ""

#: /tmp/cicero-EpGA/pltcl.xml:487(replaceable) 
msgid "msg"
msgstr ""

#: /tmp/cicero-EpGA/pltcl.xml:489(para) 
msgid "Emits a log or error message. Possible levels are <literal>DEBUG</literal>, <literal>LOG</literal>, <literal>INFO</literal>, <literal>NOTICE</literal>, <literal>WARNING</literal>, <literal>ERROR</literal>, and <literal>FATAL</literal>. <literal>ERROR</literal> raises an error condition; if this is not trapped by the surrounding Tcl code, the error propagates out to the calling query, causing the current transaction or subtransaction to be aborted. This is effectively the same as the Tcl <literal>error</literal> command. <literal>FATAL</literal> aborts the transaction and causes the current session to shut down. (There is probably no good reason to use this error level in PL/Tcl functions, but it's provided for completeness.) The other levels only generate messages of different priority levels. Whether messages of a particular priority are reported to the client, written to the server log, or both is controlled by the <xref linkend=\"guc-log-min-messages\"/> and <xref linkend=\"guc-client-min-messages\"/> configuration variables. See <xref linkend=\"runtime-config\"/> for more information."
msgstr ""

#: /tmp/cicero-EpGA/pltcl.xml:273(para) 
msgid "The following commands are available to access the database from the body of a PL/Tcl function: <placeholder-1/>"
msgstr ""

#: /tmp/cicero-EpGA/pltcl.xml:519(title) 
msgid "Trigger Procedures in PL/Tcl"
msgstr ""

#: /tmp/cicero-EpGA/pltcl.xml:522(primary) 
msgid "trigger"
msgstr ""

#: /tmp/cicero-EpGA/pltcl.xml:526(para) 
msgid "Trigger procedures can be written in PL/Tcl. <productname>PostgreSQL</productname> requires that a procedure that is to be called as a trigger must be declared as a function with no arguments and a return type of <literal>trigger</literal>."
msgstr ""

#: /tmp/cicero-EpGA/pltcl.xml:539(varname) 
msgid "$TG_name"
msgstr ""

#: /tmp/cicero-EpGA/pltcl.xml:541(para) 
msgid "The name of the trigger from the <command>CREATE TRIGGER</command> statement."
msgstr ""

#: /tmp/cicero-EpGA/pltcl.xml:548(varname) 
msgid "$TG_relid"
msgstr ""

#: /tmp/cicero-EpGA/pltcl.xml:550(para) 
msgid "The object ID of the table that caused the trigger procedure to be invoked."
msgstr ""

#: /tmp/cicero-EpGA/pltcl.xml:558(varname) 
msgid "$TG_table_name"
msgstr ""

#: /tmp/cicero-EpGA/pltcl.xml:560(para) 
msgid "The name of the table that caused the trigger procedure to be invoked."
msgstr ""

#: /tmp/cicero-EpGA/pltcl.xml:568(varname) 
msgid "$TG_table_schema"
msgstr ""

#: /tmp/cicero-EpGA/pltcl.xml:570(para) 
msgid "The schema of the table that caused the trigger procedure to be invoked."
msgstr ""

#: /tmp/cicero-EpGA/pltcl.xml:578(varname) 
msgid "$TG_relatts"
msgstr ""

#: /tmp/cicero-EpGA/pltcl.xml:580(para) 
msgid "A Tcl list of the table column names, prefixed with an empty list element. So looking up a column name in the list with <application>Tcl</application>'s <function>lsearch</function> command returns the element's number starting with 1 for the first column, the same way the columns are customarily numbered in <productname>PostgreSQL</productname>. (Empty list elements also appear in the positions of columns that have been dropped, so that the attribute numbering is correct for columns to their right.)"
msgstr ""

#: /tmp/cicero-EpGA/pltcl.xml:594(varname) 
msgid "$TG_when"
msgstr ""

#: /tmp/cicero-EpGA/pltcl.xml:596(para) 
msgid "The string <literal>BEFORE</literal>, <literal>AFTER</literal>, or <literal>INSTEAD OF</literal>, depending on the type of trigger event."
msgstr ""

#: /tmp/cicero-EpGA/pltcl.xml:604(varname) 
msgid "$TG_level"
msgstr ""

#: /tmp/cicero-EpGA/pltcl.xml:606(para) 
msgid "The string <literal>ROW</literal> or <literal>STATEMENT</literal> depending on the type of trigger event."
msgstr ""

#: /tmp/cicero-EpGA/pltcl.xml:614(varname) 
msgid "$TG_op"
msgstr ""

#: /tmp/cicero-EpGA/pltcl.xml:616(para) 
msgid "The string <literal>INSERT</literal>, <literal>UPDATE</literal>, <literal>DELETE</literal>, or <literal>TRUNCATE</literal> depending on the type of trigger event."
msgstr ""

#: /tmp/cicero-EpGA/pltcl.xml:625(varname) 
msgid "$NEW"
msgstr ""

#: /tmp/cicero-EpGA/pltcl.xml:627(para) 
msgid "An associative array containing the values of the new table row for <command>INSERT</command> or <command>UPDATE</command> actions, or empty for <command>DELETE</command>. The array is indexed by column name. Columns that are null will not appear in the array. This is not set for statement-level triggers."
msgstr ""

#: /tmp/cicero-EpGA/pltcl.xml:638(varname) 
msgid "$OLD"
msgstr ""

#: /tmp/cicero-EpGA/pltcl.xml:640(para) 
msgid "An associative array containing the values of the old table row for <command>UPDATE</command> or <command>DELETE</command> actions, or empty for <command>INSERT</command>. The array is indexed by column name. Columns that are null will not appear in the array. This is not set for statement-level triggers."
msgstr ""

#: /tmp/cicero-EpGA/pltcl.xml:651(varname) 
msgid "$args"
msgstr ""

#: /tmp/cicero-EpGA/pltcl.xml:653(para) 
msgid "A Tcl list of the arguments to the procedure as given in the <command>CREATE TRIGGER</command> statement. These arguments are also accessible as <literal>$1</literal> ... <literal>$<replaceable>n</replaceable></literal> in the procedure body."
msgstr ""

#: /tmp/cicero-EpGA/pltcl.xml:532(para) 
msgid "The information from the trigger manager is passed to the procedure body in the following variables: <placeholder-1/>"
msgstr ""

#: /tmp/cicero-EpGA/pltcl.xml:664(para) 
msgid "The return value from a trigger procedure can be one of the strings <literal>OK</literal> or <literal>SKIP</literal>, or a list as returned by the <literal>array get</literal> Tcl command. If the return value is <literal>OK</literal>, the operation (<command>INSERT</command>/<command>UPDATE</command>/<command>DELETE</command>) that fired the trigger will proceed normally. <literal>SKIP</literal> tells the trigger manager to silently suppress the operation for this row. If a list is returned, it tells PL/Tcl to return a modified row to the trigger manager. This is only meaningful for row-level <literal>BEFORE</literal><command>INSERT</command> or <command>UPDATE</command> triggers for which the modified row will be inserted instead of the one given in <varname>$NEW</varname>; or for row-level <literal>INSTEAD OF</literal><command>INSERT</command> or <command>UPDATE</command> triggers where the returned row is used to support <command>INSERT RETURNING</command> and <command>UPDATE RETURNING</command> commands. The return value is ignored for other types of triggers."
msgstr ""

#: /tmp/cicero-EpGA/pltcl.xml:687(programlisting) 
#, no-wrap
msgid "\nCREATE FUNCTION trigfunc_modcount() RETURNS trigger AS $$\n    switch $TG_op {\n        INSERT {\n            set NEW($1) 0\n        }\n        UPDATE {\n            set NEW($1) $OLD($1)\n            incr NEW($1)\n        }\n        default {\n            return OK\n        }\n    }\n    return [array get NEW]\n$$ LANGUAGE pltcl;\n\nCREATE TABLE mytab (num integer, description text, modcnt integer);\n\nCREATE TRIGGER trig_mytab_modcount BEFORE INSERT OR UPDATE ON mytab\n    FOR EACH ROW EXECUTE PROCEDURE trigfunc_modcount('modcnt');\n"
msgstr ""

#: /tmp/cicero-EpGA/pltcl.xml:681(para) 
msgid "Here's a little example trigger procedure that forces an integer value in a table to keep track of the number of updates that are performed on the row. For new rows inserted, the value is initialized to 0 and then incremented on every update operation. <placeholder-1/> Notice that the trigger procedure itself does not know the column name; that's supplied from the trigger arguments. This lets the trigger procedure be reused with different tables."
msgstr ""

#: /tmp/cicero-EpGA/pltcl.xml:717(title) 
msgid "Modules and the <function>unknown</function> Command"
msgstr ""

#: /tmp/cicero-EpGA/pltcl.xml:718(para) 
msgid "PL/Tcl has support for autoloading Tcl code when used. It recognizes a special table, <literal>pltcl_modules</literal>, which is presumed to contain modules of Tcl code. If this table exists, the module <literal>unknown</literal> is fetched from the table and loaded into the Tcl interpreter immediately before the first execution of a PL/Tcl function in a database session. (This happens separately for each Tcl interpreter, if more than one is used in a session; see <xref linkend=\"pltcl-global\"/>.)"
msgstr ""

#: /tmp/cicero-EpGA/pltcl.xml:728(para) 
msgid "While the <literal>unknown</literal> module could actually contain any initialization script you need, it normally defines a Tcl <function>unknown</function> procedure that is invoked whenever Tcl does not recognize an invoked procedure name. <application>PL/Tcl</application>'s standard version of this procedure tries to find a module in <literal>pltcl_modules</literal> that will define the required procedure. If one is found, it is loaded into the interpreter, and then execution is allowed to proceed with the originally attempted procedure call. A secondary table <literal>pltcl_modfuncs</literal> provides an index of which functions are defined by which modules, so that the lookup is reasonably quick."
msgstr ""

#: /tmp/cicero-EpGA/pltcl.xml:741(para) 
msgid "The <productname>PostgreSQL</productname> distribution includes support scripts to maintain these tables: <command>pltcl_loadmod</command>, <command>pltcl_listmod</command>, <command>pltcl_delmod</command>, as well as source for the standard <literal>unknown</literal> module in <filename>share/unknown.pltcl</filename>. This module must be loaded into each database initially to support the autoloading mechanism."
msgstr ""

#: /tmp/cicero-EpGA/pltcl.xml:750(para) 
msgid "The tables <literal>pltcl_modules</literal> and <literal>pltcl_modfuncs</literal> must be readable by all, but it is wise to make them owned and writable only by the database administrator. As a security precaution, PL/Tcl will ignore <literal>pltcl_modules</literal> (and thus, not attempt to load the <literal>unknown</literal> module) unless it is owned by a superuser. But update privileges on this table can be granted to other users, if you trust them sufficiently."
msgstr ""

#: /tmp/cicero-EpGA/pltcl.xml:762(title) 
msgid "Tcl Procedure Names"
msgstr ""

#: /tmp/cicero-EpGA/pltcl.xml:764(para) 
msgid "In <productname>PostgreSQL</productname>, the same function name can be used for different function definitions as long as the number of arguments or their types differ. Tcl, however, requires all procedure names to be distinct. PL/Tcl deals with this by making the internal Tcl procedure names contain the object ID of the function from the system table <structname>pg_proc</structname> as part of their name. Thus, <productname>PostgreSQL</productname> functions with the same name and different argument types will be different Tcl procedures, too. This is not normally a concern for a PL/Tcl programmer, but it might be visible when debugging."
msgstr ""

#. Put one translator per line, in the form of NAME <EMAIL>, YEAR1, YEAR2.
#: /tmp/cicero-EpGA/pltcl.xml:0(None) 
msgid "translator-credits"
msgstr ""

