msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2011-09-29 06:56+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: /tmp/cicero-gTQe/plpgsql.xml:5(title) 
msgid "<application>PL/pgSQL</application> - <acronym>SQL</acronym> Procedural Language"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:8(primary) 
msgid "PL/pgSQL"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:12(title) 
msgid "Overview"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:22(para) 
msgid "can be used to create functions and trigger procedures,"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:27(para) 
msgid "adds control structures to the <acronym>SQL</acronym> language,"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:32(para) 
msgid "can perform complex computations,"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:37(para) 
msgid "inherits all user-defined types, functions, and operators,"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:42(para) 
msgid "can be defined to be trusted by the server,"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:47(para) 
msgid "is easy to use."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:14(para) 
msgid "<application>PL/pgSQL</application> is a loadable procedural language for the <productname>PostgreSQL</productname> database system. The design goals of <application>PL/pgSQL</application> were to create a loadable procedural language that <placeholder-1/>"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:54(para) 
msgid "Functions created with <application>PL/pgSQL</application> can be used anywhere that built-in functions could be used. For example, it is possible to create complex conditional computation functions and later use them to define operators or use them in index expressions."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:62(para) 
msgid "In <productname>PostgreSQL</productname> 9.0 and later, <application>PL/pgSQL</application> is installed by default. However it is still a loadable module, so especially security-conscious administrators could choose to remove it."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:70(title) 
msgid "Advantages of Using <application>PL/pgSQL</application>"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:72(para) 
msgid "<acronym>SQL</acronym> is the language <productname>PostgreSQL</productname> and most other relational databases use as query language. It's portable and easy to learn. But every <acronym>SQL</acronym> statement must be executed individually by the database server."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:79(para) 
msgid "That means that your client application must send each query to the database server, wait for it to be processed, receive and process the results, do some computation, then send further queries to the server. All this incurs interprocess communication and will also incur network overhead if your client is on a different machine than the database server."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:88(para) 
msgid "With <application>PL/pgSQL</application> you can group a block of computation and a series of queries <emphasis>inside</emphasis> the database server, thus having the power of a procedural language and the ease of use of SQL, but with considerable savings of client/server communication overhead."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:97(para) 
msgid "Extra round trips between client and server are eliminated"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:100(para) 
msgid "Intermediate results that the client does not need do not have to be marshaled or transferred between server and client"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:104(para) 
msgid "Multiple rounds of query parsing can be avoided"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:108(para) 
msgid "This can result in a considerable performance increase as compared to an application that does not use stored functions."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:112(para) 
msgid "Also, with <application>PL/pgSQL</application> you can use all the data types, operators and functions of SQL."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:119(title) 
msgid "Supported Argument and Result Data Types"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:121(para) 
msgid "Functions written in <application>PL/pgSQL</application> can accept as arguments any scalar or array data type supported by the server, and they can return a result of any of these types. They can also accept or return any composite type (row type) specified by name. It is also possible to declare a <application>PL/pgSQL</application> function as returning <type>record</type>, which means that the result is a row type whose columns are determined by specification in the calling query, as discussed in <xref linkend=\"queries-tablefunctions\"/>."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:132(para) 
msgid "<application>PL/pgSQL</application> functions can be declared to accept a variable number of arguments by using the <literal>VARIADIC</literal> marker. This works exactly the same way as for SQL functions, as discussed in <xref linkend=\"xfunc-sql-variadic-functions\"/>."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:139(para) 
msgid "<application>PL/pgSQL</application> functions can also be declared to accept and return the polymorphic types <type>anyelement</type>, <type>anyarray</type>, <type>anynonarray</type>, and <type>anyenum</type>. The actual data types handled by a polymorphic function can vary from call to call, as discussed in <xref linkend=\"extend-types-polymorphic\"/>. An example is shown in <xref linkend=\"plpgsql-declaration-parameters\"/>."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:149(para) 
msgid "<application>PL/pgSQL</application> functions can also be declared to return a <quote>set</quote> (or table) of any data type that can be returned as a single instance. Such a function generates its output by executing <command>RETURN NEXT</command> for each desired element of the result set, or by using <command>RETURN QUERY</command> to output the result of evaluating a query."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:158(para) 
msgid "Finally, a <application>PL/pgSQL</application> function can be declared to return <type>void</type> if it has no useful return value."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:163(para) 
msgid "<application>PL/pgSQL</application> functions can also be declared with output parameters in place of an explicit specification of the return type. This does not add any fundamental capability to the language, but it is often convenient, especially for returning multiple values. The <literal>RETURNS TABLE</literal> notation can also be used in place of <literal>RETURNS SETOF</literal>."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:172(para) 
msgid "Specific examples appear in <xref linkend=\"plpgsql-declaration-parameters\"/> and <xref linkend=\"plpgsql-statements-returning\"/>."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:181(title) 
msgid "Structure of <application>PL/pgSQL</application>"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:183(para) 
msgid "<application>PL/pgSQL</application> is a block-structured language. The complete text of a function definition must be a <firstterm>block</firstterm>. A block is defined as: <synopsis>\n<optional> &lt;&lt;<replaceable>label</replaceable>&gt;&gt; </optional>\n<optional> DECLARE\n    <replaceable>declarations</replaceable> </optional>\nBEGIN\n    <replaceable>statements</replaceable>\nEND <optional> <replaceable>label</replaceable> </optional>;\n</synopsis>"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:198(para) 
msgid "Each declaration and each statement within a block is terminated by a semicolon. A block that appears within another block must have a semicolon after <literal>END</literal>, as shown above; however the final <literal>END</literal> that concludes a function body does not require a semicolon."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:207(para) 
msgid "A common mistake is to write a semicolon immediately after <literal>BEGIN</literal>. This is incorrect and will result in a syntax error."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:213(para) 
msgid "A <replaceable>label</replaceable> is only needed if you want to identify the block for use in an <literal>EXIT</literal> statement, or to qualify the names of the variables declared in the block. If a label is given after <literal>END</literal>, it must match the label at the block's beginning."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:221(para) 
msgid "All key words are case-insensitive. Identifiers are implicitly converted to lower case unless double-quoted, just as they are in ordinary SQL commands."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:227(para) 
msgid "Comments work the same way in <application>PL/pgSQL</application> code as in ordinary SQL. A double dash (<literal>--</literal>) starts a comment that extends to the end of the line. A <literal>/*</literal> starts a block comment that extends to the matching occurrence of <literal>*/</literal>. Block comments nest."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:243(programlisting) 
#, no-wrap
msgid "\nCREATE FUNCTION somefunc() RETURNS integer AS $$\n&lt;&lt; outerblock &gt;&gt;\nDECLARE\n    quantity integer := 30;\nBEGIN\n    RAISE NOTICE 'Quantity here is %', quantity;  -- Prints 30\n    quantity := 50;\n    --\n    -- Create a subblock\n    --\n    DECLARE\n        quantity integer := 80;\n    BEGIN\n        RAISE NOTICE 'Quantity here is %', quantity;  -- Prints 80\n        RAISE NOTICE 'Outer quantity here is %', outerblock.quantity;  -- Prints 50\n    END;\n\n    RAISE NOTICE 'Quantity here is %', quantity;  -- Prints 50\n\n    RETURN quantity;\nEND;\n$$ LANGUAGE plpgsql;\n"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:235(para) 
msgid "Any statement in the statement section of a block can be a <firstterm>subblock</firstterm>. Subblocks can be used for logical grouping or to localize variables to a small group of statements. Variables declared in a subblock mask any similarly-named variables of outer blocks for the duration of the subblock; but you can access the outer variables anyway if you qualify their names with their block's label. For example: <placeholder-1/>"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:270(para) 
msgid "There is actually a hidden <quote>outer block</quote> surrounding the body of any <application>PL/pgSQL</application> function. This block provides the declarations of the function's parameters (if any), as well as some special variables such as <literal>FOUND</literal> (see <xref linkend=\"plpgsql-statements-diagnostics\"/>). The outer block is labeled with the function's name, meaning that parameters and special variables can be qualified with the function's name."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:281(para) 
msgid "It is important not to confuse the use of <command>BEGIN</command>/<command>END</command> for grouping statements in <application>PL/pgSQL</application> with the similarly-named SQL commands for transaction control. <application>PL/pgSQL</application>'s <command>BEGIN</command>/<command>END</command> are only for grouping; they do not start or end a transaction. Functions and trigger procedures are always executed within a transaction established by an outer query — they cannot start or commit that transaction, since there would be no context for them to execute in. However, a block containing an <literal>EXCEPTION</literal> clause effectively forms a subtransaction that can be rolled back without affecting the outer transaction. For more about that see <xref linkend=\"plpgsql-error-trapping\"/>."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:299(title) 
msgid "Declarations"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:301(para) 
msgid "All variables used in a block must be declared in the declarations section of the block. (The only exceptions are that the loop variable of a <literal>FOR</literal> loop iterating over a range of integer values is automatically declared as an integer variable, and likewise the loop variable of a <literal>FOR</literal> loop iterating over a cursor's result is automatically declared as a record variable.)"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:311(para) 
msgid "<application>PL/pgSQL</application> variables can have any SQL data type, such as <type>integer</type>, <type>varchar</type>, and <type>char</type>."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:319(programlisting) 
#, no-wrap
msgid "\nuser_id integer;\nquantity numeric(5);\nurl varchar;\nmyrow tablename%ROWTYPE;\nmyfield tablename.columnname%TYPE;\narow RECORD;\n"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:317(para) 
msgid "Here are some examples of variable declarations: <placeholder-1/>"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:329(para) 
msgid "The general syntax of a variable declaration is: <synopsis>\n<replaceable>name</replaceable> <optional> CONSTANT </optional> <replaceable>type</replaceable> <optional> COLLATE <replaceable>collation_name</replaceable> </optional> <optional> NOT NULL </optional> <optional> { DEFAULT | := } <replaceable>expression</replaceable> </optional>;\n</synopsis> The <literal>DEFAULT</literal> clause, if given, specifies the initial value assigned to the variable when the block is entered. If the <literal>DEFAULT</literal> clause is not given then the variable is initialized to the <acronym>SQL</acronym> null value. The <literal>CONSTANT</literal> option prevents the variable from being assigned to after initialization, so that its value will remain constant for the duration of the block. The <literal>COLLATE</literal> option specifies a collation to use for the variable (see <xref linkend=\"plpgsql-declaration-collation\"/>). If <literal>NOT NULL</literal> is specified, an assignment of a null value results in a run-time error. All variables declared as <literal>NOT NULL</literal> must have a nonnull default value specified."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:349(para) 
msgid "A variable's default value is evaluated and assigned to the variable each time the block is entered (not just once per function call). So, for example, assigning <literal>now()</literal> to a variable of type <type>timestamp</type> causes the variable to have the time of the current function call, not the time when the function was precompiled."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:360(programlisting) 
#, no-wrap
msgid "\nquantity integer DEFAULT 32;\nurl varchar := 'http://mysite.com';\nuser_id CONSTANT integer := 10;\n"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:358(para) /tmp/cicero-gTQe/plpgsql.xml:564(para) /tmp/cicero-gTQe/plpgsql.xml:894(para) /tmp/cicero-gTQe/plpgsql.xml:2075(para) /tmp/cicero-gTQe/plpgsql.xml:2137(para) /tmp/cicero-gTQe/plpgsql.xml:2767(para) /tmp/cicero-gTQe/plpgsql.xml:2843(para) /tmp/cicero-gTQe/plpgsql.xml:2890(para) 
msgid "Examples: <placeholder-1/>"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:368(title) 
msgid "Declaring Function Parameters"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:370(para) 
msgid "Parameters passed to functions are named with the identifiers <literal>$1</literal>, <literal>$2</literal>, etc. Optionally, aliases can be declared for <literal>$<replaceable>n</replaceable></literal> parameter names for increased readability. Either the alias or the numeric identifier can then be used to refer to the parameter value."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:383(programlisting) 
#, no-wrap
msgid "\nCREATE FUNCTION sales_tax(subtotal real) RETURNS real AS $$\nBEGIN\n    RETURN subtotal * 0.06;\nEND;\n$$ LANGUAGE plpgsql;\n"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:399(programlisting) 
#, no-wrap
msgid "\nCREATE FUNCTION sales_tax(real) RETURNS real AS $$\nDECLARE\n    subtotal ALIAS FOR $1;\nBEGIN\n    RETURN subtotal * 0.06;\nEND;\n$$ LANGUAGE plpgsql;\n"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:379(para) 
msgid "There are two ways to create an alias. The preferred way is to give a name to the parameter in the <command>CREATE FUNCTION</command> command, for example: <placeholder-1/> The other way, which was the only way available before <productname>PostgreSQL</productname> 8.0, is to explicitly declare an alias, using the declaration syntax <synopsis>\n<replaceable>name</replaceable> ALIAS FOR $<replaceable>n</replaceable>;\n</synopsis> The same example in this style looks like: <placeholder-2/>"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:411(para) 
msgid "These two examples are not perfectly equivalent. In the first case, <literal>subtotal</literal> could be referenced as <literal>sales_tax.subtotal</literal>, but in the second case it could not. (Had we attached a label to the inner block, <literal>subtotal</literal> could be qualified with that label, instead.)"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:422(programlisting) 
#, no-wrap
msgid "\nCREATE FUNCTION instr(varchar, integer) RETURNS integer AS $$\nDECLARE\n    v_string ALIAS FOR $1;\n    index ALIAS FOR $2;\nBEGIN\n    -- some computations using v_string and index here\nEND;\n$$ LANGUAGE plpgsql;\n\n\nCREATE FUNCTION concat_selected_fields(in_t sometablename) RETURNS text AS $$\nBEGIN\n    RETURN in_t.f1 || in_t.f3 || in_t.f5 || in_t.f7;\nEND;\n$$ LANGUAGE plpgsql;\n"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:420(para) 
msgid "Some more examples: <placeholder-1/>"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:451(programlisting) 
#, no-wrap
msgid "\nCREATE FUNCTION sales_tax(subtotal real, OUT tax real) AS $$\nBEGIN\n    tax := subtotal * 0.06;\nEND;\n$$ LANGUAGE plpgsql;\n"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:441(para) 
msgid "When a <application>PL/pgSQL</application> function is declared with output parameters, the output parameters are given <literal>$<replaceable>n</replaceable></literal> names and optional aliases in just the same way as the normal input parameters. An output parameter is effectively a variable that starts out NULL; it should be assigned to during the execution of the function. The final value of the parameter is what is returned. For instance, the sales-tax example could also be done this way: <placeholder-1/> Notice that we omitted <literal>RETURNS real</literal> — we could have included it, but it would be redundant."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:467(programlisting) 
#, no-wrap
msgid "\nCREATE FUNCTION sum_n_product(x int, y int, OUT sum int, OUT prod int) AS $$\nBEGIN\n    sum := x + y;\n    prod := x * y;\nEND;\n$$ LANGUAGE plpgsql;\n"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:463(para) 
msgid "Output parameters are most useful when returning multiple values. A trivial example is: <placeholder-1/> As discussed in <xref linkend=\"xfunc-output-parameters\"/>, this effectively creates an anonymous record type for the function's results. If a <literal>RETURNS</literal> clause is given, it must say <literal>RETURNS record</literal>."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:486(programlisting) 
#, no-wrap
msgid "\nCREATE FUNCTION extended_sales(p_itemno int)\nRETURNS TABLE(quantity int, total numeric) AS $$\nBEGIN\n    RETURN QUERY SELECT quantity, quantity * price FROM sales\n                 WHERE itemno = p_itemno;\nEND;\n$$ LANGUAGE plpgsql;\n"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:482(para) 
msgid "Another way to declare a <application>PL/pgSQL</application> function is with <literal>RETURNS TABLE</literal>, for example: <placeholder-1/> This is exactly equivalent to declaring one or more <literal>OUT</literal> parameters and specifying <literal>RETURNS SETOF <replaceable>sometype</replaceable></literal>."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:517(programlisting) 
#, no-wrap
msgid "\nCREATE FUNCTION add_three_values(v1 anyelement, v2 anyelement, v3 anyelement)\nRETURNS anyelement AS $$\nDECLARE\n    result ALIAS FOR $0;\nBEGIN\n    result := v1 + v2 + v3;\n    RETURN result;\nEND;\n$$ LANGUAGE plpgsql;\n"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:501(para) 
msgid "When the return type of a <application>PL/pgSQL</application> function is declared as a polymorphic type (<type>anyelement</type>, <type>anyarray</type>, <type>anynonarray</type>, or <type>anyenum</type>), a special parameter <literal>$0</literal> is created. Its data type is the actual return type of the function, as deduced from the actual input types (see <xref linkend=\"extend-types-polymorphic\"/>). This allows the function to access its actual return type as shown in <xref linkend=\"plpgsql-declaration-type\"/>. <literal>$0</literal> is initialized to null and can be modified by the function, so it can be used to hold the return value if desired, though that is not required. <literal>$0</literal> can also be given an alias. For example, this function works on any data type that has a <literal>+</literal> operator: <placeholder-1/>"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:536(programlisting) 
#, no-wrap
msgid "\nCREATE FUNCTION add_three_values(v1 anyelement, v2 anyelement, v3 anyelement,\n                                 OUT sum anyelement)\nAS $$\nBEGIN\n    sum := v1 + v2 + v3;\nEND;\n$$ LANGUAGE plpgsql;\n"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:530(para) 
msgid "The same effect can be had by declaring one or more output parameters as polymorphic types. In this case the special <literal>$0</literal> parameter is not used; the output parameters themselves serve the same purpose. For example: <placeholder-1/>"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:549(literal) 
msgid "ALIAS"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:552(replaceable) 
msgid "newname"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:552(replaceable) 
msgid "oldname"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:551(synopsis) 
#, no-wrap
msgid "\n<placeholder-1/> ALIAS FOR <placeholder-2/>;\n"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:555(para) 
msgid "The <literal>ALIAS</literal> syntax is more general than is suggested in the previous section: you can declare an alias for any variable, not just function parameters. The main practical use for this is to assign a different name for variables with predetermined names, such as <varname>NEW</varname> or <varname>OLD</varname> within a trigger procedure."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:566(programlisting) 
#, no-wrap
msgid "\nDECLARE\n  prior ALIAS FOR old;\n  updated ALIAS FOR new;\n"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:573(para) 
msgid "Since <literal>ALIAS</literal> creates two different ways to name the same object, unrestricted use can be confusing. It's best to use it only for the purpose of overriding predetermined names."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:581(title) 
msgid "Copying Types"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:584(replaceable) 
msgid "variable"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:583(synopsis) 
#, no-wrap
msgid "\n<placeholder-1/>%TYPE\n"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:594(programlisting) 
#, no-wrap
msgid "\nuser_id users.user_id%TYPE;\n"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:587(para) 
msgid "<literal>%TYPE</literal> provides the data type of a variable or table column. You can use this to declare variables that will hold database values. For example, let's say you have a column named <literal>user_id</literal> in your <literal>users</literal> table. To declare a variable with the same data type as <literal>users.user_id</literal> you write: <placeholder-1/>"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:599(para) 
msgid "By using <literal>%TYPE</literal> you don't need to know the data type of the structure you are referencing, and most importantly, if the data type of the referenced item changes in the future (for instance: you change the type of <literal>user_id</literal> from <type>integer</type> to <type>real</type>), you might not need to change your function definition."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:608(para) 
msgid "<literal>%TYPE</literal> is particularly valuable in polymorphic functions, since the data types needed for internal variables can change from one call to the next. Appropriate variables can be created by applying <literal>%TYPE</literal> to the function's arguments or result placeholders."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:619(title) 
msgid "Row Types"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:622(replaceable) /tmp/cicero-gTQe/plpgsql.xml:623(replaceable) /tmp/cicero-gTQe/plpgsql.xml:687(replaceable) /tmp/cicero-gTQe/plpgsql.xml:2193(replaceable) 
msgid "name"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:622(replaceable) 
msgid "table_name"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:622(literal) 
msgid "%ROWTYPE"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:623(replaceable) 
msgid "composite_type_name"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:621(synopsis) 
#, no-wrap
msgid "\n<placeholder-1/> <placeholder-2/><placeholder-3/>;\n<placeholder-4/> <placeholder-5/>;\n"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:626(para) 
msgid "A variable of a composite type is called a <firstterm>row</firstterm> variable (or <firstterm>row-type</firstterm> variable). Such a variable can hold a whole row of a <command>SELECT</command> or <command>FOR</command> query result, so long as that query's column set matches the declared type of the variable. The individual fields of the row value are accessed using the usual dot notation, for example <literal>rowvar.field</literal>."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:637(para) 
msgid "A row variable can be declared to have the same type as the rows of an existing table or view, by using the <replaceable>table_name</replaceable><literal>%ROWTYPE</literal> notation; or it can be declared by giving a composite type's name. (Since every table has an associated composite type of the same name, it actually does not matter in <productname>PostgreSQL</productname> whether you write <literal>%ROWTYPE</literal> or not. But the form with <literal>%ROWTYPE</literal> is more portable.)"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:648(para) 
msgid "Parameters to a function can be composite types (complete table rows). In that case, the corresponding identifier <literal>$<replaceable>n</replaceable></literal> will be a row variable, and fields can be selected from it, for example <literal>$1.user_id</literal>."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:655(para) 
msgid "Only the user-defined columns of a table row are accessible in a row-type variable, not the OID or other system columns (because the row could be from a view). The fields of the row type inherit the table's field size or precision for data types such as <type>char(<replaceable>n</replaceable>)</type>."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:668(programlisting) 
#, no-wrap
msgid "\nCREATE FUNCTION merge_fields(t_row table1) RETURNS text AS $$\nDECLARE\n    t2_row table2%ROWTYPE;\nBEGIN\n    SELECT * INTO t2_row FROM table2 WHERE ... ;\n    RETURN t_row.f1 || t2_row.f3 || t_row.f5 || t2_row.f7;\nEND;\n$$ LANGUAGE plpgsql;\n\nSELECT merge_fields(t.*) FROM table1 t WHERE ... ;\n"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:663(para) 
msgid "Here is an example of using composite types. <structname>table1</structname> and <structname>table2</structname> are existing tables having at least the mentioned fields: <placeholder-1/>"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:684(title) 
msgid "Record Types"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:686(synopsis) 
#, no-wrap
msgid "\n<placeholder-1/> RECORD;\n"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:690(para) 
msgid "Record variables are similar to row-type variables, but they have no predefined structure. They take on the actual row structure of the row they are assigned during a <command>SELECT</command> or <command>FOR</command> command. The substructure of a record variable can change each time it is assigned to. A consequence of this is that until a record variable is first assigned to, it has no substructure, and any attempt to access a field in it will draw a run-time error."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:700(para) 
msgid "Note that <literal>RECORD</literal> is not a true data type, only a placeholder. One should also realize that when a <application>PL/pgSQL</application> function is declared to return type <type>record</type>, this is not quite the same concept as a record variable, even though such a function might use a record variable to hold its result. In both cases the actual row structure is unknown when the function is written, but for a function returning <type>record</type> the actual structure is determined when the calling query is parsed, whereas a record variable can change its row structure on-the-fly."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:714(title) 
msgid "Collation of <application>PL/pgSQL</application> Variables"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:717(primary) 
msgid "collation"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:718(secondary) /tmp/cicero-gTQe/plpgsql.xml:977(secondary) /tmp/cicero-gTQe/plpgsql.xml:982(secondary) /tmp/cicero-gTQe/plpgsql.xml:1610(secondary) /tmp/cicero-gTQe/plpgsql.xml:1614(secondary) /tmp/cicero-gTQe/plpgsql.xml:2000(secondary) /tmp/cicero-gTQe/plpgsql.xml:2035(secondary) /tmp/cicero-gTQe/plpgsql.xml:2107(secondary) /tmp/cicero-gTQe/plpgsql.xml:2156(secondary) /tmp/cicero-gTQe/plpgsql.xml:2421(secondary) /tmp/cicero-gTQe/plpgsql.xml:2585(secondary) /tmp/cicero-gTQe/plpgsql.xml:3101(secondary) /tmp/cicero-gTQe/plpgsql.xml:3257(secondary) 
msgid "in PL/pgSQL"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:732(programlisting) 
#, no-wrap
msgid "\nCREATE FUNCTION less_than(a text, b text) RETURNS boolean AS $$\nBEGIN\n    RETURN a &lt; b;\nEND;\n$$ LANGUAGE plpgsql;\n\nSELECT less_than(text_field_1, text_field_2) FROM table1;\nSELECT less_than(text_field_1, text_field_2 COLLATE \"C\") FROM table1;\n"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:721(para) 
msgid "When a <application>PL/pgSQL</application> function has one or more parameters of collatable data types, a collation is identified for each function call depending on the collations assigned to the actual arguments, as described in <xref linkend=\"collation\"/>. If a collation is successfully identified (i.e., there are no conflicts of implicit collations among the arguments) then all the collatable parameters are treated as having that collation implicitly. This will affect the behavior of collation-sensitive operations within the function. For example, consider <placeholder-1/> The first use of <function>less_than</function> will use the common collation of <structfield>text_field_1</structfield> and <structfield>text_field_2</structfield> for the comparison, while the second use will use <literal>C</literal> collation."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:753(programlisting) 
#, no-wrap
msgid "\nCREATE FUNCTION less_than(a text, b text) RETURNS boolean AS $$\nDECLARE\n    local_a text := a;\n    local_b text := b;\nBEGIN\n    RETURN local_a &lt; local_b;\nEND;\n$$ LANGUAGE plpgsql;\n"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:748(para) 
msgid "Furthermore, the identified collation is also assumed as the collation of any local variables that are of collatable types. Thus this function would not work any differently if it were written as <placeholder-1/>"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:765(para) 
msgid "If there are no parameters of collatable data types, or no common collation can be identified for them, then parameters and local variables use the default collation of their data type (which is usually the database's default collation, but could be different for variables of domain types)."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:778(programlisting) 
#, no-wrap
msgid "\nDECLARE\n    local_a text COLLATE \"en_US\";\n"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:773(para) 
msgid "A local variable of a collatable data type can have a different collation associated with it by including the <literal>COLLATE</literal> option in its declaration, for example <placeholder-1/> This option overrides the collation that would otherwise be given to the variable according to the rules above."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:792(programlisting) 
#, no-wrap
msgid "\nCREATE FUNCTION less_than_c(a text, b text) RETURNS boolean AS $$\nBEGIN\n    RETURN a &lt; b COLLATE \"C\";\nEND;\n$$ LANGUAGE plpgsql;\n"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:787(para) 
msgid "Also, of course explicit <literal>COLLATE</literal> clauses can be written inside a function if it is desired to force a particular collation to be used in a particular operation. For example, <placeholder-1/> This overrides the collations associated with the table columns, parameters, or local variables used in the expression, just as would happen in a plain SQL command."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:808(title) 
msgid "Expressions"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:833(programlisting) 
#, no-wrap
msgid "\nIF x &lt; y THEN ...\n"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:837(programlisting) 
#, no-wrap
msgid "\nPREPARE <replaceable>statement_name</replaceable>(integer, integer) AS SELECT $1 &lt; $2;\n"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:810(para) 
msgid "All expressions used in <application>PL/pgSQL</application> statements are processed using the server's main <acronym>SQL</acronym> executor. For example, when you write a <application>PL/pgSQL</application> statement like <synopsis>\nIF <replaceable>expression</replaceable> THEN ...\n</synopsis><application>PL/pgSQL</application> will evaluate the expression by feeding a query like <synopsis>\nSELECT <replaceable>expression</replaceable>\n</synopsis> to the main SQL engine. While forming the <command>SELECT</command> command, any occurrences of <application>PL/pgSQL</application> variable names are replaced by parameters, as discussed in detail in <xref linkend=\"plpgsql-var-subst\"/>. This allows the query plan for the <command>SELECT</command> to be prepared just once and then reused for subsequent evaluations with different values of the variables. Thus, what really happens on first use of an expression is essentially a <command>PREPARE</command> command. For example, if we have declared two integer variables <literal>x</literal> and <literal>y</literal>, and we write <placeholder-1/> what happens behind the scenes is equivalent to <placeholder-2/> and then this prepared statement is <command>EXECUTE</command>d for each execution of the <command>IF</command> statement, with the current values of the <application>PL/pgSQL</application> variables supplied as parameter values. The query plan prepared in this way is saved for the life of the database connection, as described in <xref linkend=\"plpgsql-plan-caching\"/>. Normally these details are not important to a <application>PL/pgSQL</application> user, but they are useful to know when trying to diagnose a problem."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:853(title) 
msgid "Basic Statements"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:855(para) 
msgid "In this section and the following ones, we describe all the statement types that are explicitly understood by <application>PL/pgSQL</application>. Anything not recognized as one of these statement types is presumed to be an SQL command and is sent to the main database engine to execute, as described in <xref linkend=\"plpgsql-statements-sql-noresult\"/> and <xref linkend=\"plpgsql-statements-sql-onerow\"/>."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:866(title) 
msgid "Assignment"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:868(para) 
msgid "An assignment of a value to a <application>PL/pgSQL</application> variable is written as: <synopsis>\n<replaceable>variable</replaceable> := <replaceable>expression</replaceable>;\n</synopsis> As explained previously, the expression in such a statement is evaluated by means of an SQL <command>SELECT</command> command sent to the main database engine. The expression must yield a single value (possibly a row value, if the variable is a row or record variable). The target variable can be a simple variable (optionally qualified with a block name), a field of a row or record variable, or an element of an array that is a simple variable or field."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:883(para) 
msgid "If the expression's result data type doesn't match the variable's data type, or the variable has a specific size/precision (like <type>char(20)</type>), the result value will be implicitly converted by the <application>PL/pgSQL</application> interpreter using the result type's output-function and the variable type's input-function. Note that this could potentially result in run-time errors generated by the input function, if the string form of the result value is not acceptable to the input function."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:896(programlisting) 
#, no-wrap
msgid "\ntax := subtotal * 0.06;\nmy_record.user_id := 20;\n"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:904(title) 
msgid "Executing a Command With No Result"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:906(para) 
msgid "For any SQL command that does not return rows, for example <command>INSERT</command> without a <literal>RETURNING</literal> clause, you can execute the command within a <application>PL/pgSQL</application> function just by writing the command."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:913(para) 
msgid "Any <application>PL/pgSQL</application> variable name appearing in the command text is treated as a parameter, and then the current value of the variable is provided as the parameter value at run time. This is exactly like the processing described earlier for expressions; for details see <xref linkend=\"plpgsql-var-subst\"/>."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:921(para) 
msgid "When executing a SQL command in this way, <application>PL/pgSQL</application> plans the command just once and re-uses the plan on subsequent executions, for the life of the database connection. The implications of this are discussed in detail in <xref linkend=\"plpgsql-plan-caching\"/>."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:929(para) 
msgid "Sometimes it is useful to evaluate an expression or <command>SELECT</command> query but discard the result, for example when calling a function that has side-effects but no useful result value. To do this in <application>PL/pgSQL</application>, use the <command>PERFORM</command> statement: <synopsis>\nPERFORM <replaceable>query</replaceable>;\n</synopsis> This executes <replaceable>query</replaceable> and discards the result. Write the <replaceable>query</replaceable> the same way you would write an SQL <command>SELECT</command> command, but replace the initial keyword <command>SELECT</command> with <command>PERFORM</command>. <application>PL/pgSQL</application> variables will be substituted into the query just as for commands that return no result, and the plan is cached in the same way. Also, the special variable <literal>FOUND</literal> is set to true if the query produced at least one row, or false if it produced no rows (see <xref linkend=\"plpgsql-statements-diagnostics\"/>)."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:953(para) 
msgid "One might expect that writing <command>SELECT</command> directly would accomplish this result, but at present the only accepted way to do it is <command>PERFORM</command>. A SQL command that can return rows, such as <command>SELECT</command>, will be rejected as an error unless it has an <literal>INTO</literal> clause as discussed in the next section."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:966(programlisting) 
#, no-wrap
msgid "\nPERFORM create_mv('cs_session_page_requests_mv', my_query);\n"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:964(para) /tmp/cicero-gTQe/plpgsql.xml:1407(para) /tmp/cicero-gTQe/plpgsql.xml:2691(para) /tmp/cicero-gTQe/plpgsql.xml:2919(para) /tmp/cicero-gTQe/plpgsql.xml:2940(para) 
msgid "An example: <placeholder-1/>"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:973(title) 
msgid "Executing a Query with a Single-row Result"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:976(primary) 
msgid "SELECT INTO"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:981(primary) 
msgid "RETURNING INTO"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:985(para) 
msgid "The result of a SQL command yielding a single row (possibly of multiple columns) can be assigned to a record variable, row-type variable, or list of scalar variables. This is done by writing the base SQL command and adding an <literal>INTO</literal> clause. For example, <synopsis>\nSELECT <replaceable>select_expressions</replaceable> INTO <optional>STRICT</optional> <replaceable>target</replaceable> FROM ...;\nINSERT ... RETURNING <replaceable>expressions</replaceable> INTO <optional>STRICT</optional> <replaceable>target</replaceable>;\nUPDATE ... RETURNING <replaceable>expressions</replaceable> INTO <optional>STRICT</optional> <replaceable>target</replaceable>;\nDELETE ... RETURNING <replaceable>expressions</replaceable> INTO <optional>STRICT</optional> <replaceable>target</replaceable>;\n</synopsis> where <replaceable>target</replaceable> can be a record variable, a row variable, or a comma-separated list of simple variables and record/row fields. <application>PL/pgSQL</application> variables will be substituted into the rest of the query, and the plan is cached, just as described above for commands that do not return rows. This works for <command>SELECT</command>, <command>INSERT</command>/<command>UPDATE</command>/<command>DELETE</command> with <literal>RETURNING</literal>, and utility commands that return row-set results (such as <command>EXPLAIN</command>). Except for the <literal>INTO</literal> clause, the SQL command is the same as it would be written outside <application>PL/pgSQL</application>."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:1013(para) 
msgid "Note that this interpretation of <command>SELECT</command> with <literal>INTO</literal> is quite different from <productname>PostgreSQL</productname>'s regular <command>SELECT INTO</command> command, wherein the <literal>INTO</literal> target is a newly created table. If you want to create a table from a <command>SELECT</command> result inside a <application>PL/pgSQL</application> function, use the syntax <command>CREATE TABLE ... AS SELECT</command>."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:1024(para) 
msgid "If a row or a variable list is used as target, the query's result columns must exactly match the structure of the target as to number and data types, or else a run-time error occurs. When a record variable is the target, it automatically configures itself to the row type of the query result columns."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:1032(para) 
msgid "The <literal>INTO</literal> clause can appear almost anywhere in the SQL command. Customarily it is written either just before or just after the list of <replaceable>select_expressions</replaceable> in a <command>SELECT</command> command, or at the end of the command for other command types. It is recommended that you follow this convention in case the <application>PL/pgSQL</application> parser becomes stricter in future versions."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:1053(programlisting) 
#, no-wrap
msgid "\nSELECT * INTO myrec FROM emp WHERE empname = myname;\nIF NOT FOUND THEN\n    RAISE EXCEPTION 'employee % not found', myname;\nEND IF;\n"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:1066(programlisting) 
#, no-wrap
msgid "\nBEGIN\n    SELECT * INTO STRICT myrec FROM emp WHERE empname = myname;\n    EXCEPTION\n        WHEN NO_DATA_FOUND THEN\n            RAISE EXCEPTION 'employee % not found', myname;\n        WHEN TOO_MANY_ROWS THEN\n            RAISE EXCEPTION 'employee % not unique', myname;\nEND;\n"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:1042(para) 
msgid "If <literal>STRICT</literal> is not specified in the <literal>INTO</literal> clause, then <replaceable>target</replaceable> will be set to the first row returned by the query, or to nulls if the query returned no rows. (Note that <quote>the first row</quote> is not well-defined unless you've used <literal>ORDER BY</literal>.) Any result rows after the first row are discarded. You can check the special <literal>FOUND</literal> variable (see <xref linkend=\"plpgsql-statements-diagnostics\"/>) to determine whether a row was returned: <placeholder-1/> If the <literal>STRICT</literal> option is specified, the query must return exactly one row or a run-time error will be reported, either <literal>NO_DATA_FOUND</literal> (no rows) or <literal>TOO_MANY_ROWS</literal> (more than one row). You can use an exception block if you wish to catch the error, for example: <placeholder-2/> Successful execution of a command with <literal>STRICT</literal> always sets <literal>FOUND</literal> to true."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:1080(para) 
msgid "For <command>INSERT</command>/<command>UPDATE</command>/<command>DELETE</command> with <literal>RETURNING</literal>, <application>PL/pgSQL</application> reports an error for more than one returned row, even when <literal>STRICT</literal> is not specified. This is because there is no option such as <literal>ORDER BY</literal> with which to determine which affected row should be returned."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:1090(para) 
msgid "The <literal>STRICT</literal> option matches the behavior of Oracle PL/SQL's <command>SELECT INTO</command> and related statements."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:1096(para) 
msgid "To handle cases where you need to process multiple result rows from a SQL query, see <xref linkend=\"plpgsql-records-iterating\"/>."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:1104(title) 
msgid "Executing Dynamic Commands"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:1106(para) 
msgid "Oftentimes you will want to generate dynamic commands inside your <application>PL/pgSQL</application> functions, that is, commands that will involve different tables or different data types each time they are executed. <application>PL/pgSQL</application>'s normal attempts to cache plans for commands (as discussed in <xref linkend=\"plpgsql-plan-caching\"/>) will not work in such scenarios. To handle this sort of problem, the <command>EXECUTE</command> statement is provided: <synopsis>\nEXECUTE <replaceable class=\"command\">command-string</replaceable> <optional> INTO <optional>STRICT</optional> <replaceable>target</replaceable> </optional> <optional> USING <replaceable>expression</replaceable> <optional>, ... </optional> </optional>;\n</synopsis> where <replaceable>command-string</replaceable> is an expression yielding a string (of type <type>text</type>) containing the command to be executed. The optional <replaceable>target</replaceable> is a record variable, a row variable, or a comma-separated list of simple variables and record/row fields, into which the results of the command will be stored. The optional <literal>USING</literal> expressions supply values to be inserted into the command."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:1129(para) 
msgid "No substitution of <application>PL/pgSQL</application> variables is done on the computed command string. Any required variable values must be inserted in the command string as it is constructed; or you can use parameters as described below."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:1136(para) 
msgid "Also, there is no plan caching for commands executed via <command>EXECUTE</command>. Instead, the command is prepared each time the statement is run. Thus the command string can be dynamically created within the function to perform actions on different tables and columns."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:1144(para) 
msgid "The <literal>INTO</literal> clause specifies where the results of a SQL command returning rows should be assigned. If a row or variable list is provided, it must exactly match the structure of the query's results (when a record variable is used, it will configure itself to match the result structure automatically). If multiple rows are returned, only the first will be assigned to the <literal>INTO</literal> variable. If no rows are returned, NULL is assigned to the <literal>INTO</literal> variable(s). If no <literal>INTO</literal> clause is specified, the query results are discarded."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:1157(para) 
msgid "If the <literal>STRICT</literal> option is given, an error is reported unless the query produces exactly one row."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:1171(programlisting) 
#, no-wrap
msgid "\nEXECUTE 'SELECT count(*) FROM mytable WHERE inserted_by = $1 AND inserted &lt;= $2'\n   INTO c\n   USING checked_user, checked_date;\n"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:1162(para) 
msgid "The command string can use parameter values, which are referenced in the command as <literal>$1</literal>, <literal>$2</literal>, etc. These symbols refer to values supplied in the <literal>USING</literal> clause. This method is often preferable to inserting data values into the command string as text: it avoids run-time overhead of converting the values to text and back, and it is much less prone to SQL-injection attacks since there is no need for quoting or escaping. An example is: <placeholder-1/>"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:1184(programlisting) 
#, no-wrap
msgid "\nEXECUTE 'SELECT count(*) FROM '\n    || tabname::regclass\n    || ' WHERE inserted_by = $1 AND inserted &lt;= $2'\n   INTO c\n   USING checked_user, checked_date;\n"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:1178(para) 
msgid "Note that parameter symbols can only be used for data values — if you want to use dynamically determined table or column names, you must insert them into the command string textually. For example, if the preceding query needed to be done against a dynamically selected table, you could do this: <placeholder-1/> Another restriction on parameter symbols is that they only work in <command>SELECT</command>, <command>INSERT</command>, <command>UPDATE</command>, and <command>DELETE</command> commands. In other statement types (generically called utility statements), you must insert values textually even if they are just data values."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:1198(para) 
msgid "An <command>EXECUTE</command> with a simple constant command string and some <literal>USING</literal> parameters, as in the first example above, is functionally equivalent to just writing the command directly in <application>PL/pgSQL</application> and allowing replacement of <application>PL/pgSQL</application> variables to happen automatically. The important difference is that <command>EXECUTE</command> will re-plan the command on each execution, generating a plan that is specific to the current parameter values; whereas <application>PL/pgSQL</application> normally creates a generic plan and caches it for re-use. In situations where the best plan depends strongly on the parameter values, <command>EXECUTE</command> can be significantly faster; while when the plan is not sensitive to parameter values, re-planning will be a waste."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:1214(para) 
msgid "<command>SELECT INTO</command> is not currently supported within <command>EXECUTE</command>; instead, execute a plain <command>SELECT</command> command and specify <literal>INTO</literal> as part of the <command>EXECUTE</command> itself."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:1222(para) 
msgid "The <application>PL/pgSQL</application><command>EXECUTE</command> statement is not related to the <xref linkend=\"sql-execute\"/> SQL statement supported by the <productname>PostgreSQL</productname> server. The server's <command>EXECUTE</command> statement cannot be used directly within <application>PL/pgSQL</application> functions (and is not needed)."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:1234(title) 
msgid "Quoting Values In Dynamic Queries"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:1237(primary) 
msgid "quote_ident"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:1238(secondary) /tmp/cicero-gTQe/plpgsql.xml:1243(secondary) /tmp/cicero-gTQe/plpgsql.xml:1248(secondary) /tmp/cicero-gTQe/plpgsql.xml:1253(secondary) 
msgid "use in PL/pgSQL"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:1242(primary) 
msgid "quote_literal"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:1247(primary) 
msgid "quote_nullable"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:1252(primary) 
msgid "format"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:1256(para) 
msgid "When working with dynamic commands you will often have to handle escaping of single quotes. The recommended method for quoting fixed text in your function body is dollar quoting. (If you have legacy code that does not use dollar quoting, please refer to the overview in <xref linkend=\"plpgsql-quote-tips\"/>, which can save you some effort when translating said code to a more reasonable scheme.)"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:1271(programlisting) 
#, no-wrap
msgid "\nEXECUTE 'UPDATE tbl SET '\n        || quote_ident(colname)\n        || ' = '\n        || quote_literal(newvalue)\n        || ' WHERE key = '\n        || quote_literal(keyvalue);\n"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:1265(para) 
msgid "Dynamic values that are to be inserted into the constructed query require careful handling since they might themselves contain quote characters. An example (this assumes that you are using dollar quoting for the function as a whole, so the quote marks need not be doubled): <placeholder-1/>"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:1281(para) 
msgid "This example demonstrates the use of the <function>quote_ident</function> and <function>quote_literal</function> functions (see <xref linkend=\"functions-string\"/>). For safety, expressions containing column or table identifiers should be passed through <function>quote_ident</function> before insertion in a dynamic query. Expressions containing values that should be literal strings in the constructed command should be passed through <function>quote_literal</function>. These functions take the appropriate steps to return the input text enclosed in double or single quotes respectively, with any embedded special characters properly escaped."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:1305(programlisting) 
#, no-wrap
msgid "\nEXECUTE 'UPDATE tbl SET '\n        || quote_ident(colname)\n        || ' = '\n        || quote_nullable(newvalue)\n        || ' WHERE key = '\n        || quote_nullable(keyvalue);\n"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:1295(para) 
msgid "Because <function>quote_literal</function> is labelled <literal>STRICT</literal>, it will always return null when called with a null argument. In the above example, if <literal>newvalue</literal> or <literal>keyvalue</literal> were null, the entire dynamic query string would become null, leading to an error from <command>EXECUTE</command>. You can avoid this problem by using the <function>quote_nullable</function> function, which works the same as <function>quote_literal</function> except that when called with a null argument it returns the string <literal>NULL</literal>. For example, <placeholder-1/> If you are dealing with values that might be null, you should usually use <function>quote_nullable</function> in place of <function>quote_literal</function>."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:1320(programlisting) 
#, no-wrap
msgid "\n'WHERE key = ' || quote_nullable(keyvalue)\n"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:1327(programlisting) 
#, no-wrap
msgid "\n'WHERE key IS NOT DISTINCT FROM ' || quote_nullable(keyvalue)\n"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:1317(para) 
msgid "As always, care must be taken to ensure that null values in a query do not deliver unintended results. For example the <literal>WHERE</literal> clause <placeholder-1/> will never succeed if <literal>keyvalue</literal> is null, because the result of using the equality operator <literal>=</literal> with a null operand is always null. If you wish null to work like an ordinary key value, you would need to rewrite the above as <placeholder-2/> (At present, <literal>IS NOT DISTINCT FROM</literal> is handled much less efficiently than <literal>=</literal>, so don't do this unless you must. See <xref linkend=\"functions-comparison\"/> for more information on nulls and <literal>IS DISTINCT</literal>.)"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:1339(programlisting) 
#, no-wrap
msgid "\nEXECUTE 'UPDATE tbl SET '\n        || quote_ident(colname)\n        || ' = $$'\n        || newvalue\n        || '$$ WHERE key = '\n        || quote_literal(keyvalue);\n"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:1336(para) 
msgid "Note that dollar quoting is only useful for quoting fixed text. It would be a very bad idea to try to write this example as: <placeholder-1/> because it would break if the contents of <literal>newvalue</literal> happened to contain <literal>$$</literal>. The same objection would apply to any other dollar-quoting delimiter you might pick. So, to safely quote text that is not known in advance, you <emphasis>must</emphasis> use <function>quote_literal</function>, <function>quote_nullable</function>, or <function>quote_ident</function>, as appropriate."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:1359(programlisting) 
#, no-wrap
msgid "\nEXECUTE format('UPDATE tbl SET %I = %L WHERE key = %L', colname, newvalue, keyvalue);\n"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:1364(programlisting) 
#, no-wrap
msgid "\nEXECUTE format('UPDATE tbl SET %I = $1 WHERE key = $2', colname)\n   USING newvalue, keyvalue;\n"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:1355(para) 
msgid "Dynamic SQL statements can also be safely constructed using the <function>format</function> function (see <xref linkend=\"functions-string\"/>). For example: <placeholder-1/> The <function>format</function> function can be used in conjunction with the <literal>USING</literal> clause: <placeholder-2/> This form is more efficient, because the parameters <literal>newvalue</literal> and <literal>keyvalue</literal> are not converted to text."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:1374(para) 
msgid "A much larger example of a dynamic command and <command>EXECUTE</command> can be seen in <xref linkend=\"plpgsql-porting-ex2\"/>, which builds and executes a <command>CREATE FUNCTION</command> command to define a new function."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:1383(title) 
msgid "Obtaining the Result Status"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:1385(para) 
msgid "There are several ways to determine the effect of a command. The first method is to use the <command>GET DIAGNOSTICS</command> command, which has the form: <synopsis>\nGET DIAGNOSTICS <replaceable>variable</replaceable> = <replaceable>item</replaceable> <optional> , ... </optional>;\n</synopsis> This command allows retrieval of system status indicators. Each <replaceable>item</replaceable> is a key word identifying a state value to be assigned to the specified variable (which should be of the right data type to receive it). The currently available status items are <varname>ROW_COUNT</varname>, the number of rows processed by the last <acronym>SQL</acronym> command sent to the <acronym>SQL</acronym> engine, and <varname>RESULT_OID</varname>, the OID of the last row inserted by the most recent <acronym>SQL</acronym> command. Note that <varname>RESULT_OID</varname> is only useful after an <command>INSERT</command> command into a table containing OIDs."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:1409(programlisting) 
#, no-wrap
msgid "\nGET DIAGNOSTICS integer_var = ROW_COUNT;\n"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:1423(para) 
msgid "A <command>SELECT INTO</command> statement sets <literal>FOUND</literal> true if a row is assigned, false if no row is returned."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:1430(para) 
msgid "A <command>PERFORM</command> statement sets <literal>FOUND</literal> true if it produces (and discards) one or more rows, false if no row is produced."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:1437(para) 
msgid "<command>UPDATE</command>, <command>INSERT</command>, and <command>DELETE</command> statements set <literal>FOUND</literal> true if at least one row is affected, false if no row is affected."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:1444(para) 
msgid "A <command>FETCH</command> statement sets <literal>FOUND</literal> true if it returns a row, false if no row is returned."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:1450(para) 
msgid "A <command>MOVE</command> statement sets <literal>FOUND</literal> true if it successfully repositions the cursor, false otherwise."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:1456(para) 
msgid "A <command>FOR</command> or <command>FOREACH</command> statement sets <literal>FOUND</literal> true if it iterates one or more times, else false. <literal>FOUND</literal> is set this way when the loop exits; inside the execution of the loop, <literal>FOUND</literal> is not modified by the loop statement, although it might be changed by the execution of other statements within the loop body."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:1468(para) 
msgid "<command>RETURN QUERY</command> and <command>RETURN QUERY EXECUTE</command> statements set <literal>FOUND</literal> true if the query returns at least one row, false if no row is returned."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:1414(para) 
msgid "The second method to determine the effects of a command is to check the special variable named <literal>FOUND</literal>, which is of type <type>boolean</type>. <literal>FOUND</literal> starts out false within each <application>PL/pgSQL</application> function call. It is set by each of the following types of statements: <placeholder-1/> Other <application>PL/pgSQL</application> statements do not change the state of <literal>FOUND</literal>. Note in particular that <command>EXECUTE</command> changes the output of <command>GET DIAGNOSTICS</command>, but does not change <literal>FOUND</literal>."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:1484(para) 
msgid "<literal>FOUND</literal> is a local variable within each <application>PL/pgSQL</application> function; any changes to it affect only the current function."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:1493(title) 
msgid "Doing Nothing At All"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:1495(para) 
msgid "Sometimes a placeholder statement that does nothing is useful. For example, it can indicate that one arm of an if/then/else chain is deliberately empty. For this purpose, use the <command>NULL</command> statement: <synopsis>\nNULL;\n</synopsis>"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:1508(programlisting) 
#, no-wrap
msgid "\nBEGIN\n    y := x / 0;\nEXCEPTION\n    WHEN division_by_zero THEN\n        NULL;  -- ignore the error\nEND;\n"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:1517(programlisting) 
#, no-wrap
msgid "\nBEGIN\n    y := x / 0;\nEXCEPTION\n    WHEN division_by_zero THEN  -- ignore the error\nEND;\n"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:1506(para) 
msgid "For example, the following two fragments of code are equivalent: <placeholder-1/><placeholder-2/> Which is preferable is a matter of taste."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:1528(para) 
msgid "In Oracle's PL/SQL, empty statement lists are not allowed, and so <command>NULL</command> statements are <emphasis>required</emphasis> for situations such as this. <application>PL/pgSQL</application> allows you to just write nothing, instead."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:1540(title) 
msgid "Control Structures"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:1542(para) 
msgid "Control structures are probably the most useful (and important) part of <application>PL/pgSQL</application>. With <application>PL/pgSQL</application>'s control structures, you can manipulate <productname>PostgreSQL</productname> data in a very flexible and powerful way."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:1551(title) 
msgid "Returning From a Function"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:1553(para) 
msgid "There are two commands available that allow you to return data from a function: <command>RETURN</command> and <command>RETURN NEXT</command>."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:1560(command) 
msgid "RETURN"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:1563(replaceable) /tmp/cicero-gTQe/plpgsql.xml:1618(replaceable) /tmp/cicero-gTQe/plpgsql.xml:1620(replaceable) /tmp/cicero-gTQe/plpgsql.xml:1905(replaceable) /tmp/cicero-gTQe/plpgsql.xml:1905(replaceable) /tmp/cicero-gTQe/plpgsql.xml:1907(replaceable) /tmp/cicero-gTQe/plpgsql.xml:1907(replaceable) /tmp/cicero-gTQe/plpgsql.xml:2193(replaceable) /tmp/cicero-gTQe/plpgsql.xml:2193(replaceable) /tmp/cicero-gTQe/plpgsql.xml:2193(replaceable) /tmp/cicero-gTQe/plpgsql.xml:2704(replaceable) 
msgid "expression"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:1562(synopsis) 
#, no-wrap
msgid "\nRETURN <placeholder-1/>;\n"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:1566(para) 
msgid "<command>RETURN</command> with an expression terminates the function and returns the value of <replaceable>expression</replaceable> to the caller. This form is used for <application>PL/pgSQL</application> functions that do not return a set."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:1574(para) 
msgid "When returning a scalar type, any expression can be used. The expression's result will be automatically cast into the function's return type as described for assignments. To return a composite (row) value, you must write a record or row variable as the <replaceable>expression</replaceable>."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:1582(para) 
msgid "If you declared the function with output parameters, write just <command>RETURN</command> with no expression. The current values of the output parameter variables will be returned."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:1588(para) 
msgid "If you declared the function to return <type>void</type>, a <command>RETURN</command> statement can be used to exit the function early; but do not write an expression following <command>RETURN</command>."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:1595(para) 
msgid "The return value of a function cannot be left undefined. If control reaches the end of the top-level block of the function without hitting a <command>RETURN</command> statement, a run-time error will occur. This restriction does not apply to functions with output parameters and functions returning <type>void</type>, however. In those cases a <command>RETURN</command> statement is automatically executed if the top-level block finishes."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:1607(title) 
msgid "<command>RETURN NEXT</command> and <command>RETURN QUERY</command>"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:1609(primary) 
msgid "RETURN NEXT"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:1613(primary) 
msgid "RETURN QUERY"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:1619(replaceable) /tmp/cicero-gTQe/plpgsql.xml:2666(replaceable) /tmp/cicero-gTQe/plpgsql.xml:2669(replaceable) 
msgid "query"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:1620(replaceable) 
msgid "command-string"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:1620(optional) /tmp/cicero-gTQe/plpgsql.xml:2704(optional) 
msgid ", ..."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:1620(optional) /tmp/cicero-gTQe/plpgsql.xml:2704(optional) 
msgid "USING <placeholder-1/><placeholder-2/>"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:1617(synopsis) 
#, no-wrap
msgid "\nRETURN NEXT <placeholder-1/>;\nRETURN QUERY <placeholder-2/>;\nRETURN QUERY EXECUTE <placeholder-3/> <placeholder-4/>;\n"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:1623(para) 
msgid "When a <application>PL/pgSQL</application> function is declared to return <literal>SETOF <replaceable>sometype</replaceable></literal>, the procedure to follow is slightly different. In that case, the individual items to return are specified by a sequence of <command>RETURN NEXT</command> or <command>RETURN QUERY</command> commands, and then a final <command>RETURN</command> command with no argument is used to indicate that the function has finished executing. <command>RETURN NEXT</command> can be used with both scalar and composite data types; with a composite result type, an entire <quote>table</quote> of results will be returned. <command>RETURN QUERY</command> appends the results of executing a query to the function's result set. <command>RETURN NEXT</command> and <command>RETURN QUERY</command> can be freely intermixed in a single set-returning function, in which case their results will be concatenated."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:1641(para) 
msgid "<command>RETURN NEXT</command> and <command>RETURN QUERY</command> do not actually return from the function — they simply append zero or more rows to the function's result set. Execution then continues with the next statement in the <application>PL/pgSQL</application> function. As successive <command>RETURN NEXT</command> or <command>RETURN QUERY</command> commands are executed, the result set is built up. A final <command>RETURN</command>, which should have no argument, causes control to exit the function (or you can just let control reach the end of the function)."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:1654(para) 
msgid "<command>RETURN QUERY</command> has a variant <command>RETURN QUERY EXECUTE</command>, which specifies the query to be executed dynamically. Parameter expressions can be inserted into the computed query string via <literal>USING</literal>, in just the same way as in the <command>EXECUTE</command> command."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:1662(para) 
msgid "If you declared the function with output parameters, write just <command>RETURN NEXT</command> with no expression. On each execution, the current values of the output parameter variable(s) will be saved for eventual return as a row of the result. Note that you must declare the function as returning <literal>SETOF record</literal> when there are multiple output parameters, or <literal>SETOF <replaceable>sometype</replaceable></literal> when there is just one output parameter of type <replaceable>sometype</replaceable>, in order to create a set-returning function with output parameters."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:1679(programlisting) 
#, no-wrap
msgid "\nCREATE TABLE foo (fooid INT, foosubid INT, fooname TEXT);\nINSERT INTO foo VALUES (1, 2, 'three');\nINSERT INTO foo VALUES (4, 5, 'six');\n\nCREATE OR REPLACE FUNCTION getAllFoo() RETURNS SETOF foo AS\n$BODY$\nDECLARE\n    r foo%rowtype;\nBEGIN\n    FOR r IN SELECT * FROM foo\n    WHERE fooid &gt; 0\n    LOOP\n        -- can do some processing here\n        RETURN NEXT r; -- return current row of SELECT\n    END LOOP;\n    RETURN;\nEND\n$BODY$\nLANGUAGE 'plpgsql' ;\n\nSELECT * FROM getallfoo();\n"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:1675(para) 
msgid "Here is an example of a function using <command>RETURN NEXT</command>: <placeholder-1/>"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:1705(para) 
msgid "The current implementation of <command>RETURN NEXT</command> and <command>RETURN QUERY</command> stores the entire result set before returning from the function, as discussed above. That means that if a <application>PL/pgSQL</application> function produces a very large result set, performance might be poor: data will be written to disk to avoid memory exhaustion, but the function itself will not return until the entire result set has been generated. A future version of <application>PL/pgSQL</application> might allow users to define set-returning functions that do not have this limitation. Currently, the point at which data begins being written to disk is controlled by the <xref linkend=\"guc-work-mem\"/> configuration variable. Administrators who have sufficient memory to store larger result sets in memory should consider increasing this parameter."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:1727(title) 
msgid "Conditionals"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:1735(literal) 
msgid "IF ... THEN"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:1738(literal) 
msgid "IF ... THEN ... ELSE"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:1741(literal) 
msgid "IF ... THEN ... ELSIF ... THEN ... ELSE"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:1748(literal) 
msgid "CASE ... WHEN ... THEN ... ELSE ... END CASE"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:1751(literal) 
msgid "CASE WHEN ... THEN ... ELSE ... END CASE"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:1729(para) 
msgid "<command>IF</command> and <command>CASE</command> statements let you execute alternative commands based on certain conditions. <application>PL/pgSQL</application> has three forms of <command>IF</command>: <placeholder-1/> and two forms of <command>CASE</command>: <placeholder-2/>"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:1757(literal) 
msgid "IF-THEN"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:1760(replaceable) /tmp/cicero-gTQe/plpgsql.xml:1787(replaceable) /tmp/cicero-gTQe/plpgsql.xml:1828(replaceable) /tmp/cicero-gTQe/plpgsql.xml:1830(replaceable) /tmp/cicero-gTQe/plpgsql.xml:1832(replaceable) /tmp/cicero-gTQe/plpgsql.xml:1948(replaceable) /tmp/cicero-gTQe/plpgsql.xml:1950(replaceable) /tmp/cicero-gTQe/plpgsql.xml:2039(replaceable) /tmp/cicero-gTQe/plpgsql.xml:2111(replaceable) /tmp/cicero-gTQe/plpgsql.xml:2161(replaceable) 
msgid "boolean-expression"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:1761(replaceable) /tmp/cicero-gTQe/plpgsql.xml:1788(replaceable) /tmp/cicero-gTQe/plpgsql.xml:1790(replaceable) /tmp/cicero-gTQe/plpgsql.xml:1829(replaceable) /tmp/cicero-gTQe/plpgsql.xml:1831(replaceable) /tmp/cicero-gTQe/plpgsql.xml:1833(replaceable) /tmp/cicero-gTQe/plpgsql.xml:1838(replaceable) /tmp/cicero-gTQe/plpgsql.xml:1906(replaceable) /tmp/cicero-gTQe/plpgsql.xml:1908(replaceable) /tmp/cicero-gTQe/plpgsql.xml:1911(replaceable) /tmp/cicero-gTQe/plpgsql.xml:1949(replaceable) /tmp/cicero-gTQe/plpgsql.xml:1951(replaceable) /tmp/cicero-gTQe/plpgsql.xml:1954(replaceable) /tmp/cicero-gTQe/plpgsql.xml:2016(replaceable) /tmp/cicero-gTQe/plpgsql.xml:2162(replaceable) /tmp/cicero-gTQe/plpgsql.xml:2194(replaceable) 
msgid "statements"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:1759(synopsis) 
#, no-wrap
msgid "\nIF <placeholder-1/> THEN\n    <placeholder-2/>\nEND IF;\n"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:1765(para) 
msgid "<literal>IF-THEN</literal> statements are the simplest form of <literal>IF</literal>. The statements between <literal>THEN</literal> and <literal>END IF</literal> will be executed if the condition is true. Otherwise, they are skipped."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:1775(programlisting) 
#, no-wrap
msgid "\nIF v_user_id &lt;&gt; 0 THEN\n    UPDATE users SET email = v_email WHERE user_id = v_user_id;\nEND IF;\n"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:1773(para) 
msgid "Example: <placeholder-1/>"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:1784(literal) 
msgid "IF-THEN-ELSE"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:1786(synopsis) 
#, no-wrap
msgid "\nIF <placeholder-1/> THEN\n    <placeholder-2/>\nELSE\n    <placeholder-3/>\nEND IF;\n"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:1794(para) 
msgid "<literal>IF-THEN-ELSE</literal> statements add to <literal>IF-THEN</literal> by letting you specify an alternative set of statements that should be executed if the condition is not true. (Note this includes the case where the condition evaluates to NULL.)"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:1804(programlisting) 
#, no-wrap
msgid "\nIF parentid IS NULL OR parentid = ''\nTHEN\n    RETURN fullname;\nELSE\n    RETURN hp_true_filename(parentid) || '/' || fullname;\nEND IF;\n"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:1813(programlisting) 
#, no-wrap
msgid "\nIF v_count &gt; 0 THEN\n    INSERT INTO users_count (count) VALUES (v_count);\n    RETURN 't';\nELSE\n    RETURN 'f';\nEND IF;\n"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:1802(para) 
msgid "Examples: <placeholder-1/><placeholder-2/>"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:1825(literal) 
msgid "IF-THEN-ELSIF"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:1832(optional) 
msgid "ELSIF <placeholder-1/> THEN <placeholder-2/> ..."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:1830(optional) 
msgid "ELSIF <placeholder-1/> THEN <placeholder-2/><placeholder-3/>"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:1837(optional) /tmp/cicero-gTQe/plpgsql.xml:1910(optional) /tmp/cicero-gTQe/plpgsql.xml:1953(optional) 
msgid "ELSE <placeholder-1/>"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:1827(synopsis) 
#, no-wrap
msgid "\nIF <placeholder-1/> THEN\n    <placeholder-2/>\n<placeholder-3/>\n<placeholder-4/>\nEND IF;\n"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:1842(para) 
msgid "Sometimes there are more than just two alternatives. <literal>IF-THEN-ELSIF</literal> provides a convenient method of checking several alternatives in turn. The <literal>IF</literal> conditions are tested successively until the first one that is true is found. Then the associated statement(s) are executed, after which control passes to the next statement after <literal>END IF</literal>. (Any subsequent <literal>IF</literal> conditions are <emphasis>not</emphasis> tested.) If none of the <literal>IF</literal> conditions is true, then the <literal>ELSE</literal> block (if any) is executed."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:1858(programlisting) 
#, no-wrap
msgid "\nIF number = 0 THEN\n    result := 'zero';\nELSIF number &gt; 0 THEN\n    result := 'positive';\nELSIF number &lt; 0 THEN\n    result := 'negative';\nELSE\n    -- hmm, the only other possibility is that number is null\n    result := 'NULL';\nEND IF;\n"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:1855(para) /tmp/cicero-gTQe/plpgsql.xml:1972(para) 
msgid "Here is an example: <placeholder-1/>"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:1872(para) 
msgid "The key word <literal>ELSIF</literal> can also be spelled <literal>ELSEIF</literal>."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:1882(programlisting) 
#, no-wrap
msgid "\nIF demo_row.sex = 'm' THEN\n    pretty_sex := 'man';\nELSE\n    IF demo_row.sex = 'f' THEN\n        pretty_sex := 'woman';\n    END IF;\nEND IF;\n"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:1877(para) 
msgid "An alternative way of accomplishing the same task is to nest <literal>IF-THEN-ELSE</literal> statements, as in the following example: <placeholder-1/>"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:1893(para) 
msgid "However, this method requires writing a matching <literal>END IF</literal> for each <literal>IF</literal>, so it is much more cumbersome than using <literal>ELSIF</literal> when there are many alternatives."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:1901(title) 
msgid "Simple <literal>CASE</literal>"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:1904(replaceable) 
msgid "search-expression"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:1905(optional) /tmp/cicero-gTQe/plpgsql.xml:1907(optional) 
msgid "..."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:1905(optional) /tmp/cicero-gTQe/plpgsql.xml:1907(optional) 
msgid ", <placeholder-1/><placeholder-2/>"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:1907(optional) 
msgid "WHEN <placeholder-1/><placeholder-2/> THEN <placeholder-3/> ..."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:1903(synopsis) 
#, no-wrap
msgid "\nCASE <placeholder-1/>\n    WHEN <placeholder-2/> <placeholder-3/> THEN\n      <placeholder-4/>\n  <placeholder-5/>\n  <placeholder-6/>\nEND CASE;\n"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:1915(para) 
msgid "The simple form of <command>CASE</command> provides conditional execution based on equality of operands. The <replaceable>search-expression</replaceable> is evaluated (once) and successively compared to each <replaceable>expression</replaceable> in the <literal>WHEN</literal> clauses. If a match is found, then the corresponding <replaceable>statements</replaceable> are executed, and then control passes to the next statement after <literal>END CASE</literal>. (Subsequent <literal>WHEN</literal> expressions are not evaluated.) If no match is found, the <literal>ELSE</literal><replaceable>statements</replaceable> are executed; but if <literal>ELSE</literal> is not present, then a <literal>CASE_NOT_FOUND</literal> exception is raised."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:1932(programlisting) 
#, no-wrap
msgid "\nCASE x\n    WHEN 1, 2 THEN\n        msg := 'one or two';\n    ELSE\n        msg := 'other value than one or two';\nEND CASE;\n"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:1929(para) 
msgid "Here is a simple example: <placeholder-1/>"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:1944(title) 
msgid "Searched <literal>CASE</literal>"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:1950(optional) 
msgid "WHEN <placeholder-1/> THEN <placeholder-2/> ..."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:1946(synopsis) 
#, no-wrap
msgid "\nCASE\n    WHEN <placeholder-1/> THEN\n      <placeholder-2/>\n  <placeholder-3/>\n  <placeholder-4/>\nEND CASE;\n"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:1958(para) 
msgid "The searched form of <command>CASE</command> provides conditional execution based on truth of Boolean expressions. Each <literal>WHEN</literal> clause's <replaceable>boolean-expression</replaceable> is evaluated in turn, until one is found that yields <literal>true</literal>. Then the corresponding <replaceable>statements</replaceable> are executed, and then control passes to the next statement after <literal>END CASE</literal>. (Subsequent <literal>WHEN</literal> expressions are not evaluated.) If no true result is found, the <literal>ELSE</literal><replaceable>statements</replaceable> are executed; but if <literal>ELSE</literal> is not present, then a <literal>CASE_NOT_FOUND</literal> exception is raised."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:1975(programlisting) 
#, no-wrap
msgid "\nCASE\n    WHEN x BETWEEN 0 AND 10 THEN\n        msg := 'value is between zero and ten';\n    WHEN x BETWEEN 11 AND 20 THEN\n        msg := 'value is between eleven and twenty';\nEND CASE;\n"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:1985(para) 
msgid "This form of <command>CASE</command> is entirely equivalent to <literal>IF-THEN-ELSIF</literal>, except for the rule that reaching an omitted <literal>ELSE</literal> clause results in an error rather than doing nothing."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:1996(title) 
msgid "Simple Loops"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:1999(primary) 
msgid "loop"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:2003(para) 
msgid "With the <literal>LOOP</literal>, <literal>EXIT</literal>, <literal>CONTINUE</literal>, <literal>WHILE</literal>, <literal>FOR</literal>, and <literal>FOREACH</literal> statements, you can arrange for your <application>PL/pgSQL</application> function to repeat a series of commands."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:2011(literal) 
msgid "LOOP"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:2014(replaceable) /tmp/cicero-gTQe/plpgsql.xml:2017(replaceable) /tmp/cicero-gTQe/plpgsql.xml:2039(replaceable) /tmp/cicero-gTQe/plpgsql.xml:2111(replaceable) /tmp/cicero-gTQe/plpgsql.xml:2160(replaceable) /tmp/cicero-gTQe/plpgsql.xml:2163(replaceable) /tmp/cicero-gTQe/plpgsql.xml:2192(replaceable) /tmp/cicero-gTQe/plpgsql.xml:2195(replaceable) 
msgid "label"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:2014(optional) /tmp/cicero-gTQe/plpgsql.xml:2160(optional) /tmp/cicero-gTQe/plpgsql.xml:2192(optional) 
msgid "&lt;&lt;<placeholder-1/>&gt;&gt;"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:2013(synopsis) 
#, no-wrap
msgid "\n<placeholder-1/>\nLOOP\n    <placeholder-2/>\nEND LOOP <optional> <placeholder-3/> </optional>;\n"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:2020(para) 
msgid "<literal>LOOP</literal> defines an unconditional loop that is repeated indefinitely until terminated by an <literal>EXIT</literal> or <command>RETURN</command> statement. The optional <replaceable>label</replaceable> can be used by <literal>EXIT</literal> and <literal>CONTINUE</literal> statements within nested loops to specify which loop those statements refer to."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:2031(literal) /tmp/cicero-gTQe/plpgsql.xml:2034(primary) 
msgid "EXIT"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:2039(optional) /tmp/cicero-gTQe/plpgsql.xml:2111(optional) 
msgid "WHEN <placeholder-1/>"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:2038(synopsis) 
#, no-wrap
msgid "\nEXIT <optional> <placeholder-1/> </optional> <placeholder-2/>;\n"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:2042(para) 
msgid "If no <replaceable>label</replaceable> is given, the innermost loop is terminated and the statement following <literal>END LOOP</literal> is executed next. If <replaceable>label</replaceable> is given, it must be the label of the current or some outer level of nested loop or block. Then the named loop or block is terminated and control continues with the statement after the loop's/block's corresponding <literal>END</literal>."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:2052(para) 
msgid "If <literal>WHEN</literal> is specified, the loop exit occurs only if <replaceable>boolean-expression</replaceable> is true. Otherwise, control passes to the statement after <literal>EXIT</literal>."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:2058(para) 
msgid "<literal>EXIT</literal> can be used with all types of loops; it is not limited to use with unconditional loops."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:2063(para) 
msgid "When used with a <literal>BEGIN</literal> block, <literal>EXIT</literal> passes control to the next statement after the end of the block. Note that a label must be used for this purpose; an unlabelled <literal>EXIT</literal> is never considered to match a <literal>BEGIN</literal> block. (This is a change from pre-8.4 releases of <productname>PostgreSQL</productname>, which would allow an unlabelled <literal>EXIT</literal> to match a <literal>BEGIN</literal> block.)"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:2077(programlisting) 
#, no-wrap
msgid "\nLOOP\n    -- some computations\n    IF count &gt; 0 THEN\n        EXIT;  -- exit loop\n    END IF;\nEND LOOP;\n\nLOOP\n    -- some computations\n    EXIT WHEN count &gt; 0;  -- same result as previous example\nEND LOOP;\n\n&lt;&lt;ablock&gt;&gt;\nBEGIN\n    -- some computations\n    IF stocks &gt; 100000 THEN\n        EXIT ablock;  -- causes exit from the BEGIN block\n    END IF;\n    -- computations here will be skipped when stocks &gt; 100000\nEND;\n"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:2103(literal) /tmp/cicero-gTQe/plpgsql.xml:2106(primary) 
msgid "CONTINUE"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:2110(synopsis) 
#, no-wrap
msgid "\nCONTINUE <optional> <placeholder-1/> </optional> <placeholder-2/>;\n"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:2114(para) 
msgid "If no <replaceable>label</replaceable> is given, the next iteration of the innermost loop is begun. That is, all statements remaining in the loop body are skipped, and control returns to the loop control expression (if any) to determine whether another loop iteration is needed. If <replaceable>label</replaceable> is present, it specifies the label of the loop whose execution will be continued."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:2125(para) 
msgid "If <literal>WHEN</literal> is specified, the next iteration of the loop is begun only if <replaceable>boolean-expression</replaceable> is true. Otherwise, control passes to the statement after <literal>CONTINUE</literal>."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:2132(para) 
msgid "<literal>CONTINUE</literal> can be used with all types of loops; it is not limited to use with unconditional loops."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:2139(programlisting) 
#, no-wrap
msgid "\nLOOP\n    -- some computations\n    EXIT WHEN count &gt; 100;\n    CONTINUE WHEN count &lt; 50;\n    -- some computations for count IN [50 .. 100]\nEND LOOP;\n"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:2152(literal) /tmp/cicero-gTQe/plpgsql.xml:2155(primary) 
msgid "WHILE"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:2159(synopsis) 
#, no-wrap
msgid "\n<placeholder-1/>\nWHILE <placeholder-2/> LOOP\n    <placeholder-3/>\nEND LOOP <optional> <placeholder-4/> </optional>;\n"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:2166(para) 
msgid "The <literal>WHILE</literal> statement repeats a sequence of statements so long as the <replaceable>boolean-expression</replaceable> evaluates to true. The expression is checked just before each entry to the loop body."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:2176(programlisting) 
#, no-wrap
msgid "\nWHILE amount_owed &gt; 0 AND gift_certificate_balance &gt; 0 LOOP\n    -- some computations here\nEND LOOP;\n\nWHILE NOT done LOOP\n    -- some computations here\nEND LOOP;\n"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:2174(para) 
msgid "For example: <placeholder-1/>"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:2189(title) 
msgid "<literal>FOR</literal> (Integer Variant)"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:2193(optional) 
msgid "REVERSE"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:2193(optional) 
msgid "BY <placeholder-1/>"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:2191(synopsis) 
#, no-wrap
msgid "\n<placeholder-1/>\nFOR <placeholder-2/> IN <placeholder-3/> <placeholder-4/> .. <placeholder-5/> <placeholder-6/> LOOP\n    <placeholder-7/>\nEND LOOP <optional> <placeholder-8/> </optional>;\n"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:2198(para) 
msgid "This form of <literal>FOR</literal> creates a loop that iterates over a range of integer values. The variable <replaceable>name</replaceable> is automatically defined as type <type>integer</type> and exists only inside the loop (any existing definition of the variable name is ignored within the loop). The two expressions giving the lower and upper bound of the range are evaluated once when entering the loop. If the <literal>BY</literal> clause isn't specified the iteration step is 1, otherwise it's the value specified in the <literal>BY</literal> clause, which again is evaluated once on loop entry. If <literal>REVERSE</literal> is specified then the step value is subtracted, rather than added, after each iteration."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:2215(programlisting) 
#, no-wrap
msgid "\nFOR i IN 1..10 LOOP\n    -- i will take on the values 1,2,3,4,5,6,7,8,9,10 within the loop\nEND LOOP;\n\nFOR i IN REVERSE 10..1 LOOP\n    -- i will take on the values 10,9,8,7,6,5,4,3,2,1 within the loop\nEND LOOP;\n\nFOR i IN REVERSE 10..1 BY 2 LOOP\n    -- i will take on the values 10,8,6,4,2 within the loop\nEND LOOP;\n"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:2213(para) 
msgid "Some examples of integer <literal>FOR</literal> loops: <placeholder-1/>"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:2230(para) 
msgid "If the lower bound is greater than the upper bound (or less than, in the <literal>REVERSE</literal> case), the loop body is not executed at all. No error is raised."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:2236(para) 
msgid "If a <replaceable>label</replaceable> is attached to the <literal>FOR</literal> loop then the integer loop variable can be referenced with a qualified name, using that <replaceable>label</replaceable>."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:2246(title) 
msgid "Looping Through Query Results"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:2263(programlisting) 
#, no-wrap
msgid "\nCREATE FUNCTION cs_refresh_mviews() RETURNS integer AS $$\nDECLARE\n    mviews RECORD;\nBEGIN\n    RAISE NOTICE 'Refreshing materialized views...';\n\n    FOR mviews IN SELECT * FROM cs_materialized_views ORDER BY sort_key LOOP\n\n        -- Now \"mviews\" has one record from cs_materialized_views\n\n        RAISE NOTICE 'Refreshing materialized view %s ...', quote_ident(mviews.mv_name);\n        EXECUTE 'TRUNCATE TABLE ' || quote_ident(mviews.mv_name);\n        EXECUTE 'INSERT INTO '\n                   || quote_ident(mviews.mv_name) || ' '\n                   || mviews.mv_query;\n    END LOOP;\n\n    RAISE NOTICE 'Done refreshing materialized views.';\n    RETURN 1;\nEND;\n$$ LANGUAGE plpgsql;\n"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:2248(para) 
msgid "Using a different type of <literal>FOR</literal> loop, you can iterate through the results of a query and manipulate that data accordingly. The syntax is: <synopsis>\n<optional> &lt;&lt;<replaceable>label</replaceable>&gt;&gt; </optional>\nFOR <replaceable>target</replaceable> IN <replaceable>query</replaceable> LOOP\n    <replaceable>statements</replaceable>\nEND LOOP <optional> <replaceable>label</replaceable> </optional>;\n</synopsis> The <replaceable>target</replaceable> is a record variable, row variable, or comma-separated list of scalar variables. The <replaceable>target</replaceable> is successively assigned each row resulting from the <replaceable>query</replaceable> and the loop body is executed for each row. Here is an example: <placeholder-1/> If the loop is terminated by an <literal>EXIT</literal> statement, the last assigned row value is still accessible after the loop."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:2291(para) 
msgid "The <replaceable>query</replaceable> used in this type of <literal>FOR</literal> statement can be any SQL command that returns rows to the caller: <command>SELECT</command> is the most common case, but you can also use <command>INSERT</command>, <command>UPDATE</command>, or <command>DELETE</command> with a <literal>RETURNING</literal> clause. Some utility commands such as <command>EXPLAIN</command> will work too."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:2300(para) 
msgid "<application>PL/pgSQL</application> variables are substituted into the query text, and the query plan is cached for possible re-use, as discussed in detail in <xref linkend=\"plpgsql-var-subst\"/> and <xref linkend=\"plpgsql-plan-caching\"/>."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:2307(para) 
msgid "The <literal>FOR-IN-EXECUTE</literal> statement is another way to iterate over rows: <synopsis>\n<optional> &lt;&lt;<replaceable>label</replaceable>&gt;&gt; </optional>\nFOR <replaceable>target</replaceable> IN EXECUTE <replaceable>text_expression</replaceable> <optional> USING <replaceable>expression</replaceable> <optional>, ... </optional> </optional> LOOP\n    <replaceable>statements</replaceable>\nEND LOOP <optional> <replaceable>label</replaceable> </optional>;\n</synopsis> This is like the previous form, except that the source query is specified as a string expression, which is evaluated and replanned on each entry to the <literal>FOR</literal> loop. This allows the programmer to choose the speed of a preplanned query or the flexibility of a dynamic query, just as with a plain <command>EXECUTE</command> statement. As with <command>EXECUTE</command>, parameter values can be inserted into the dynamic command via <literal>USING</literal>."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:2325(para) 
msgid "Another way to specify the query whose results should be iterated through is to declare it as a cursor. This is described in <xref linkend=\"plpgsql-cursor-for-loop\"/>."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:2333(title) 
msgid "Looping Through Arrays"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:2335(para) 
msgid "The <literal>FOREACH</literal> loop is much like a <literal>FOR</literal> loop, but instead of iterating through the rows returned by a SQL query, it iterates through the elements of an array value. (In general, <literal>FOREACH</literal> is meant for looping through components of a composite-valued expression; variants for looping through composites besides arrays may be added in future.) The <literal>FOREACH</literal> statement to loop over an array is: <synopsis>\n<optional> &lt;&lt;<replaceable>label</replaceable>&gt;&gt; </optional>\nFOREACH <replaceable>target</replaceable> <optional> SLICE <replaceable>number</replaceable> </optional> IN ARRAY <replaceable>expression</replaceable> LOOP\n    <replaceable>statements</replaceable>\nEND LOOP <optional> <replaceable>label</replaceable> </optional>;\n</synopsis>"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:2361(programlisting) 
#, no-wrap
msgid "\nCREATE FUNCTION sum(int[]) RETURNS int8 AS $$\nDECLARE\n  s int8 := 0;\n  x int;\nBEGIN\n  FOREACH x IN ARRAY $1\n  LOOP\n    s := s + x;\n  END LOOP;\n  RETURN s;\nEND;\n$$ LANGUAGE plpgsql;\n"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:2352(para) 
msgid "Without <literal>SLICE</literal>, or if <literal>SLICE 0</literal> is specified, the loop iterates through individual elements of the array produced by evaluating the <replaceable>expression</replaceable>. The <replaceable>target</replaceable> variable is assigned each element value in sequence, and the loop body is executed for each element. Here is an example of looping through the elements of an integer array: <placeholder-1/> The elements are visited in storage order, regardless of the number of array dimensions. Although the <replaceable>target</replaceable> is usually just a single variable, it can be a list of variables when looping through an array of composite values (records). In that case, for each array element, the variables are assigned from successive columns of the composite value."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:2394(programlisting) 
#, no-wrap
msgid "\nCREATE FUNCTION scan_rows(int[]) RETURNS void AS $$\nDECLARE\n  x int[];\nBEGIN\n  FOREACH x SLICE 1 IN ARRAY $1\n  LOOP\n    RAISE NOTICE 'row = %', x;\n  END LOOP;\nEND;\n$$ LANGUAGE plpgsql;\n\nSELECT scan_rows(ARRAY[[1,2,3],[4,5,6],[7,8,9],[10,11,12]]);\n\nNOTICE:  row = {1,2,3}\nNOTICE:  row = {4,5,6}\nNOTICE:  row = {7,8,9}\nNOTICE:  row = {10,11,12}\n"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:2384(para) 
msgid "With a positive <literal>SLICE</literal> value, <literal>FOREACH</literal> iterates through slices of the array rather than single elements. The <literal>SLICE</literal> value must be an integer constant not larger than the number of dimensions of the array. The <replaceable>target</replaceable> variable must be an array, and it receives successive slices of the array value, where each slice is of the number of dimensions specified by <literal>SLICE</literal>. Here is an example of iterating through one-dimensional slices: <placeholder-1/>"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:2417(title) 
msgid "Trapping Errors"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:2420(primary) 
msgid "exceptions"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:2424(para) 
msgid "By default, any error occurring in a <application>PL/pgSQL</application> function aborts execution of the function, and indeed of the surrounding transaction as well. You can trap errors and recover from them by using a <command>BEGIN</command> block with an <literal>EXCEPTION</literal> clause. The syntax is an extension of the normal syntax for a <command>BEGIN</command> block: <synopsis>\n<optional> &lt;&lt;<replaceable>label</replaceable>&gt;&gt; </optional>\n<optional> DECLARE\n    <replaceable>declarations</replaceable> </optional>\nBEGIN\n    <replaceable>statements</replaceable>\nEXCEPTION\n    WHEN <replaceable>condition</replaceable> <optional> OR <replaceable>condition</replaceable> ... </optional> THEN\n        <replaceable>handler_statements</replaceable>\n    <optional> WHEN <replaceable>condition</replaceable> <optional> OR <replaceable>condition</replaceable> ... </optional> THEN\n          <replaceable>handler_statements</replaceable>\n      ... </optional>\nEND;\n</synopsis>"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:2448(para) 
msgid "If no error occurs, this form of block simply executes all the <replaceable>statements</replaceable>, and then control passes to the next statement after <literal>END</literal>. But if an error occurs within the <replaceable>statements</replaceable>, further processing of the <replaceable>statements</replaceable> is abandoned, and control passes to the <literal>EXCEPTION</literal> list. The list is searched for the first <replaceable>condition</replaceable> matching the error that occurred. If a match is found, the corresponding <replaceable>handler_statements</replaceable> are executed, and then control passes to the next statement after <literal>END</literal>. If no match is found, the error propagates out as though the <literal>EXCEPTION</literal> clause were not there at all: the error can be caught by an enclosing block with <literal>EXCEPTION</literal>, or if there is none it aborts processing of the function."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:2475(programlisting) 
#, no-wrap
msgid "\nWHEN division_by_zero THEN ...\nWHEN SQLSTATE '22012' THEN ...\n"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:2466(para) 
msgid "The <replaceable>condition</replaceable> names can be any of those shown in <xref linkend=\"errcodes-appendix\"/>. A category name matches any error within its category. The special condition name <literal>OTHERS</literal> matches every error type except <literal>QUERY_CANCELED</literal>. (It is possible, but often unwise, to trap <literal>QUERY_CANCELED</literal> by name.) Condition names are not case-sensitive. Also, an error condition can be specified by <literal>SQLSTATE</literal> code; for example these are equivalent: <placeholder-1/>"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:2481(para) 
msgid "If a new error occurs within the selected <replaceable>handler_statements</replaceable>, it cannot be caught by this <literal>EXCEPTION</literal> clause, but is propagated out. A surrounding <literal>EXCEPTION</literal> clause could catch it."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:2495(programlisting) 
#, no-wrap
msgid "\nINSERT INTO mytab(firstname, lastname) VALUES('Tom', 'Jones');\nBEGIN\n    UPDATE mytab SET firstname = 'Joe' WHERE lastname = 'Jones';\n    x := x + 1;\n    y := x / 0;\nEXCEPTION\n    WHEN division_by_zero THEN\n        RAISE NOTICE 'caught division_by_zero';\n        RETURN x;\nEND;\n"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:2488(para) 
msgid "When an error is caught by an <literal>EXCEPTION</literal> clause, the local variables of the <application>PL/pgSQL</application> function remain as they were when the error occurred, but all changes to persistent database state within the block are rolled back. As an example, consider this fragment: <placeholder-1/> When control reaches the assignment to <literal>y</literal>, it will fail with a <literal>division_by_zero</literal> error. This will be caught by the <literal>EXCEPTION</literal> clause. The value returned in the <command>RETURN</command> statement will be the incremented value of <literal>x</literal>, but the effects of the <command>UPDATE</command> command will have been rolled back. The <command>INSERT</command> command preceding the block is not rolled back, however, so the end result is that the database contains <literal>Tom Jones</literal> not <literal>Joe Jones</literal>."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:2519(para) 
msgid "A block containing an <literal>EXCEPTION</literal> clause is significantly more expensive to enter and exit than a block without one. Therefore, don't use <literal>EXCEPTION</literal> without need."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:2526(para) 
msgid "Within an exception handler, the <varname>SQLSTATE</varname> variable contains the error code that corresponds to the exception that was raised (refer to <xref linkend=\"errcodes-table\"/> for a list of possible error codes). The <varname>SQLERRM</varname> variable contains the error message associated with the exception. These variables are undefined outside exception handlers."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:2537(title) 
msgid "Exceptions with <command>UPDATE</command>/<command>INSERT</command>"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:2543(programlisting) 
#, no-wrap
msgid "\nCREATE TABLE db (a INT PRIMARY KEY, b TEXT);\n\nCREATE FUNCTION merge_db(key INT, data TEXT) RETURNS VOID AS\n$$\nBEGIN\n    LOOP\n        -- first try to update the key\n        UPDATE db SET b = data WHERE a = key;\n        IF found THEN\n            RETURN;\n        END IF;\n        -- not there, so try to insert the key\n        -- if someone else inserts the same key concurrently,\n        -- we could get a unique-key failure\n        BEGIN\n            INSERT INTO db(a,b) VALUES (key, data);\n            RETURN;\n        EXCEPTION WHEN unique_violation THEN\n            -- Do nothing, and loop to try the UPDATE again.\n        END;\n    END LOOP;\nEND;\n$$\nLANGUAGE plpgsql;\n\nSELECT merge_db(1, 'david');\nSELECT merge_db(1, 'dennis');\n"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:2538(para) 
msgid "This example uses exception handling to perform either <command>UPDATE</command> or <command>INSERT</command>, as appropriate: <placeholder-1/> This example assumes the <literal>unique_violation</literal> error is caused by the <command>INSERT</command>, and not by an <command>INSERT</command> trigger function on the table."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:2581(title) 
msgid "Cursors"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:2584(primary) /tmp/cicero-gTQe/plpgsql.xml:2805(replaceable) /tmp/cicero-gTQe/plpgsql.xml:2858(replaceable) /tmp/cicero-gTQe/plpgsql.xml:2905(replaceable) /tmp/cicero-gTQe/plpgsql.xml:2906(replaceable) /tmp/cicero-gTQe/plpgsql.xml:2931(replaceable) 
msgid "cursor"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:2588(para) 
msgid "Rather than executing a whole query at once, it is possible to set up a <firstterm>cursor</firstterm> that encapsulates the query, and then read the query result a few rows at a time. One reason for doing this is to avoid memory overrun when the result contains a large number of rows. (However, <application>PL/pgSQL</application> users do not normally need to worry about that, since <literal>FOR</literal> loops automatically use a cursor internally to avoid memory problems.) A more interesting usage is to return a reference to a cursor that a function has created, allowing the caller to read the rows. This provides an efficient way to return large row sets from functions."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:2602(title) 
msgid "Declaring Cursor Variables"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:2604(para) 
msgid "All access to cursors in <application>PL/pgSQL</application> goes through cursor variables, which are always of the special data type <type>refcursor</type>. One way to create a cursor variable is just to declare it as a variable of type <type>refcursor</type>. Another way is to use the cursor declaration syntax, which in general is: <synopsis>\n<replaceable>name</replaceable> <optional> <optional> NO </optional> SCROLL </optional> CURSOR <optional> ( <replaceable>arguments</replaceable> ) </optional> FOR <replaceable>query</replaceable>;\n</synopsis> (<literal>FOR</literal> can be replaced by <literal>IS</literal> for <productname>Oracle</productname> compatibility.) If <literal>SCROLL</literal> is specified, the cursor will be capable of scrolling backward; if <literal>NO SCROLL</literal> is specified, backward fetches will be rejected; if neither specification appears, it is query-dependent whether backward fetches will be allowed. <replaceable>arguments</replaceable>, if specified, is a comma-separated list of pairs <literal><replaceable>name</replaceable><replaceable>datatype</replaceable></literal> that define names to be replaced by parameter values in the given query. The actual values to substitute for these names will be specified later, when the cursor is opened."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:2629(programlisting) 
#, no-wrap
msgid "\nDECLARE\n    curs1 refcursor;\n    curs2 CURSOR FOR SELECT * FROM tenk1;\n    curs3 CURSOR (key integer) IS SELECT * FROM tenk1 WHERE unique1 = key;\n"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:2627(para) 
msgid "Some examples: <placeholder-1/> All three of these variables have the data type <type>refcursor</type>, but the first can be used with any query, while the second has a fully specified query already <firstterm>bound</firstterm> to it, and the last has a parameterized query bound to it. (<literal>key</literal> will be replaced by an integer parameter value when the cursor is opened.) The variable <literal>curs1</literal> is said to be <firstterm>unbound</firstterm> since it is not bound to any particular query."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:2647(title) 
msgid "Opening Cursors"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:2649(para) 
msgid "Before a cursor can be used to retrieve rows, it must be <firstterm>opened</firstterm>. (This is the equivalent action to the SQL command <command>DECLARE CURSOR</command>.) <application>PL/pgSQL</application> has three forms of the <command>OPEN</command> statement, two of which use unbound cursor variables while the third uses a bound cursor variable."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:2658(para) 
msgid "Bound cursor variables can also be used without explicitly opening the cursor, via the <command>FOR</command> statement described in <xref linkend=\"plpgsql-cursor-for-loop\"/>."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:2666(command) 
msgid "OPEN FOR"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:2669(replaceable) /tmp/cicero-gTQe/plpgsql.xml:2703(replaceable) 
msgid "unbound_cursorvar"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:2669(optional) /tmp/cicero-gTQe/plpgsql.xml:2703(optional) 
msgid "NO"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:2669(optional) /tmp/cicero-gTQe/plpgsql.xml:2703(optional) 
msgid "<placeholder-1/> SCROLL"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:2668(synopsis) 
#, no-wrap
msgid "\nOPEN <placeholder-1/> <placeholder-2/> FOR <placeholder-3/>;\n"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:2672(para) 
msgid "The cursor variable is opened and given the specified query to execute. The cursor cannot be open already, and it must have been declared as an unbound cursor variable (that is, as a simple <type>refcursor</type> variable). The query must be a <command>SELECT</command>, or something else that returns rows (such as <command>EXPLAIN</command>). The query is treated in the same way as other SQL commands in <application>PL/pgSQL</application>: <application>PL/pgSQL</application> variable names are substituted, and the query plan is cached for possible reuse. When a <application>PL/pgSQL</application> variable is substituted into the cursor query, the value that is substituted is the one it has at the time of the <command>OPEN</command>; subsequent changes to the variable will not affect the cursor's behavior. The <literal>SCROLL</literal> and <literal>NO SCROLL</literal> options have the same meanings as for a bound cursor."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:2693(programlisting) 
#, no-wrap
msgid "\nOPEN curs1 FOR SELECT * FROM foo WHERE key = mykey;\n"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:2700(command) 
msgid "OPEN FOR EXECUTE"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:2703(replaceable) 
msgid "query_string"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:2702(synopsis) 
#, no-wrap
msgid "\nOPEN <placeholder-1/> <placeholder-2/> FOR EXECUTE <placeholder-3/>\n                                     <placeholder-4/>;\n"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:2707(para) 
msgid "The cursor variable is opened and given the specified query to execute. The cursor cannot be open already, and it must have been declared as an unbound cursor variable (that is, as a simple <type>refcursor</type> variable). The query is specified as a string expression, in the same way as in the <command>EXECUTE</command> command. As usual, this gives flexibility so the query plan can vary from one run to the next (see <xref linkend=\"plpgsql-plan-caching\"/>), and it also means that variable substitution is not done on the command string. As with <command>EXECUTE</command>, parameter values can be inserted into the dynamic command via <literal>USING</literal>. The <literal>SCROLL</literal> and <literal>NO SCROLL</literal> options have the same meanings as for a bound cursor."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:2725(programlisting) 
#, no-wrap
msgid "\nOPEN curs1 FOR EXECUTE 'SELECT * FROM ' || quote_ident(tabname)\n                                        || ' WHERE col1 = $1' USING keyvalue;\n"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:2723(para) 
msgid "An example: <placeholder-1/> In this example, the table name is inserted into the query textually, so use of <function>quote_ident()</function> is recommended to guard against SQL injection. The comparison value for <literal>col1</literal> is inserted via a <literal>USING</literal> parameter, so it needs no quoting."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:2737(title) 
msgid "Opening a Bound Cursor"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:2740(replaceable) 
msgid "bound_cursorvar"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:2740(replaceable) 
msgid "argument_values"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:2740(optional) 
msgid "( <placeholder-1/> )"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:2739(synopsis) 
#, no-wrap
msgid "\nOPEN <placeholder-1/> <placeholder-2/>;\n"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:2743(para) 
msgid "This form of <command>OPEN</command> is used to open a cursor variable whose query was bound to it when it was declared. The cursor cannot be open already. A list of actual argument value expressions must appear if and only if the cursor was declared to take arguments. These values will be substituted in the query. The query plan for a bound cursor is always considered cacheable; there is no equivalent of <command>EXECUTE</command> in this case. Notice that <literal>SCROLL</literal> and <literal>NO SCROLL</literal> cannot be specified, as the cursor's scrolling behavior was already determined."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:2756(para) 
msgid "Note that because variable substitution is done on the bound cursor's query, there are two ways to pass values into the cursor: either with an explicit argument to <command>OPEN</command>, or implicitly by referencing a <application>PL/pgSQL</application> variable in the query. However, only variables declared before the bound cursor was declared will be substituted into it. In either case the value to be passed is determined at the time of the <command>OPEN</command>."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:2769(programlisting) 
#, no-wrap
msgid "\nOPEN curs2;\nOPEN curs3(42);\n"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:2778(title) 
msgid "Using Cursors"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:2780(para) 
msgid "Once a cursor has been opened, it can be manipulated with the statements described here."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:2785(para) 
msgid "These manipulations need not occur in the same function that opened the cursor to begin with. You can return a <type>refcursor</type> value out of a function and let the caller operate on the cursor. (Internally, a <type>refcursor</type> value is simply the string name of a so-called portal containing the active query for the cursor. This name can be passed around, assigned to other <type>refcursor</type> variables, and so on, without disturbing the portal.)"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:2795(para) 
msgid "All portals are implicitly closed at transaction end. Therefore a <type>refcursor</type> value is usable to reference an open cursor only until the end of the transaction."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:2802(literal) 
msgid "FETCH"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:2805(replaceable) /tmp/cicero-gTQe/plpgsql.xml:2858(replaceable) 
msgid "direction"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:2805(optional) /tmp/cicero-gTQe/plpgsql.xml:2858(optional) 
msgid "<placeholder-1/> { FROM | IN }"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:2805(replaceable) 
msgid "target"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:2804(synopsis) 
#, no-wrap
msgid "\nFETCH <placeholder-1/> <placeholder-2/> INTO <placeholder-3/>;\n"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:2808(para) 
msgid "<command>FETCH</command> retrieves the next row from the cursor into a target, which might be a row variable, a record variable, or a comma-separated list of simple variables, just like <command>SELECT INTO</command>. If there is no next row, the target is set to NULL(s). As with <command>SELECT INTO</command>, the special variable <literal>FOUND</literal> can be checked to see whether a row was obtained or not."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:2818(para) 
msgid "The <replaceable>direction</replaceable> clause can be any of the variants allowed in the SQL <xref linkend=\"sql-fetch\"/> command except the ones that can fetch more than one row; namely, it can be <literal>NEXT</literal>, <literal>PRIOR</literal>, <literal>FIRST</literal>, <literal>LAST</literal>, <literal>ABSOLUTE</literal><replaceable>count</replaceable>, <literal>RELATIVE</literal><replaceable>count</replaceable>, <literal>FORWARD</literal>, or <literal>BACKWARD</literal>. Omitting <replaceable>direction</replaceable> is the same as specifying <literal>NEXT</literal>. <replaceable>direction</replaceable> values that require moving backward are likely to fail unless the cursor was declared or opened with the <literal>SCROLL</literal> option."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:2838(para) 
msgid "<replaceable>cursor</replaceable> must be the name of a <type>refcursor</type> variable that references an open cursor portal."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:2845(programlisting) 
#, no-wrap
msgid "\nFETCH curs1 INTO rowvar;\nFETCH curs2 INTO foo, bar, baz;\nFETCH LAST FROM curs3 INTO x, y;\nFETCH RELATIVE -2 FROM curs4 INTO x;\n"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:2855(literal) 
msgid "MOVE"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:2857(synopsis) 
#, no-wrap
msgid "\nMOVE <placeholder-1/> <placeholder-2/>;\n"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:2861(para) 
msgid "<command>MOVE</command> repositions a cursor without retrieving any data. <command>MOVE</command> works exactly like the <command>FETCH</command> command, except it only repositions the cursor and does not return the row moved to. As with <command>SELECT INTO</command>, the special variable <literal>FOUND</literal> can be checked to see whether there was a next row to move to."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:2870(para) 
msgid "The <replaceable>direction</replaceable> clause can be any of the variants allowed in the SQL <xref linkend=\"sql-fetch\"/> command, namely <literal>NEXT</literal>, <literal>PRIOR</literal>, <literal>FIRST</literal>, <literal>LAST</literal>, <literal>ABSOLUTE</literal><replaceable>count</replaceable>, <literal>RELATIVE</literal><replaceable>count</replaceable>, <literal>ALL</literal>, <literal>FORWARD</literal><optional><replaceable>count</replaceable> | <literal>ALL</literal></optional>, or <literal>BACKWARD</literal><optional><replaceable>count</replaceable> | <literal>ALL</literal></optional>. Omitting <replaceable>direction</replaceable> is the same as specifying <literal>NEXT</literal>. <replaceable>direction</replaceable> values that require moving backward are likely to fail unless the cursor was declared or opened with the <literal>SCROLL</literal> option."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:2892(programlisting) 
#, no-wrap
msgid "\nMOVE curs1;\nMOVE LAST FROM curs3;\nMOVE RELATIVE -2 FROM curs4;\nMOVE FORWARD 2 FROM curs4;\n"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:2902(literal) 
msgid "UPDATE/DELETE WHERE CURRENT OF"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:2905(replaceable) /tmp/cicero-gTQe/plpgsql.xml:2906(replaceable) 
msgid "table"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:2904(synopsis) 
#, no-wrap
msgid "\nUPDATE <placeholder-1/> SET ... WHERE CURRENT OF <placeholder-2/>;\nDELETE FROM <placeholder-3/> WHERE CURRENT OF <placeholder-4/>;\n"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:2909(para) 
msgid "When a cursor is positioned on a table row, that row can be updated or deleted using the cursor to identify the row. There are restrictions on what the cursor's query can be (in particular, no grouping) and it's best to use <literal>FOR UPDATE</literal> in the cursor. For more information see the <xref linkend=\"sql-declare\"/> reference page."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:2921(programlisting) 
#, no-wrap
msgid "\nUPDATE foo SET dataval = myval WHERE CURRENT OF curs1;\n"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:2928(literal) 
msgid "CLOSE"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:2930(synopsis) 
#, no-wrap
msgid "\nCLOSE <placeholder-1/>;\n"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:2934(para) 
msgid "<command>CLOSE</command> closes the portal underlying an open cursor. This can be used to release resources earlier than end of transaction, or to free up the cursor variable to be opened again."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:2942(programlisting) 
#, no-wrap
msgid "\nCLOSE curs1;\n"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:2949(title) 
msgid "Returning Cursors"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:2951(para) 
msgid "<application>PL/pgSQL</application> functions can return cursors to the caller. This is useful to return multiple rows or columns, especially with very large result sets. To do this, the function opens the cursor and returns the cursor name to the caller (or simply opens the cursor using a portal name specified by or otherwise known to the caller). The caller can then fetch rows from the cursor. The cursor can be closed by the caller, or it will be closed automatically when the transaction closes."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:2962(para) 
msgid "The portal name used for a cursor can be specified by the programmer or automatically generated. To specify a portal name, simply assign a string to the <type>refcursor</type> variable before opening it. The string value of the <type>refcursor</type> variable will be used by <command>OPEN</command> as the name of the underlying portal. However, if the <type>refcursor</type> variable is null, <command>OPEN</command> automatically generates a name that does not conflict with any existing portal, and assigns it to the <type>refcursor</type> variable."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:2975(para) 
msgid "A bound cursor variable is initialized to the string value representing its name, so that the portal name is the same as the cursor variable name, unless the programmer overrides it by assignment before opening the cursor. But an unbound cursor variable defaults to the null value initially, so it will receive an automatically-generated unique name, unless overridden."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:2989(programlisting) 
#, no-wrap
msgid "\nCREATE TABLE test (col text);\nINSERT INTO test VALUES ('123');\n\nCREATE FUNCTION reffunc(refcursor) RETURNS refcursor AS '\nBEGIN\n    OPEN $1 FOR SELECT col FROM test;\n    RETURN $1;\nEND;\n' LANGUAGE plpgsql;\n\nBEGIN;\nSELECT reffunc('funccursor');\nFETCH ALL IN funccursor;\nCOMMIT;\n"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:2985(para) 
msgid "The following example shows one way a cursor name can be supplied by the caller: <placeholder-1/>"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:3010(programlisting) 
#, no-wrap
msgid "\nCREATE FUNCTION reffunc2() RETURNS refcursor AS '\nDECLARE\n    ref refcursor;\nBEGIN\n    OPEN ref FOR SELECT col FROM test;\n    RETURN ref;\nEND;\n' LANGUAGE plpgsql;\n\n-- need to be in a transaction to use cursors.\nBEGIN;\nSELECT reffunc2();\n\n      reffunc2\n--------------------\n &lt;unnamed cursor 1&gt;\n(1 row)\n\nFETCH ALL IN \"&lt;unnamed cursor 1&gt;\";\nCOMMIT;\n"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:3007(para) 
msgid "The following example uses automatic cursor name generation: <placeholder-1/>"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:3038(programlisting) 
#, no-wrap
msgid "\nCREATE FUNCTION myfunc(refcursor, refcursor) RETURNS SETOF refcursor AS $$\nBEGIN\n    OPEN $1 FOR SELECT * FROM table_1;\n    RETURN NEXT $1;\n    OPEN $2 FOR SELECT * FROM table_2;\n    RETURN NEXT $2;\nEND;\n$$ LANGUAGE plpgsql;\n\n-- need to be in a transaction to use cursors.\nBEGIN;\n\nSELECT * FROM myfunc('a', 'b');\n\nFETCH ALL FROM a;\nFETCH ALL FROM b;\nCOMMIT;\n"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:3034(para) 
msgid "The following example shows one way to return multiple cursors from a single function: <placeholder-1/>"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:3062(title) 
msgid "Looping Through a Cursor's Result"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:3064(para) 
msgid "There is a variant of the <command>FOR</command> statement that allows iterating through the rows returned by a cursor. The syntax is: <synopsis>\n<optional> &lt;&lt;<replaceable>label</replaceable>&gt;&gt; </optional>\nFOR <replaceable>recordvar</replaceable> IN <replaceable>bound_cursorvar</replaceable> <optional> ( <replaceable>argument_values</replaceable> ) </optional> LOOP\n    <replaceable>statements</replaceable>\nEND LOOP <optional> <replaceable>label</replaceable> </optional>;\n</synopsis> The cursor variable must have been bound to some query when it was declared, and it <emphasis>cannot</emphasis> be open already. The <command>FOR</command> statement automatically opens the cursor, and it closes the cursor again when the loop exits. A list of actual argument value expressions must appear if and only if the cursor was declared to take arguments. These values will be substituted in the query, in just the same way as during an <command>OPEN</command>. The variable <replaceable>recordvar</replaceable> is automatically defined as type <type>record</type> and exists only inside the loop (any existing definition of the variable name is ignored within the loop). Each row returned by the cursor is successively assigned to this record variable and the loop body is executed."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:3093(title) 
msgid "Errors and Messages"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:3096(primary) 
msgid "RAISE"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:3100(primary) 
msgid "reporting errors"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:3104(para) 
msgid "Use the <command>RAISE</command> statement to report messages and raise errors. <synopsis>\nRAISE <optional> <replaceable class=\"parameter\">level</replaceable> </optional> '<replaceable class=\"parameter\">format</replaceable>' <optional>, <replaceable class=\"parameter\">expression</replaceable> <optional>, ... </optional></optional> <optional> USING <replaceable class=\"parameter\">option</replaceable> = <replaceable class=\"parameter\">expression</replaceable> <optional>, ... </optional> </optional>;\nRAISE <optional> <replaceable class=\"parameter\">level</replaceable> </optional> <replaceable class=\"parameter\">condition_name</replaceable> <optional> USING <replaceable class=\"parameter\">option</replaceable> = <replaceable class=\"parameter\">expression</replaceable> <optional>, ... </optional> </optional>;\nRAISE <optional> <replaceable class=\"parameter\">level</replaceable> </optional> SQLSTATE '<replaceable class=\"parameter\">sqlstate</replaceable>' <optional> USING <replaceable class=\"parameter\">option</replaceable> = <replaceable class=\"parameter\">expression</replaceable> <optional>, ... </optional> </optional>;\nRAISE <optional> <replaceable class=\"parameter\">level</replaceable> </optional> USING <replaceable class=\"parameter\">option</replaceable> = <replaceable class=\"parameter\">expression</replaceable> <optional>, ... </optional>;\nRAISE ;\n</synopsis> The <replaceable class=\"parameter\">level</replaceable> option specifies the error severity. Allowed levels are <literal>DEBUG</literal>, <literal>LOG</literal>, <literal>INFO</literal>, <literal>NOTICE</literal>, <literal>WARNING</literal>, and <literal>EXCEPTION</literal>, with <literal>EXCEPTION</literal> being the default. <literal>EXCEPTION</literal> raises an error (which normally aborts the current transaction); the other levels only generate messages of different priority levels. Whether messages of a particular priority are reported to the client, written to the server log, or both is controlled by the <xref linkend=\"guc-log-min-messages\"/> and <xref linkend=\"guc-client-min-messages\"/> configuration variables. See <xref linkend=\"runtime-config\"/> for more information."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:3133(para) 
msgid "After <replaceable class=\"parameter\">level</replaceable> if any, you can write a <replaceable class=\"parameter\">format</replaceable> (which must be a simple string literal, not an expression). The format string specifies the error message text to be reported. The format string can be followed by optional argument expressions to be inserted into the message. Inside the format string, <literal>%</literal> is replaced by the string representation of the next optional argument's value. Write <literal>%%</literal> to emit a literal <literal>%</literal>."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:3148(programlisting) 
#, no-wrap
msgid "\nRAISE NOTICE 'Calling cs_create_job(%)', v_job_id;\n"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:3145(para) 
msgid "In this example, the value of <literal>v_job_id</literal> will replace the <literal>%</literal> in the string: <placeholder-1/>"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:3153(para) 
msgid "You can attach additional information to the error report by writing <literal>USING</literal> followed by <replaceable class=\"parameter\">option</replaceable> = <replaceable class=\"parameter\">expression</replaceable> items. The allowed <replaceable class=\"parameter\">option</replaceable> keywords are <literal>MESSAGE</literal>, <literal>DETAIL</literal>, <literal>HINT</literal>, and <literal>ERRCODE</literal>, while each <replaceable class=\"parameter\">expression</replaceable> can be any string-valued expression. <literal>MESSAGE</literal> sets the error message text (this option can't be used in the form of <command>RAISE</command> that includes a format string before <literal>USING</literal>). <literal>DETAIL</literal> supplies an error detail message, while <literal>HINT</literal> supplies a hint message. <literal>ERRCODE</literal> specifies the error code (SQLSTATE) to report, either by condition name as shown in <xref linkend=\"errcodes-appendix\"/>, or directly as a five-character SQLSTATE code."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:3176(programlisting) 
#, no-wrap
msgid "\nRAISE EXCEPTION 'Nonexistent ID --&gt; %', user_id\n      USING HINT = 'Please check your user ID';\n"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:3173(para) 
msgid "This example will abort the transaction with the given error message and hint: <placeholder-1/>"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:3184(programlisting) 
#, no-wrap
msgid "\nRAISE 'Duplicate user ID: %', user_id USING ERRCODE = 'unique_violation';\nRAISE 'Duplicate user ID: %', user_id USING ERRCODE = '23505';\n"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:3182(para) 
msgid "These two examples show equivalent ways of setting the SQLSTATE: <placeholder-1/>"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:3193(programlisting) 
#, no-wrap
msgid "\nRAISE division_by_zero;\nRAISE SQLSTATE '22012';\n"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:3200(programlisting) 
#, no-wrap
msgid "\nRAISE unique_violation USING MESSAGE = 'Duplicate user ID: ' || user_id;\n"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:3190(para) 
msgid "There is a second <command>RAISE</command> syntax in which the main argument is the condition name or SQLSTATE to be reported, for example: <placeholder-1/> In this syntax, <literal>USING</literal> can be used to supply a custom error message, detail, or hint. Another way to do the earlier example is <placeholder-2/>"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:3205(para) 
msgid "Still another variant is to write <literal>RAISE USING</literal> or <literal>RAISE <replaceable class=\"parameter\">level</replaceable> USING</literal> and put everything else into the <literal>USING</literal> list."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:3211(para) 
msgid "The last variant of <command>RAISE</command> has no parameters at all. This form can only be used inside a <literal>BEGIN</literal> block's <literal>EXCEPTION</literal> clause; it causes the error currently being handled to be re-thrown."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:3219(para) 
msgid "Before <productname>PostgreSQL</productname> 9.1, <command>RAISE</command> without parameters was interpreted as re-throwing the error from the block containing the active exception handler. Thus an <literal>EXCEPTION</literal> clause nested within that handler could not catch it, even if the <command>RAISE</command> was within the nested <literal>EXCEPTION</literal> clause's block. This was deemed surprising as well as being incompatible with Oracle's PL/SQL."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:3230(para) 
msgid "If no condition name nor SQLSTATE is specified in a <command>RAISE EXCEPTION</command> command, the default is to use <literal>RAISE_EXCEPTION</literal> (<literal>P0001</literal>). If no message text is specified, the default is to use the condition name or SQLSTATE as message text."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:3239(para) 
msgid "When specifying an error code by SQLSTATE code, you are not limited to the predefined error codes, but can select any error code consisting of five digits and/or upper-case ASCII letters, other than <literal>00000</literal>. It is recommended that you avoid throwing error codes that end in three zeroes, because these are category codes and can only be trapped by trapping the whole category."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:3253(title) 
msgid "Trigger Procedures"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:3256(primary) 
msgid "trigger"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:3260(para) 
msgid "<application>PL/pgSQL</application> can be used to define trigger procedures. A trigger procedure is created with the <command>CREATE FUNCTION</command> command, declaring it as a function with no arguments and a return type of <type>trigger</type>. Note that the function must be declared with no arguments even if it expects to receive arguments specified in <command>CREATE TRIGGER</command> — trigger arguments are passed via <varname>TG_ARGV</varname>, as described below."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:3278(varname) 
msgid "NEW"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:3280(para) 
msgid "Data type <type>RECORD</type>; variable holding the new database row for <command>INSERT</command>/<command>UPDATE</command> operations in row-level triggers. This variable is <symbol>NULL</symbol> in statement-level triggers and for <command>DELETE</command> operations."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:3290(varname) 
msgid "OLD"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:3292(para) 
msgid "Data type <type>RECORD</type>; variable holding the old database row for <command>UPDATE</command>/<command>DELETE</command> operations in row-level triggers. This variable is <symbol>NULL</symbol> in statement-level triggers and for <command>INSERT</command> operations."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:3302(varname) 
msgid "TG_NAME"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:3304(para) 
msgid "Data type <type>name</type>; variable that contains the name of the trigger actually fired."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:3312(varname) 
msgid "TG_WHEN"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:3314(para) 
msgid "Data type <type>text</type>; a string of <literal>BEFORE</literal>, <literal>AFTER</literal>, or <literal>INSTEAD OF</literal>, depending on the trigger's definition."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:3323(varname) 
msgid "TG_LEVEL"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:3325(para) 
msgid "Data type <type>text</type>; a string of either <literal>ROW</literal> or <literal>STATEMENT</literal> depending on the trigger's definition."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:3334(varname) 
msgid "TG_OP"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:3336(para) 
msgid "Data type <type>text</type>; a string of <literal>INSERT</literal>, <literal>UPDATE</literal>, <literal>DELETE</literal>, or <literal>TRUNCATE</literal> telling for which operation the trigger was fired."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:3346(varname) 
msgid "TG_RELID"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:3348(para) 
msgid "Data type <type>oid</type>; the object ID of the table that caused the trigger invocation."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:3356(varname) 
msgid "TG_RELNAME"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:3358(para) 
msgid "Data type <type>name</type>; the name of the table that caused the trigger invocation. This is now deprecated, and could disappear in a future release. Use <literal>TG_TABLE_NAME</literal> instead."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:3367(varname) 
msgid "TG_TABLE_NAME"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:3369(para) 
msgid "Data type <type>name</type>; the name of the table that caused the trigger invocation."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:3377(varname) 
msgid "TG_TABLE_SCHEMA"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:3379(para) 
msgid "Data type <type>name</type>; the name of the schema of the table that caused the trigger invocation."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:3387(varname) 
msgid "TG_NARGS"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:3389(para) 
msgid "Data type <type>integer</type>; the number of arguments given to the trigger procedure in the <command>CREATE TRIGGER</command> statement."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:3397(varname) 
msgid "TG_ARGV[]"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:3399(para) 
msgid "Data type array of <type>text</type>; the arguments from the <command>CREATE TRIGGER</command> statement. The index counts from 0. Invalid indexes (less than 0 or greater than or equal to <varname>tg_nargs</varname>) result in a null value."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:3271(para) 
msgid "When a <application>PL/pgSQL</application> function is called as a trigger, several special variables are created automatically in the top-level block. They are: <placeholder-1/>"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:3411(para) 
msgid "A trigger function must return either <symbol>NULL</symbol> or a record/row value having exactly the structure of the table the trigger was fired for."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:3417(para) 
msgid "Row-level triggers fired <literal>BEFORE</literal> can return null to signal the trigger manager to skip the rest of the operation for this row (i.e., subsequent triggers are not fired, and the <command>INSERT</command>/<command>UPDATE</command>/<command>DELETE</command> does not occur for this row). If a nonnull value is returned then the operation proceeds with that row value. Returning a row value different from the original value of <varname>NEW</varname> alters the row that will be inserted or updated. Thus, if the trigger function wants the triggering action to succeed normally without altering the row value, <varname>NEW</varname> (or a value equal thereto) has to be returned. To alter the row to be stored, it is possible to replace single values directly in <varname>NEW</varname> and return the modified <varname>NEW</varname>, or to build a complete new record/row to return. In the case of a before-trigger on <command>DELETE</command>, the returned value has no direct effect, but it has to be nonnull to allow the trigger action to proceed. Note that <varname>NEW</varname> is null in <command>DELETE</command> triggers, so returning that is usually not sensible. The usual idiom in <command>DELETE</command> triggers is to return <varname>OLD</varname>."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:3441(para) 
msgid "<literal>INSTEAD OF</literal> triggers (which are always row-level triggers, and may only be used on views) can return null to signal that they did not perform any updates, and that the rest of the operation for this row should be skipped (i.e., subsequent triggers are not fired, and the row is not counted in the rows-affected status for the surrounding <command>INSERT</command>/<command>UPDATE</command>/<command>DELETE</command>). Otherwise a nonnull value should be returned, to signal that the trigger performed the requested operation. For <command>INSERT</command> and <command>UPDATE</command> operations, the return value should be <varname>NEW</varname>, which the trigger function may modify to support <command>INSERT RETURNING</command> and <command>UPDATE RETURNING</command> (this will also affect the row value passed to any subsequent triggers). For <command>DELETE</command> operations, the return value should be <varname>OLD</varname>."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:3458(para) 
msgid "The return value of a row-level trigger fired <literal>AFTER</literal> or a statement-level trigger fired <literal>BEFORE</literal> or <literal>AFTER</literal> is always ignored; it might as well be null. However, any of these types of triggers might still abort the entire operation by raising an error."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:3466(para) 
msgid "<xref linkend=\"plpgsql-trigger-example\"/> shows an example of a trigger procedure in <application>PL/pgSQL</application>."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:3472(title) 
msgid "A <application>PL/pgSQL</application> Trigger Procedure"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:3474(para) 
msgid "This example trigger ensures that any time a row is inserted or updated in the table, the current user name and time are stamped into the row. And it checks that an employee's name is given and that the salary is a positive value."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:3481(programlisting) 
#, no-wrap
msgid "\nCREATE TABLE emp (\n    empname text,\n    salary integer,\n    last_date timestamp,\n    last_user text\n);\n\nCREATE FUNCTION emp_stamp() RETURNS trigger AS $emp_stamp$\n    BEGIN\n        -- Check that empname and salary are given\n        IF NEW.empname IS NULL THEN\n            RAISE EXCEPTION 'empname cannot be null';\n        END IF;\n        IF NEW.salary IS NULL THEN\n            RAISE EXCEPTION '% cannot have null salary', NEW.empname;\n        END IF;\n\n        -- Who works for us when she must pay for it?\n        IF NEW.salary &lt; 0 THEN\n            RAISE EXCEPTION '% cannot have a negative salary', NEW.empname;\n        END IF;\n\n        -- Remember who changed the payroll when\n        NEW.last_date := current_timestamp;\n        NEW.last_user := current_user;\n        RETURN NEW;\n    END;\n$emp_stamp$ LANGUAGE plpgsql;\n\nCREATE TRIGGER emp_stamp BEFORE INSERT OR UPDATE ON emp\n    FOR EACH ROW EXECUTE PROCEDURE emp_stamp();\n"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:3516(para) 
msgid "Another way to log changes to a table involves creating a new table that holds a row for each insert, update, or delete that occurs. This approach can be thought of as auditing changes to a table. <xref linkend=\"plpgsql-trigger-audit-example\"/> shows an example of an audit trigger procedure in <application>PL/pgSQL</application>."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:3525(title) 
msgid "A <application>PL/pgSQL</application> Trigger Procedure For Auditing"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:3527(para) 
msgid "This example trigger ensures that any insert, update or delete of a row in the <literal>emp</literal> table is recorded (i.e., audited) in the <literal>emp_audit</literal> table. The current time and user name are stamped into the row, together with the type of operation performed on it."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:3534(programlisting) 
#, no-wrap
msgid "\nCREATE TABLE emp (\n    empname           text NOT NULL,\n    salary            integer\n);\n\nCREATE TABLE emp_audit(\n    operation         char(1)   NOT NULL,\n    stamp             timestamp NOT NULL,\n    userid            text      NOT NULL,\n    empname           text      NOT NULL,\n    salary integer\n);\n\nCREATE OR REPLACE FUNCTION process_emp_audit() RETURNS TRIGGER AS $emp_audit$\n    BEGIN\n        --\n        -- Create a row in emp_audit to reflect the operation performed on emp,\n        -- make use of the special variable TG_OP to work out the operation.\n        --\n        IF (TG_OP = 'DELETE') THEN\n            INSERT INTO emp_audit SELECT 'D', now(), user, OLD.*;\n            RETURN OLD;\n        ELSIF (TG_OP = 'UPDATE') THEN\n            INSERT INTO emp_audit SELECT 'U', now(), user, NEW.*;\n            RETURN NEW;\n        ELSIF (TG_OP = 'INSERT') THEN\n            INSERT INTO emp_audit SELECT 'I', now(), user, NEW.*;\n            RETURN NEW;\n        END IF;\n        RETURN NULL; -- result is ignored since this is an AFTER trigger\n    END;\n$emp_audit$ LANGUAGE plpgsql;\n\nCREATE TRIGGER emp_audit\nAFTER INSERT OR UPDATE OR DELETE ON emp\n    FOR EACH ROW EXECUTE PROCEDURE process_emp_audit();\n"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:3574(para) 
msgid "A variation of the previous example uses a view joining the main table to the audit table, to show when each entry was last modified. This approach still records the full audit trail of changes to the table, but also presents a simplified view of the audit trail, showing just the last modified timestamp derived from the audit trail for each entry. <xref linkend=\"plpgsql-view-trigger-audit-example\"/> shows an example of an audit trigger on a view in <application>PL/pgSQL</application>."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:3585(title) 
msgid "A <application>PL/pgSQL</application> View Trigger Procedure For Auditing"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:3587(para) 
msgid "This example uses a trigger on the view to make it updatable, and ensure that any insert, update or delete of a row in the view is recorded (i.e., audited) in the <literal>emp_audit</literal> table. The current time and user name are recorded, together with the type of operation performed, and the view displays the last modified time of each row."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:3595(programlisting) 
#, no-wrap
msgid "\nCREATE TABLE emp (\n    empname           text PRIMARY KEY,\n    salary            integer\n);\n\nCREATE TABLE emp_audit(\n    operation         char(1)   NOT NULL,\n    userid            text      NOT NULL,\n    empname           text      NOT NULL,\n    salary            integer,\n    stamp             timestamp NOT NULL\n);\n\nCREATE VIEW emp_view AS\n    SELECT e.empname,\n           e.salary,\n           max(ea.stamp) AS last_updated\n      FROM emp e\n      LEFT JOIN emp_audit ea ON ea.empname = e.empname\n     GROUP BY 1, 2;\n\nCREATE OR REPLACE FUNCTION update_emp_view() RETURNS TRIGGER AS $$\n    BEGIN\n        --\n        -- Perform the required operation on emp, and create a row in emp_audit\n        -- to reflect the change made to emp.\n        --\n        IF (TG_OP = 'DELETE') THEN\n            DELETE FROM emp WHERE empname = OLD.empname;\n            IF NOT FOUND THEN RETURN NULL; END IF;\n\n            OLD.last_updated = now();\n            INSERT INTO emp_audit VALUES('D', user, OLD.*);\n            RETURN OLD;\n        ELSIF (TG_OP = 'UPDATE') THEN\n            UPDATE emp SET salary = NEW.salary WHERE empname = OLD.empname;\n            IF NOT FOUND THEN RETURN NULL; END IF;\n\n            NEW.last_updated = now();\n            INSERT INTO emp_audit VALUES('U', user, NEW.*);\n            RETURN NEW;\n        ELSIF (TG_OP = 'INSERT') THEN\n            INSERT INTO emp VALUES(NEW.empname, NEW.salary);\n\n            NEW.last_updated = now();\n            INSERT INTO emp_audit VALUES('I', user, NEW.*);\n            RETURN NEW;\n        END IF;\n    END;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER emp_audit\nINSTEAD OF INSERT OR UPDATE OR DELETE ON emp_view\n    FOR EACH ROW EXECUTE PROCEDURE update_emp_view();\n"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:3653(para) 
msgid "One use of triggers is to maintain a summary table of another table. The resulting summary can be used in place of the original table for certain queries — often with vastly reduced run times. This technique is commonly used in Data Warehousing, where the tables of measured or observed data (called fact tables) might be extremely large. <xref linkend=\"plpgsql-trigger-summary-example\"/> shows an example of a trigger procedure in <application>PL/pgSQL</application> that maintains a summary table for a fact table in a data warehouse."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:3667(title) 
msgid "A <application>PL/pgSQL</application> Trigger Procedure For Maintaining A Summary Table"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:3669(para) 
msgid "The schema detailed here is partly based on the <emphasis>Grocery Store </emphasis> example from <emphasis>The Data Warehouse Toolkit</emphasis> by Ralph Kimball."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:3675(programlisting) 
#, no-wrap
msgid "\n--\n-- Main tables - time dimension and sales fact.\n--\nCREATE TABLE time_dimension (\n    time_key                    integer NOT NULL,\n    day_of_week                 integer NOT NULL,\n    day_of_month                integer NOT NULL,\n    month                       integer NOT NULL,\n    quarter                     integer NOT NULL,\n    year                        integer NOT NULL\n);\nCREATE UNIQUE INDEX time_dimension_key ON time_dimension(time_key);\n\nCREATE TABLE sales_fact (\n    time_key                    integer NOT NULL,\n    product_key                 integer NOT NULL,\n    store_key                   integer NOT NULL,\n    amount_sold                 numeric(12,2) NOT NULL,\n    units_sold                  integer NOT NULL,\n    amount_cost                 numeric(12,2) NOT NULL\n);\nCREATE INDEX sales_fact_time ON sales_fact(time_key);\n\n--\n-- Summary table - sales by time.\n--\nCREATE TABLE sales_summary_bytime (\n    time_key                    integer NOT NULL,\n    amount_sold                 numeric(15,2) NOT NULL,\n    units_sold                  numeric(12) NOT NULL,\n    amount_cost                 numeric(15,2) NOT NULL\n);\nCREATE UNIQUE INDEX sales_summary_bytime_key ON sales_summary_bytime(time_key);\n\n--\n-- Function and trigger to amend summarized column(s) on UPDATE, INSERT, DELETE.\n--\nCREATE OR REPLACE FUNCTION maint_sales_summary_bytime() RETURNS TRIGGER\nAS $maint_sales_summary_bytime$\n    DECLARE\n        delta_time_key          integer;\n        delta_amount_sold       numeric(15,2);\n        delta_units_sold        numeric(12);\n        delta_amount_cost       numeric(15,2);\n    BEGIN\n\n        -- Work out the increment/decrement amount(s).\n        IF (TG_OP = 'DELETE') THEN\n\n            delta_time_key = OLD.time_key;\n            delta_amount_sold = -1 * OLD.amount_sold;\n            delta_units_sold = -1 * OLD.units_sold;\n            delta_amount_cost = -1 * OLD.amount_cost;\n\n        ELSIF (TG_OP = 'UPDATE') THEN\n\n            -- forbid updates that change the time_key -\n            -- (probably not too onerous, as DELETE + INSERT is how most\n            -- changes will be made).\n            IF ( OLD.time_key != NEW.time_key) THEN\n                RAISE EXCEPTION 'Update of time_key : % -&gt; % not allowed',\n                                                      OLD.time_key, NEW.time_key;\n            END IF;\n\n            delta_time_key = OLD.time_key;\n            delta_amount_sold = NEW.amount_sold - OLD.amount_sold;\n            delta_units_sold = NEW.units_sold - OLD.units_sold;\n            delta_amount_cost = NEW.amount_cost - OLD.amount_cost;\n\n        ELSIF (TG_OP = 'INSERT') THEN\n\n            delta_time_key = NEW.time_key;\n            delta_amount_sold = NEW.amount_sold;\n            delta_units_sold = NEW.units_sold;\n            delta_amount_cost = NEW.amount_cost;\n\n        END IF;\n\n\n        -- Insert or update the summary row with the new values.\n        &lt;&lt;insert_update&gt;&gt;\n        LOOP\n            UPDATE sales_summary_bytime\n                SET amount_sold = amount_sold + delta_amount_sold,\n                    units_sold = units_sold + delta_units_sold,\n                    amount_cost = amount_cost + delta_amount_cost\n                WHERE time_key = delta_time_key;\n\n            EXIT insert_update WHEN found;\n\n            BEGIN\n                INSERT INTO sales_summary_bytime (\n                            time_key,\n                            amount_sold,\n                            units_sold,\n                            amount_cost)\n                    VALUES (\n                            delta_time_key,\n                            delta_amount_sold,\n                            delta_units_sold,\n                            delta_amount_cost\n                           );\n\n                EXIT insert_update;\n\n            EXCEPTION\n                WHEN UNIQUE_VIOLATION THEN\n                    -- do nothing\n            END;\n        END LOOP insert_update;\n\n        RETURN NULL;\n\n    END;\n$maint_sales_summary_bytime$ LANGUAGE plpgsql;\n\nCREATE TRIGGER maint_sales_summary_bytime\nAFTER INSERT OR UPDATE OR DELETE ON sales_fact\n    FOR EACH ROW EXECUTE PROCEDURE maint_sales_summary_bytime();\n\nINSERT INTO sales_fact VALUES(1,1,1,10,3,15);\nINSERT INTO sales_fact VALUES(1,2,1,20,5,35);\nINSERT INTO sales_fact VALUES(2,2,1,40,15,135);\nINSERT INTO sales_fact VALUES(2,3,1,10,1,13);\nSELECT * FROM sales_summary_bytime;\nDELETE FROM sales_fact WHERE product_key = 1;\nSELECT * FROM sales_summary_bytime;\nUPDATE sales_fact SET units_sold = units_sold * 2;\nSELECT * FROM sales_summary_bytime;\n"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:3811(title) 
msgid "<application>PL/pgSQL</application> Under the Hood"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:3813(para) 
msgid "This section discusses some implementation details that are frequently important for <application>PL/pgSQL</application> users to know."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:3819(title) 
msgid "Variable Substitution"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:3828(programlisting) 
#, no-wrap
msgid "\nINSERT INTO foo (foo) VALUES (foo);\n"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:3821(para) 
msgid "SQL statements and expressions within a <application>PL/pgSQL</application> function can refer to variables and parameters of the function. Behind the scenes, <application>PL/pgSQL</application> substitutes query parameters for such references. Parameters will only be substituted in places where a parameter or column reference is syntactically allowed. As an extreme case, consider this example of poor programming style: <placeholder-1/> The first occurrence of <literal>foo</literal> must syntactically be a table name, so it will not be substituted, even if the function has a variable named <literal>foo</literal>. The second occurrence must be the name of a column of the table, so it will not be substituted either. Only the third occurrence is a candidate to be a reference to the function's variable."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:3840(para) 
msgid "<productname>PostgreSQL</productname> versions before 9.0 would try to substitute the variable in all three cases, leading to syntax errors."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:3851(programlisting) 
#, no-wrap
msgid "\nINSERT INTO dest (col) SELECT foo + bar FROM src;\n"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:3846(para) 
msgid "Since the names of variables are syntactically no different from the names of table columns, there can be ambiguity in statements that also refer to tables: is a given name meant to refer to a table column, or a variable? Let's change the previous example to <placeholder-1/> Here, <literal>dest</literal> and <literal>src</literal> must be table names, and <literal>col</literal> must be a column of <literal>dest</literal>, but <literal>foo</literal> and <literal>bar</literal> might reasonably be either variables of the function or columns of <literal>src</literal>."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:3860(para) 
msgid "By default, <application>PL/pgSQL</application> will report an error if a name in a SQL statement could refer to either a variable or a table column. You can fix such a problem by renaming the variable or column, or by qualifying the ambiguous reference, or by telling <application>PL/pgSQL</application> which interpretation to prefer."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:3868(para) 
msgid "The simplest solution is to rename the variable or column. A common coding rule is to use a different naming convention for <application>PL/pgSQL</application> variables than you use for column names. For example, if you consistently name function variables <literal>v_<replaceable>something</replaceable></literal> while none of your column names start with <literal>v_</literal>, no conflicts will occur."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:3884(programlisting) 
#, no-wrap
msgid "\n&lt;&lt;block&gt;&gt;\nDECLARE\n    foo int;\nBEGIN\n    foo := ...;\n    INSERT INTO dest (col) SELECT block.foo + bar FROM src;\n"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:3878(para) 
msgid "Alternatively you can qualify ambiguous references to make them clear. In the above example, <literal>src.foo</literal> would be an unambiguous reference to the table column. To create an unambiguous reference to a variable, declare it in a labeled block and use the block's label (see <xref linkend=\"plpgsql-structure\"/>). For example, <placeholder-1/> Here <literal>block.foo</literal> means the variable even if there is a column <literal>foo</literal> in <literal>src</literal>. Function parameters, as well as special variables such as <literal>FOUND</literal>, can be qualified by the function's name, because they are implicitly declared in an outer block labeled with the function's name."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:3899(para) 
msgid "Sometimes it is impractical to fix all the ambiguous references in a large body of <application>PL/pgSQL</application> code. In such cases you can specify that <application>PL/pgSQL</application> should resolve ambiguous references as the variable (which is compatible with <application>PL/pgSQL</application>'s behavior before <productname>PostgreSQL</productname> 9.0), or as the table column (which is compatible with some other systems such as <productname>Oracle</productname>)."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:3910(varname) 
msgid "plpgsql.variable_conflict"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:3910(primary) 
msgid "<placeholder-1/> configuration parameter"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:3913(para) 
msgid "To change this behavior on a system-wide basis, set the configuration parameter <literal>plpgsql.variable_conflict</literal> to one of <literal>error</literal>, <literal>use_variable</literal>, or <literal>use_column</literal> (where <literal>error</literal> is the factory default). This parameter affects subsequent compilations of statements in <application>PL/pgSQL</application> functions, but not statements already compiled in the current session. To set the parameter before <application>PL/pgSQL</application> has been loaded, it is necessary to have added <quote><literal>plpgsql</literal></quote> to the <xref linkend=\"guc-custom-variable-classes\"/> list in <filename>postgresql.conf</filename>. Because changing this setting can cause unexpected changes in the behavior of <application>PL/pgSQL</application> functions, it can only be changed by a superuser."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:3933(programlisting) 
#, no-wrap
msgid "\n#variable_conflict error\n#variable_conflict use_variable\n#variable_conflict use_column\n"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:3940(programlisting) 
#, no-wrap
msgid "\nCREATE FUNCTION stamp_user(id int, comment text) RETURNS void AS $$\n    #variable_conflict use_variable\n    DECLARE\n        curtime timestamp := now();\n    BEGIN\n        UPDATE users SET last_modified = curtime, comment = comment\n          WHERE users.id = id;\n    END;\n$$ LANGUAGE plpgsql;\n"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:3961(programlisting) 
#, no-wrap
msgid "\nCREATE FUNCTION stamp_user(id int, comment text) RETURNS void AS $$\n    &lt;&lt;fn&gt;&gt;\n    DECLARE\n        curtime timestamp := now();\n    BEGIN\n        UPDATE users SET last_modified = fn.curtime, comment = stamp_user.comment\n          WHERE users.id = stamp_user.id;\n    END;\n$$ LANGUAGE plpgsql;\n"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:3929(para) 
msgid "You can also set the behavior on a function-by-function basis, by inserting one of these special commands at the start of the function text: <placeholder-1/> These commands affect only the function they are written in, and override the setting of <literal>plpgsql.variable_conflict</literal>. An example is <placeholder-2/> In the <literal>UPDATE</literal> command, <literal>curtime</literal>, <literal>comment</literal>, and <literal>id</literal> will refer to the function's variable and parameters whether or not <literal>users</literal> has columns of those names. Notice that we had to qualify the reference to <literal>users.id</literal> in the <literal>WHERE</literal> clause to make it refer to the table column. But we did not have to qualify the reference to <literal>comment</literal> as a target in the <literal>UPDATE</literal> list, because syntactically that must be a column of <literal>users</literal>. We could write the same function without depending on the <literal>variable_conflict</literal> setting in this way: <placeholder-3/>"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:3974(para) 
msgid "Variable substitution does not happen in the command string given to <command>EXECUTE</command> or one of its variants. If you need to insert a varying value into such a command, do so as part of constructing the string value, or use <literal>USING</literal>, as illustrated in <xref linkend=\"plpgsql-statements-executing-dyn\"/>."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:3982(para) 
msgid "Variable substitution currently works only in <command>SELECT</command>, <command>INSERT</command>, <command>UPDATE</command>, and <command>DELETE</command> commands, because the main SQL engine allows query parameters only in these commands. To use a non-constant name or value in other statement types (generically called utility statements), you must construct the utility statement as a string and <command>EXECUTE</command> it."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:3994(title) 
msgid "Plan Caching"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:3996(para) 
msgid "The <application>PL/pgSQL</application> interpreter parses the function's source text and produces an internal binary instruction tree the first time the function is called (within each session). The instruction tree fully translates the <application>PL/pgSQL</application> statement structure, but individual <acronym>SQL</acronym> expressions and <acronym>SQL</acronym> commands used in the function are not translated immediately."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:4006(para) 
msgid "<indexterm><primary>preparing a query</primary><secondary>in PL/pgSQL</secondary></indexterm> As each expression and <acronym>SQL</acronym> command is first executed in the function, the <application>PL/pgSQL</application> interpreter creates a prepared execution plan (using the <acronym>SPI</acronym> manager's <function>SPI_prepare</function> and <function>SPI_saveplan</function> functions). Subsequent visits to that expression or command reuse the prepared plan. Thus, a function with conditional code that contains many statements for which execution plans might be required will only prepare and save those plans that are really used during the lifetime of the database connection. This can substantially reduce the total amount of time required to parse and generate execution plans for the statements in a <application>PL/pgSQL</application> function. A disadvantage is that errors in a specific expression or command cannot be detected until that part of the function is reached in execution. (Trivial syntax errors will be detected during the initial parsing pass, but anything deeper will not be detected until execution.)"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:4030(para) 
msgid "A saved plan will be re-planned automatically if there is any schema change to any table used in the query, or if any user-defined function used in the query is redefined. This makes the re-use of prepared plans transparent in most cases, but there are corner cases where a stale plan might be re-used. An example is that dropping and re-creating a user-defined operator won't affect already-cached plans; they'll continue to call the original operator's underlying function, if that has not been changed. When necessary, the cache can be flushed by starting a fresh database session."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:4042(para) 
msgid "Because <application>PL/pgSQL</application> saves execution plans in this way, SQL commands that appear directly in a <application>PL/pgSQL</application> function must refer to the same tables and columns on every execution; that is, you cannot use a parameter as the name of a table or column in an SQL command. To get around this restriction, you can construct dynamic commands using the <application>PL/pgSQL</application><command>EXECUTE</command> statement — at the price of constructing a new execution plan on every execution."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:4060(programlisting) 
#, no-wrap
msgid "\nSELECT * INTO myrec FROM dictionary WHERE word LIKE search_term;\n"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:4054(para) 
msgid "Another important point is that the prepared plans are parameterized to allow the values of <application>PL/pgSQL</application> variables to change from one use to the next, as discussed in detail above. Sometimes this means that a plan is less efficient than it would be if generated for a specific variable value. As an example, consider <placeholder-1/> where <literal>search_term</literal> is a <application>PL/pgSQL</application> variable. The cached plan for this query will never use an index on <structfield>word</structfield>, since the planner cannot assume that the <literal>LIKE</literal> pattern will be left-anchored at run time. To use an index the query must be planned with a specific constant <literal>LIKE</literal> pattern provided. This is another situation where <command>EXECUTE</command> can be used to force a new plan to be generated for each execution."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:4073(para) 
msgid "The mutable nature of record variables presents another problem in this connection. When fields of a record variable are used in expressions or statements, the data types of the fields must not change from one call of the function to the next, since each expression will be planned using the data type that is present when the expression is first reached. <command>EXECUTE</command> can be used to get around this problem when necessary."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:4083(para) 
msgid "If the same function is used as a trigger for more than one table, <application>PL/pgSQL</application> prepares and caches plans independently for each such table — that is, there is a cache for each trigger function and table combination, not just for each function. This alleviates some of the problems with varying data types; for instance, a trigger function will be able to work successfully with a column named <literal>key</literal> even if it happens to have different types in different tables."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:4094(para) 
msgid "Likewise, functions having polymorphic argument types have a separate plan cache for each combination of actual argument types they have been invoked for, so that data type differences do not cause unexpected failures."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:4106(programlisting) 
#, no-wrap
msgid "\nCREATE FUNCTION logfunc1(logtxt text) RETURNS void AS $$\n    BEGIN\n        INSERT INTO logtable VALUES (logtxt, 'now');\n    END;\n$$ LANGUAGE plpgsql;\n"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:4116(programlisting) 
#, no-wrap
msgid "\nCREATE FUNCTION logfunc2(logtxt text) RETURNS void AS $$\n    DECLARE\n        curtime timestamp;\n    BEGIN\n        curtime := 'now';\n        INSERT INTO logtable VALUES (logtxt, curtime);\n    END;\n$$ LANGUAGE plpgsql;\n"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:4101(para) 
msgid "Plan caching can sometimes have surprising effects on the interpretation of time-sensitive values. For example there is a difference between what these two functions do: <placeholder-1/> and: <placeholder-2/>"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:4128(para) 
msgid "In the case of <function>logfunc1</function>, the <productname>PostgreSQL</productname> main parser knows when preparing the plan for the <command>INSERT</command> that the string <literal>'now'</literal> should be interpreted as <type>timestamp</type>, because the target column of <classname>logtable</classname> is of that type. Thus, <literal>'now'</literal> will be converted to a constant when the <command>INSERT</command> is planned, and then used in all invocations of <function>logfunc1</function> during the lifetime of the session. Needless to say, this isn't what the programmer wanted."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:4142(para) 
msgid "In the case of <function>logfunc2</function>, the <productname>PostgreSQL</productname> main parser does not know what type <literal>'now'</literal> should become and therefore it returns a data value of type <type>text</type> containing the string <literal>now</literal>. During the ensuing assignment to the local variable <varname>curtime</varname>, the <application>PL/pgSQL</application> interpreter casts this string to the <type>timestamp</type> type by calling the <function>text_out</function> and <function>timestamp_in</function> functions for the conversion. So, the computed time stamp is updated on each execution as the programmer expects."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:4161(title) 
msgid "Tips for Developing in <application>PL/pgSQL</application>"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:4172(programlisting) 
#, no-wrap
msgid "\nCREATE OR REPLACE FUNCTION testfunc(integer) RETURNS integer AS $$\n          ....\n$$ LANGUAGE plpgsql;\n"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:4163(para) 
msgid "One good way to develop in <application>PL/pgSQL</application> is to use the text editor of your choice to create your functions, and in another window, use <application>psql</application> to load and test those functions. If you are doing it this way, it is a good idea to write the function using <command>CREATE OR REPLACE FUNCTION</command>. That way you can just reload the file to update the function definition. For example: <placeholder-1/>"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:4182(programlisting) 
#, no-wrap
msgid "\n\\i filename.sql\n"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:4179(para) 
msgid "While running <application>psql</application>, you can load or reload such a function definition file with: <placeholder-1/> and then immediately issue SQL commands to test the function."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:4188(para) 
msgid "Another good way to develop in <application>PL/pgSQL</application> is with a GUI database access tool that facilitates development in a procedural language. One example of such a tool is <application>pgAdmin</application>, although others exist. These tools often provide convenient features such as escaping single quotes and making it easier to recreate and debug functions."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:4198(title) 
msgid "Handling of Quotation Marks"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:4217(programlisting) 
#, no-wrap
msgid "\nCREATE OR REPLACE FUNCTION testfunc(integer) RETURNS integer AS $PROC$\n          ....\n$PROC$ LANGUAGE plpgsql;\n"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:4200(para) 
msgid "The code of a <application>PL/pgSQL</application> function is specified in <command>CREATE FUNCTION</command> as a string literal. If you write the string literal in the ordinary way with surrounding single quotes, then any single quotes inside the function body must be doubled; likewise any backslashes must be doubled (assuming escape string syntax is used). Doubling quotes is at best tedious, and in more complicated cases the code can become downright incomprehensible, because you can easily find yourself needing half a dozen or more adjacent quote marks. It's recommended that you instead write the function body as a <quote>dollar-quoted</quote> string literal (see <xref linkend=\"sql-syntax-dollar-quoting\"/>). In the dollar-quoting approach, you never double any quote marks, but instead take care to choose a different dollar-quoting delimiter for each level of nesting you need. For example, you might write the <command>CREATE FUNCTION</command> command as: <placeholder-1/> Within this, you might use quote marks for simple literal strings in SQL commands and <literal>$$</literal> to delimit fragments of SQL commands that you are assembling as strings. If you need to quote text that includes <literal>$$</literal>, you could use <literal>$Q$</literal>, and so on."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:4228(para) 
msgid "The following chart shows what you have to do when writing quote marks without dollar quoting. It might be useful when translating pre-dollar quoting code into something more comprehensible."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:4236(term) 
msgid "1 quotation mark"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:4240(programlisting) 
#, no-wrap
msgid "\nCREATE FUNCTION foo() RETURNS integer AS '\n          ....\n' LANGUAGE plpgsql;\n"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:4238(para) 
msgid "To begin and end the function body, for example: <placeholder-1/> Anywhere within a single-quoted function body, quote marks <emphasis>must</emphasis> appear in pairs."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:4252(term) 
msgid "2 quotation marks"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:4256(programlisting) 
#, no-wrap
msgid "\na_output := ''Blah'';\nSELECT * FROM users WHERE f_name=''foobar'';\n"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:4261(programlisting) 
#, no-wrap
msgid "\na_output := 'Blah';\nSELECT * FROM users WHERE f_name='foobar';\n"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:4254(para) 
msgid "For string literals inside the function body, for example: <placeholder-1/> In the dollar-quoting approach, you'd just write: <placeholder-2/> which is exactly what the <application>PL/pgSQL</application> parser would see in either case."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:4272(term) 
msgid "4 quotation marks"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:4277(programlisting) 
#, no-wrap
msgid "\na_output := a_output || '' AND name LIKE ''''foobar'''' AND xyz''\n"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:4274(para) 
msgid "When you need a single quotation mark in a string constant inside the function body, for example: <placeholder-1/> The value actually appended to <literal>a_output</literal> would be: <literal> AND name LIKE 'foobar' AND xyz</literal>."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:4285(programlisting) 
#, no-wrap
msgid "\na_output := a_output || $$ AND name LIKE 'foobar' AND xyz$$\n"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:4283(para) 
msgid "In the dollar-quoting approach, you'd write: <placeholder-1/> being careful that any dollar-quote delimiters around this are not just <literal>$$</literal>."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:4295(term) 
msgid "6 quotation marks"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:4300(programlisting) 
#, no-wrap
msgid "\na_output := a_output || '' AND name LIKE ''''foobar''''''\n"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:4297(para) 
msgid "When a single quotation mark in a string inside the function body is adjacent to the end of that string constant, for example: <placeholder-1/> The value appended to <literal>a_output</literal> would then be: <literal> AND name LIKE 'foobar'</literal>."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:4308(programlisting) 
#, no-wrap
msgid "\na_output := a_output || $$ AND name LIKE 'foobar'$$\n"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:4306(para) 
msgid "In the dollar-quoting approach, this becomes: <placeholder-1/>"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:4316(term) 
msgid "10 quotation marks"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:4325(programlisting) 
#, no-wrap
msgid "\na_output := a_output || '' if v_'' ||\n    referrer_keys.kind || '' like ''''''''''\n    || referrer_keys.key_string || ''''''''''\n    then return ''''''  || referrer_keys.referrer_type\n    || ''''''; end if;'';\n"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:4333(programlisting) 
#, no-wrap
msgid "\nif v_... like ''...'' then return ''...''; end if;\n"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:4318(para) 
msgid "When you want two single quotation marks in a string constant (which accounts for 8 quotation marks) and this is adjacent to the end of that string constant (2 more). You will probably only need that if you are writing a function that generates other functions, as in <xref linkend=\"plpgsql-porting-ex2\"/>. For example: <placeholder-1/> The value of <literal>a_output</literal> would then be: <placeholder-2/>"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:4339(programlisting) 
#, no-wrap
msgid "\na_output := a_output || $$ if v_$$ || referrer_keys.kind || $$ like '$$\n    || referrer_keys.key_string || $$'\n    then return '$$  || referrer_keys.referrer_type\n    || $$'; end if;$$;\n"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:4337(para) 
msgid "In the dollar-quoting approach, this becomes: <placeholder-1/> where we assume we only need to put single quote marks into <literal>a_output</literal>, because it will be re-quoted before use."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:4358(title) 
msgid "Porting from <productname>Oracle</productname> PL/SQL"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:4361(primary) 
msgid "Oracle"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:4362(secondary) 
msgid "porting from PL/SQL to PL/pgSQL"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:4366(primary) 
msgid "PL/SQL (Oracle)"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:4367(secondary) 
msgid "porting to PL/pgSQL"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:4370(para) 
msgid "This section explains differences between <productname>PostgreSQL</productname>'s <application>PL/pgSQL</application> language and Oracle's <application>PL/SQL</application> language, to help developers who port applications from <trademark class=\"registered\">Oracle</trademark> to <productname>PostgreSQL</productname>."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:4388(para) 
msgid "If a name used in a SQL command could be either a column name of a table or a reference to a variable of the function, <application>PL/SQL</application> treats it as a column name. This corresponds to <application>PL/pgSQL</application>'s <literal>plpgsql.variable_conflict</literal> = <literal>use_column</literal> behavior, which is not the default, as explained in <xref linkend=\"plpgsql-var-subst\"/>. It's often best to avoid such ambiguities in the first place, but if you have to port a large amount of code that depends on this behavior, setting <literal>variable_conflict</literal> may be the best solution."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:4404(para) 
msgid "In <productname>PostgreSQL</productname> the function body must be written as a string literal. Therefore you need to use dollar quoting or escape single quotes in the function body. (See <xref linkend=\"plpgsql-quote-tips\"/>.)"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:4413(para) 
msgid "Instead of packages, use schemas to organize your functions into groups."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:4420(para) 
msgid "Since there are no packages, there are no package-level variables either. This is somewhat annoying. You can keep per-session state in temporary tables instead."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:4428(para) 
msgid "Integer <command>FOR</command> loops with <literal>REVERSE</literal> work differently: <application>PL/SQL</application> counts down from the second number to the first, while <application>PL/pgSQL</application> counts down from the first number to the second, requiring the loop bounds to be swapped when porting. This incompatibility is unfortunate but is unlikely to be changed. (See <xref linkend=\"plpgsql-integer-for\"/>.)"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:4440(para) 
msgid "<command>FOR</command> loops over queries (other than cursors) also work differently: the target variable(s) must have been declared, whereas <application>PL/SQL</application> always declares them implicitly. An advantage of this is that the variable values are still accessible after the loop exits."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:4450(para) 
msgid "There are various notational differences for the use of cursor variables."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:4378(para) 
msgid "<application>PL/pgSQL</application> is similar to PL/SQL in many aspects. It is a block-structured, imperative language, and all variables have to be declared. Assignments, loops, conditionals are similar. The main differences you should keep in mind when porting from <application>PL/SQL</application> to <application>PL/pgSQL</application> are: <placeholder-1/>"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:4460(title) 
msgid "Porting Examples"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:4462(para) 
msgid "<xref linkend=\"pgsql-porting-ex1\"/> shows how to port a simple function from <application>PL/SQL</application> to <application>PL/pgSQL</application>."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:4468(title) 
msgid "Porting a Simple Function from <application>PL/SQL</application> to <application>PL/pgSQL</application>"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:4472(programlisting) 
#, no-wrap
msgid "\nCREATE OR REPLACE FUNCTION cs_fmt_browser_version(v_name varchar,\n                                                  v_version varchar)\nRETURN varchar IS\nBEGIN\n    IF v_version IS NULL THEN\n        RETURN v_name;\n    END IF;\n    RETURN v_name || '/' || v_version;\nEND;\n/\nshow errors;\n"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:4470(para) 
msgid "Here is an <productname>Oracle</productname><application>PL/SQL</application> function: <placeholder-1/>"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:4493(para) 
msgid "The <literal>RETURN</literal> key word in the function prototype (not the function body) becomes <literal>RETURNS</literal> in <productname>PostgreSQL</productname>. Also, <literal>IS</literal> becomes <literal>AS</literal>, and you need to add a <literal>LANGUAGE</literal> clause because <application>PL/pgSQL</application> is not the only possible function language."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:4505(para) 
msgid "In <productname>PostgreSQL</productname>, the function body is considered to be a string literal, so you need to use quote marks or dollar quotes around it. This substitutes for the terminating <literal>/</literal> in the Oracle approach."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:4514(para) 
msgid "The <literal>show errors</literal> command does not exist in <productname>PostgreSQL</productname>, and is not needed since errors are reported automatically."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:4487(para) 
msgid "Let's go through this function and see the differences compared to <application>PL/pgSQL</application>: <placeholder-1/>"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:4527(programlisting) 
#, no-wrap
msgid "\nCREATE OR REPLACE FUNCTION cs_fmt_browser_version(v_name varchar,\n                                                  v_version varchar)\nRETURNS varchar AS $$\nBEGIN\n    IF v_version IS NULL THEN\n        RETURN v_name;\n    END IF;\n    RETURN v_name || '/' || v_version;\nEND;\n$$ LANGUAGE plpgsql;\n"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:4523(para) 
msgid "This is how this function would look when ported to <productname>PostgreSQL</productname>: <placeholder-1/>"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:4542(para) 
msgid "<xref linkend=\"plpgsql-porting-ex2\"/> shows how to port a function that creates another function and how to handle the ensuing quoting problems."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:4549(title) 
msgid "Porting a Function that Creates Another Function from <application>PL/SQL</application> to <application>PL/pgSQL</application>"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:4551(para) 
msgid "The following procedure grabs rows from a <command>SELECT</command> statement and builds a large function with the results in <literal>IF</literal> statements, for the sake of efficiency."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:4560(programlisting) 
#, no-wrap
msgid "\nCREATE OR REPLACE PROCEDURE cs_update_referrer_type_proc IS\n    CURSOR referrer_keys IS\n        SELECT * FROM cs_referrer_keys\n        ORDER BY try_order;\n    func_cmd VARCHAR(4000);\nBEGIN\n    func_cmd := 'CREATE OR REPLACE FUNCTION cs_find_referrer_type(v_host IN VARCHAR,\n                 v_domain IN VARCHAR, v_url IN VARCHAR) RETURN VARCHAR IS BEGIN';\n\n    FOR referrer_key IN referrer_keys LOOP\n        func_cmd := func_cmd ||\n          ' IF v_' || referrer_key.kind\n          || ' LIKE ''' || referrer_key.key_string\n          || ''' THEN RETURN ''' || referrer_key.referrer_type\n          || '''; END IF;';\n    END LOOP;\n\n    func_cmd := func_cmd || ' RETURN NULL; END;';\n\n    EXECUTE IMMEDIATE func_cmd;\nEND;\n/\nshow errors;\n"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:4558(para) /tmp/cicero-gTQe/plpgsql.xml:4660(para) 
msgid "This is the Oracle version: <placeholder-1/>"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:4589(programlisting) 
#, no-wrap
msgid "\nCREATE OR REPLACE FUNCTION cs_update_referrer_type_proc() RETURNS void AS $func$\nDECLARE\n    referrer_keys CURSOR IS\n        SELECT * FROM cs_referrer_keys\n        ORDER BY try_order;\n    func_body text;\n    func_cmd text;\nBEGIN\n    func_body := 'BEGIN';\n\n    FOR referrer_key IN referrer_keys LOOP\n        func_body := func_body ||\n          ' IF v_' || referrer_key.kind\n          || ' LIKE ' || quote_literal(referrer_key.key_string)\n          || ' THEN RETURN ' || quote_literal(referrer_key.referrer_type)\n          || '; END IF;' ;\n    END LOOP;\n\n    func_body := func_body || ' RETURN NULL; END;';\n\n    func_cmd :=\n      'CREATE OR REPLACE FUNCTION cs_find_referrer_type(v_host varchar,\n                                                        v_domain varchar,\n                                                        v_url varchar)\n        RETURNS varchar AS '\n      || quote_literal(func_body)\n      || ' LANGUAGE plpgsql;' ;\n\n    EXECUTE func_cmd;\nEND;\n$func$ LANGUAGE plpgsql;\n"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:4587(para) 
msgid "Here is how this function would end up in <productname>PostgreSQL</productname>: <placeholder-1/> Notice how the body of the function is built separately and passed through <literal>quote_literal</literal> to double any quote marks in it. This technique is needed because we cannot safely use dollar quoting for defining the new function: we do not know for sure what strings will be interpolated from the <structfield>referrer_key.key_string</structfield> field. (We are assuming here that <structfield>referrer_key.kind</structfield> can be trusted to always be <literal>host</literal>, <literal>domain</literal>, or <literal>url</literal>, but <structfield>referrer_key.key_string</structfield> might be anything, in particular it might contain dollar signs.) This function is actually an improvement on the Oracle original, because it will not generate broken code when <structfield>referrer_key.key_string</structfield> or <structfield>referrer_key.referrer_type</structfield> contain quote marks."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:4637(para) 
msgid "<xref linkend=\"plpgsql-porting-ex3\"/> shows how to port a function with <literal>OUT</literal> parameters and string manipulation. <productname>PostgreSQL</productname> does not have a built-in <function>instr</function> function, but you can create one using a combination of other functions.<indexterm><primary>instr</primary></indexterm> In <xref linkend=\"plpgsql-porting-appendix\"/> there is a <application>PL/pgSQL</application> implementation of <function>instr</function> that you can use to make your porting easier."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:4651(title) 
msgid "Porting a Procedure With String Manipulation and <literal>OUT</literal> Parameters from <application>PL/SQL</application> to <application>PL/pgSQL</application>"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:4655(para) 
msgid "The following <productname>Oracle</productname> PL/SQL procedure is used to parse a URL and return several elements (host, path, and query)."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:4662(programlisting) 
#, no-wrap
msgid "\nCREATE OR REPLACE PROCEDURE cs_parse_url(\n    v_url IN VARCHAR,\n    v_host OUT VARCHAR,  -- This will be passed back\n    v_path OUT VARCHAR,  -- This one too\n    v_query OUT VARCHAR) -- And this one\nIS\n    a_pos1 INTEGER;\n    a_pos2 INTEGER;\nBEGIN\n    v_host := NULL;\n    v_path := NULL;\n    v_query := NULL;\n    a_pos1 := instr(v_url, '//');\n\n    IF a_pos1 = 0 THEN\n        RETURN;\n    END IF;\n    a_pos2 := instr(v_url, '/', a_pos1 + 2);\n    IF a_pos2 = 0 THEN\n        v_host := substr(v_url, a_pos1 + 2);\n        v_path := '/';\n        RETURN;\n    END IF;\n\n    v_host := substr(v_url, a_pos1 + 2, a_pos2 - a_pos1 - 2);\n    a_pos1 := instr(v_url, '?', a_pos2 + 1);\n\n    IF a_pos1 = 0 THEN\n        v_path := substr(v_url, a_pos2);\n        RETURN;\n    END IF;\n\n    v_path := substr(v_url, a_pos2, a_pos1 - a_pos2);\n    v_query := substr(v_url, a_pos1 + 1);\nEND;\n/\nshow errors;\n"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:4705(programlisting) 
#, no-wrap
msgid "\nCREATE OR REPLACE FUNCTION cs_parse_url(\n    v_url IN VARCHAR,\n    v_host OUT VARCHAR,  -- This will be passed back\n    v_path OUT VARCHAR,  -- This one too\n    v_query OUT VARCHAR) -- And this one\nAS $$\nDECLARE\n    a_pos1 INTEGER;\n    a_pos2 INTEGER;\nBEGIN\n    v_host := NULL;\n    v_path := NULL;\n    v_query := NULL;\n    a_pos1 := instr(v_url, '//');\n\n    IF a_pos1 = 0 THEN\n        RETURN;\n    END IF;\n    a_pos2 := instr(v_url, '/', a_pos1 + 2);\n    IF a_pos2 = 0 THEN\n        v_host := substr(v_url, a_pos1 + 2);\n        v_path := '/';\n        RETURN;\n    END IF;\n\n    v_host := substr(v_url, a_pos1 + 2, a_pos2 - a_pos1 - 2);\n    a_pos1 := instr(v_url, '?', a_pos2 + 1);\n\n    IF a_pos1 = 0 THEN\n        v_path := substr(v_url, a_pos2);\n        RETURN;\n    END IF;\n\n    v_path := substr(v_url, a_pos2, a_pos1 - a_pos2);\n    v_query := substr(v_url, a_pos1 + 1);\nEND;\n$$ LANGUAGE plpgsql;\n"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:4746(programlisting) 
#, no-wrap
msgid "\nSELECT * FROM cs_parse_url('http://foobar.com/query.cgi?baz');\n"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:4703(para) 
msgid "Here is a possible translation into <application>PL/pgSQL</application>: <placeholder-1/> This function could be used like this: <placeholder-2/>"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:4752(para) 
msgid "<xref linkend=\"plpgsql-porting-ex4\"/> shows how to port a procedure that uses numerous features that are specific to Oracle."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:4758(title) 
msgid "Porting a Procedure from <application>PL/SQL</application> to <application>PL/pgSQL</application>"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:4763(programlisting) 
#, no-wrap
msgid "\nCREATE OR REPLACE PROCEDURE cs_create_job(v_job_id IN INTEGER) IS\n    a_running_job_count INTEGER;\n    PRAGMA AUTONOMOUS_TRANSACTION;<co id=\"co.plpgsql-porting-pragma\"></co>\nBEGIN\n    LOCK TABLE cs_jobs IN EXCLUSIVE MODE;<co id=\"co.plpgsql-porting-locktable\"></co>\n\n    SELECT count(*) INTO a_running_job_count FROM cs_jobs WHERE end_stamp IS NULL;\n\n    IF a_running_job_count &gt; 0 THEN\n        COMMIT; -- free lock<co id=\"co.plpgsql-porting-commit\"></co>\n        raise_application_error(-20000,\n                 'Unable to create a new job: a job is currently running.');\n    END IF;\n\n    DELETE FROM cs_active_job;\n    INSERT INTO cs_active_job(job_id) VALUES (v_job_id);\n\n    BEGIN\n        INSERT INTO cs_jobs (job_id, start_stamp) VALUES (v_job_id, sysdate);\n    EXCEPTION\n        WHEN dup_val_on_index THEN NULL; -- don't worry if it already exists\n    END;\n    COMMIT;\nEND;\n/\nshow errors\n"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:4760(para) 
msgid "The Oracle version: <placeholder-1/>"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:4800(para) 
msgid "There is no <literal>PRAGMA</literal> statement in <productname>PostgreSQL</productname>."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:4806(para) 
msgid "If you do a <command>LOCK TABLE</command> in <application>PL/pgSQL</application>, the lock will not be released until the calling transaction is finished."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:4814(para) 
msgid "You cannot issue <command>COMMIT</command> in a <application>PL/pgSQL</application> function. The function is running within some outer transaction and so <command>COMMIT</command> would imply terminating the function's execution. However, in this particular case it is not necessary anyway, because the lock obtained by the <command>LOCK TABLE</command> will be released when we raise an error."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:4793(para) 
msgid "Procedures like this can easily be converted into <productname>PostgreSQL</productname> functions returning <type>void</type>. This procedure in particular is interesting because it can teach us some things: <placeholder-1/>"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:4830(programlisting) 
#, no-wrap
msgid "\nCREATE OR REPLACE FUNCTION cs_create_job(v_job_id integer) RETURNS void AS $$\nDECLARE\n    a_running_job_count integer;\nBEGIN\n    LOCK TABLE cs_jobs IN EXCLUSIVE MODE;\n\n    SELECT count(*) INTO a_running_job_count FROM cs_jobs WHERE end_stamp IS NULL;\n\n    IF a_running_job_count &gt; 0 THEN\n        RAISE EXCEPTION 'Unable to create a new job: a job is currently running';<co id=\"co.plpgsql-porting-raise\"></co>\n    END IF;\n\n    DELETE FROM cs_active_job;\n    INSERT INTO cs_active_job(job_id) VALUES (v_job_id);\n\n    BEGIN\n        INSERT INTO cs_jobs (job_id, start_stamp) VALUES (v_job_id, now());\n    EXCEPTION\n        WHEN unique_violation THEN <co id=\"co.plpgsql-porting-exception\"></co>\n            -- don't worry if it already exists\n    END;\nEND;\n$$ LANGUAGE plpgsql;\n"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:4858(para) 
msgid "The syntax of <literal>RAISE</literal> is considerably different from Oracle's statement, although the basic case <literal>RAISE</literal><replaceable class=\"parameter\">exception_name</replaceable> works similarly."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:4866(para) 
msgid "The exception names supported by <application>PL/pgSQL</application> are different from Oracle's. The set of built-in exception names is much larger (see <xref linkend=\"errcodes-appendix\"/>). There is not currently a way to declare user-defined exception names, although you can throw user-chosen SQLSTATE values instead."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:4827(para) 
msgid "This is how we could port this procedure to <application>PL/pgSQL</application>: <placeholder-1/><placeholder-2/> The main functional difference between this procedure and the Oracle equivalent is that the exclusive lock on the <literal>cs_jobs</literal> table will be held until the calling transaction completes. Also, if the caller later aborts (for example due to an error), the effects of this procedure will be rolled back."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:4886(title) 
msgid "Other Things to Watch For"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:4888(para) 
msgid "This section explains a few other things to watch for when porting Oracle <application>PL/SQL</application> functions to <productname>PostgreSQL</productname>."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:4895(title) 
msgid "Implicit Rollback after Exceptions"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:4903(programlisting) 
#, no-wrap
msgid "\nBEGIN\n    SAVEPOINT s1;\n    ... code here ...\nEXCEPTION\n    WHEN ... THEN\n        ROLLBACK TO s1;\n        ... code here ...\n    WHEN ... THEN\n        ROLLBACK TO s1;\n        ... code here ...\nEND;\n"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:4897(para) 
msgid "In <application>PL/pgSQL</application>, when an exception is caught by an <literal>EXCEPTION</literal> clause, all database changes since the block's <literal>BEGIN</literal> are automatically rolled back. That is, the behavior is equivalent to what you'd get in Oracle with: <placeholder-1/> If you are translating an Oracle procedure that uses <command>SAVEPOINT</command> and <command>ROLLBACK TO</command> in this style, your task is easy: just omit the <command>SAVEPOINT</command> and <command>ROLLBACK TO</command>. If you have a procedure that uses <command>SAVEPOINT</command> and <command>ROLLBACK TO</command> in a different way then some actual thought will be required."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:4927(command) 
msgid "EXECUTE"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:4929(para) 
msgid "The <application>PL/pgSQL</application> version of <command>EXECUTE</command> works similarly to the <application>PL/SQL</application> version, but you have to remember to use <function>quote_literal</function> and <function>quote_ident</function> as described in <xref linkend=\"plpgsql-statements-executing-dyn\"/>. Constructs of the type <literal>EXECUTE 'SELECT * FROM $1';</literal> will not work reliably unless you use these functions."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:4942(title) 
msgid "Optimizing <application>PL/pgSQL</application> Functions"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:4944(para) 
msgid "<productname>PostgreSQL</productname> gives you two function creation modifiers to optimize execution: <quote>volatility</quote> (whether the function always returns the same result when given the same arguments) and <quote>strictness</quote> (whether the function returns null if any argument is null). Consult the <xref linkend=\"sql-createfunction\"/> reference page for details."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:4959(programlisting) 
#, no-wrap
msgid "\nCREATE FUNCTION foo(...) RETURNS integer AS $$\n...\n$$ LANGUAGE plpgsql STRICT IMMUTABLE;\n"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:4954(para) 
msgid "When making use of these optimization attributes, your <command>CREATE FUNCTION</command> statement might look something like this: <placeholder-1/>"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:4969(title) 
msgid "Appendix"
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:4971(para) 
msgid "This section contains the code for a set of Oracle-compatible <function>instr</function> functions that you can use to simplify your porting efforts."
msgstr ""

#: /tmp/cicero-gTQe/plpgsql.xml:4977(programlisting) 
#, no-wrap
msgid "\n--\n-- instr functions that mimic Oracle's counterpart\n-- Syntax: instr(string1, string2, [n], [m]) where [] denotes optional parameters.\n--\n-- Searches string1 beginning at the nth character for the mth occurrence\n-- of string2.  If n is negative, search backwards.  If m is not passed,\n-- assume 1 (search starts at first character).\n--\n\nCREATE FUNCTION instr(varchar, varchar) RETURNS integer AS $$\nDECLARE\n    pos integer;\nBEGIN\n    pos:= instr($1, $2, 1);\n    RETURN pos;\nEND;\n$$ LANGUAGE plpgsql STRICT IMMUTABLE;\n\n\nCREATE FUNCTION instr(string varchar, string_to_search varchar, beg_index integer)\nRETURNS integer AS $$\nDECLARE\n    pos integer NOT NULL DEFAULT 0;\n    temp_str varchar;\n    beg integer;\n    length integer;\n    ss_length integer;\nBEGIN\n    IF beg_index &gt; 0 THEN\n        temp_str := substring(string FROM beg_index);\n        pos := position(string_to_search IN temp_str);\n\n        IF pos = 0 THEN\n            RETURN 0;\n        ELSE\n            RETURN pos + beg_index - 1;\n        END IF;\n    ELSE\n        ss_length := char_length(string_to_search);\n        length := char_length(string);\n        beg := length + beg_index - ss_length + 2;\n\n        WHILE beg &gt; 0 LOOP\n            temp_str := substring(string FROM beg FOR ss_length);\n            pos := position(string_to_search IN temp_str);\n\n            IF pos &gt; 0 THEN\n                RETURN beg;\n            END IF;\n\n            beg := beg - 1;\n        END LOOP;\n\n        RETURN 0;\n    END IF;\nEND;\n$$ LANGUAGE plpgsql STRICT IMMUTABLE;\n\n\nCREATE FUNCTION instr(string varchar, string_to_search varchar,\n                      beg_index integer, occur_index integer)\nRETURNS integer AS $$\nDECLARE\n    pos integer NOT NULL DEFAULT 0;\n    occur_number integer NOT NULL DEFAULT 0;\n    temp_str varchar;\n    beg integer;\n    i integer;\n    length integer;\n    ss_length integer;\nBEGIN\n    IF beg_index &gt; 0 THEN\n        beg := beg_index;\n        temp_str := substring(string FROM beg_index);\n\n        FOR i IN 1..occur_index LOOP\n            pos := position(string_to_search IN temp_str);\n\n            IF i = 1 THEN\n                beg := beg + pos - 1;\n            ELSE\n                beg := beg + pos;\n            END IF;\n\n            temp_str := substring(string FROM beg + 1);\n        END LOOP;\n\n        IF pos = 0 THEN\n            RETURN 0;\n        ELSE\n            RETURN beg;\n        END IF;\n    ELSE\n        ss_length := char_length(string_to_search);\n        length := char_length(string);\n        beg := length + beg_index - ss_length + 2;\n\n        WHILE beg &gt; 0 LOOP\n            temp_str := substring(string FROM beg FOR ss_length);\n            pos := position(string_to_search IN temp_str);\n\n            IF pos &gt; 0 THEN\n                occur_number := occur_number + 1;\n\n                IF occur_number = occur_index THEN\n                    RETURN beg;\n                END IF;\n            END IF;\n\n            beg := beg - 1;\n        END LOOP;\n\n        RETURN 0;\n    END IF;\nEND;\n$$ LANGUAGE plpgsql STRICT IMMUTABLE;\n"
msgstr ""

#. Put one translator per line, in the form of NAME <EMAIL>, YEAR1, YEAR2.
#: /tmp/cicero-gTQe/plpgsql.xml:0(None) 
msgid "translator-credits"
msgstr ""

