msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2011-09-05 06:57+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: /tmp/cicero-PnJu/rules.xml:5(title) 
msgid "The Rule System"
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:8(primary) /tmp/cicero-PnJu/rules.xml:273(primary) /tmp/cicero-PnJu/rules.xml:312(primary) /tmp/cicero-PnJu/rules.xml:872(primary) /tmp/cicero-PnJu/rules.xml:877(primary) /tmp/cicero-PnJu/rules.xml:882(primary) /tmp/cicero-PnJu/rules.xml:1935(primary) 
msgid "rule"
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:11(para) 
msgid "This chapter discusses the rule system in <productname>PostgreSQL</productname>. Production rule systems are conceptually simple, but there are many subtle points involved in actually using them."
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:18(para) 
msgid "Some other database systems define active database rules, which are usually stored procedures and triggers. In <productname>PostgreSQL</productname>, these can be implemented using functions and triggers as well."
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:25(para) 
msgid "The rule system (more precisely speaking, the query rewrite rule system) is totally different from stored procedures and triggers. It modifies queries to take rules into consideration, and then passes the modified query to the query planner for planning and execution. It is very powerful, and can be used for many things such as query language procedures, views, and versions. The theoretical foundations and the power of this rule system are also discussed in <xref linkend=\"ston90b\"/> and <xref linkend=\"ong90\"/>."
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:38(title) 
msgid "The Query Tree"
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:41(primary) 
msgid "query tree"
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:44(para) 
msgid "To understand how the rule system works it is necessary to know when it is invoked and what its input and results are."
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:49(para) 
msgid "The rule system is located between the parser and the planner. It takes the output of the parser, one query tree, and the user-defined rewrite rules, which are also query trees with some extra information, and creates zero or more query trees as result. So its input and output are always things the parser itself could have produced and thus, anything it sees is basically representable as an <acronym>SQL</acronym> statement."
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:59(para) 
msgid "Now what is a query tree? It is an internal representation of an <acronym>SQL</acronym> statement where the single parts that it is built from are stored separately. These query trees can be shown in the server log if you set the configuration parameters <varname>debug_print_parse</varname>, <varname>debug_print_rewritten</varname>, or <varname>debug_print_plan</varname>. The rule actions are also stored as query trees, in the system catalog <structname>pg_rewrite</structname>. They are not formatted like the log output, but they contain exactly the same information."
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:72(para) 
msgid "Reading a raw query tree requires some experience. But since <acronym>SQL</acronym> representations of query trees are sufficient to understand the rule system, this chapter will not teach how to read them."
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:87(term) 
msgid "the command type"
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:91(para) 
msgid "This is a simple value telling which command (<command>SELECT</command>, <command>INSERT</command>, <command>UPDATE</command>, <command>DELETE</command>) produced the query tree."
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:101(term) 
msgid "the range table"
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:104(primary) 
msgid "range table"
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:106(para) 
msgid "The range table is a list of relations that are used in the query. In a <command>SELECT</command> statement these are the relations given after the <literal>FROM</literal> key word."
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:112(para) 
msgid "Every range table entry identifies a table or view and tells by which name it is called in the other parts of the query. In the query tree, the range table entries are referenced by number rather than by name, so here it doesn't matter if there are duplicate names as it would in an <acronym>SQL</acronym> statement. This can happen after the range tables of rules have been merged in. The examples in this chapter will not have this situation."
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:126(term) 
msgid "the result relation"
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:130(para) 
msgid "This is an index into the range table that identifies the relation where the results of the query go."
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:135(para) 
msgid "<command>SELECT</command> queries don't have a result relation. (The special case of <command>SELECT INTO</command> is mostly identical to <command>CREATE TABLE</command> followed by <literal>INSERT ... SELECT</literal>, and is not discussed separately here.)"
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:143(para) 
msgid "For <command>INSERT</command>, <command>UPDATE</command>, and <command>DELETE</command> commands, the result relation is the table (or view!) where the changes are to take effect."
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:152(term) 
msgid "the target list"
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:155(primary) 
msgid "target list"
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:157(para) 
msgid "The target list is a list of expressions that define the result of the query. In the case of a <command>SELECT</command>, these expressions are the ones that build the final output of the query. They correspond to the expressions between the key words <command>SELECT</command> and <command>FROM</command>. (<literal>*</literal> is just an abbreviation for all the column names of a relation. It is expanded by the parser into the individual columns, so the rule system never sees it.)"
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:169(para) 
msgid "<command>DELETE</command> commands don't need a normal target list because they don't produce any result. Instead, the rule system adds a special <acronym>CTID</acronym> entry to the empty target list, to allow the executor to find the row to be deleted. (<acronym>CTID</acronym> is added when the result relation is an ordinary table. If it is a view, a whole-row variable is added instead, as described in <xref linkend=\"rules-views-update\"/>.)"
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:179(para) 
msgid "For <command>INSERT</command> commands, the target list describes the new rows that should go into the result relation. It consists of the expressions in the <literal>VALUES</literal> clause or the ones from the <command>SELECT</command> clause in <literal>INSERT ... SELECT</literal>. The first step of the rewrite process adds target list entries for any columns that were not assigned to by the original command but have defaults. Any remaining columns (with neither a given value nor a default) will be filled in by the planner with a constant null expression."
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:191(para) 
msgid "For <command>UPDATE</command> commands, the target list describes the new rows that should replace the old ones. In the rule system, it contains just the expressions from the <literal>SET column = expression</literal> part of the command. The planner will handle missing columns by inserting expressions that copy the values from the old row into the new one. Just as for <command>DELETE</command>, the rule system adds a <acronym>CTID</acronym> or whole-row variable so that the executor can identify the old row to be updated."
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:202(para) 
msgid "Every entry in the target list contains an expression that can be a constant value, a variable pointing to a column of one of the relations in the range table, a parameter, or an expression tree made of function calls, constants, variables, operators, etc."
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:212(term) 
msgid "the qualification"
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:216(para) 
msgid "The query's qualification is an expression much like one of those contained in the target list entries. The result value of this expression is a Boolean that tells whether the operation (<command>INSERT</command>, <command>UPDATE</command>, <command>DELETE</command>, or <command>SELECT</command>) for the final result row should be executed or not. It corresponds to the <literal>WHERE</literal> clause of an <acronym>SQL</acronym> statement."
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:229(term) 
msgid "the join tree"
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:233(para) 
msgid "The query's join tree shows the structure of the <literal>FROM</literal> clause. For a simple query like <literal>SELECT ... FROM a, b, c</literal>, the join tree is just a list of the <literal>FROM</literal> items, because we are allowed to join them in any order. But when <literal>JOIN</literal> expressions, particularly outer joins, are used, we have to join in the order shown by the joins. In that case, the join tree shows the structure of the <literal>JOIN</literal> expressions. The restrictions associated with particular <literal>JOIN</literal> clauses (from <literal>ON</literal> or <literal>USING</literal> expressions) are stored as qualification expressions attached to those join-tree nodes. It turns out to be convenient to store the top-level <literal>WHERE</literal> expression as a qualification attached to the top-level join-tree item, too. So really the join tree represents both the <literal>FROM</literal> and <literal>WHERE</literal> clauses of a <command>SELECT</command>."
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:251(term) 
msgid "the others"
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:255(para) 
msgid "The other parts of the query tree like the <literal>ORDER BY</literal> clause aren't of interest here. The rule system substitutes some entries there while applying rules, but that doesn't have much to do with the fundamentals of the rule system."
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:79(para) 
msgid "When reading the <acronym>SQL</acronym> representations of the query trees in this chapter it is necessary to be able to identify the parts the statement is broken into when it is in the query tree structure. The parts of a query tree are <placeholder-1/>"
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:270(title) 
msgid "Views and the Rule System"
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:274(secondary) 
msgid "and views"
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:278(primary) /tmp/cicero-PnJu/rules.xml:1303(primary) 
msgid "view"
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:279(secondary) 
msgid "implementation through rules"
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:287(programlisting) 
#, no-wrap
msgid "\nCREATE VIEW myview AS SELECT * FROM mytab;\n"
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:293(programlisting) 
#, no-wrap
msgid "\nCREATE TABLE myview (<replaceable>same column list as mytab</replaceable>);\nCREATE RULE \"_RETURN\" AS ON SELECT TO myview DO INSTEAD\n    SELECT * FROM mytab;\n"
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:282(para) 
msgid "Views in <productname>PostgreSQL</productname> are implemented using the rule system. In fact, there is essentially no difference between: <placeholder-1/> compared against the two commands: <placeholder-2/> because this is exactly what the <command>CREATE VIEW</command> command does internally. This has some side effects. One of them is that the information about a view in the <productname>PostgreSQL</productname> system catalogs is exactly the same as it is for a table. So for the parser, there is absolutely no difference between a table and a view. They are the same thing: relations."
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:309(title) 
msgid "How <command>SELECT</command> Rules Work"
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:313(secondary) 
msgid "for SELECT"
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:316(para) 
msgid "Rules <literal>ON SELECT</literal> are applied to all queries as the last step, even if the command given is an <command>INSERT</command>, <command>UPDATE</command> or <command>DELETE</command>. And they have different semantics from rules on the other command types in that they modify the query tree in place instead of creating a new one. So <command>SELECT</command> rules are described first."
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:325(para) 
msgid "Currently, there can be only one action in an <literal>ON SELECT</literal> rule, and it must be an unconditional <command>SELECT</command> action that is <literal>INSTEAD</literal>. This restriction was required to make rules safe enough to open them for ordinary users, and it restricts <literal>ON SELECT</literal> rules to act like views."
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:332(para) 
msgid "The examples for this chapter are two join views that do some calculations and some more views using them in turn. One of the two first views is customized later by adding rules for <command>INSERT</command>, <command>UPDATE</command>, and <command>DELETE</command> operations so that the final result will be a view that behaves like a real table with some magic functionality. This is not such a simple example to start from and this makes things harder to get into. But it's better to have one example that covers all the points discussed step by step rather than having many different ones that might mix up in mind."
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:349(programlisting) 
#, no-wrap
msgid "\nCREATE FUNCTION min(integer, integer) RETURNS integer AS $$\n    SELECT CASE WHEN $1 &lt; $2 THEN $1 ELSE $2 END\n$$ LANGUAGE SQL STRICT;\n"
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:345(para) 
msgid "For the example, we need a little <literal>min</literal> function that returns the lower of 2 integer values. We create that as: <placeholder-1/>"
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:360(programlisting) 
#, no-wrap
msgid "\nCREATE TABLE shoe_data (\n    shoename   text,          -- primary key\n    sh_avail   integer,       -- available number of pairs\n    slcolor    text,          -- preferred shoelace color\n    slminlen   real,          -- minimum shoelace length\n    slmaxlen   real,          -- maximum shoelace length\n    slunit     text           -- length unit\n);\n\nCREATE TABLE shoelace_data (\n    sl_name    text,          -- primary key\n    sl_avail   integer,       -- available number of pairs\n    sl_color   text,          -- shoelace color\n    sl_len     real,          -- shoelace length\n    sl_unit    text           -- length unit\n);\n\nCREATE TABLE unit (\n    un_name    text,          -- primary key\n    un_fact    real           -- factor to transform to cm\n);\n"
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:356(para) 
msgid "The real tables we need in the first two rule system descriptions are these: <placeholder-1/> As you can see, they represent shoe-store data."
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:390(programlisting) 
#, no-wrap
msgid "\nCREATE VIEW shoe AS\n    SELECT sh.shoename,\n           sh.sh_avail,\n           sh.slcolor,\n           sh.slminlen,\n           sh.slminlen * un.un_fact AS slminlen_cm,\n           sh.slmaxlen,\n           sh.slmaxlen * un.un_fact AS slmaxlen_cm,\n           sh.slunit\n      FROM shoe_data sh, unit un\n     WHERE sh.slunit = un.un_name;\n\nCREATE VIEW shoelace AS\n    SELECT s.sl_name,\n           s.sl_avail,\n           s.sl_color,\n           s.sl_len,\n           s.sl_unit,\n           s.sl_len * u.un_fact AS sl_len_cm\n      FROM shoelace_data s, unit u\n     WHERE s.sl_unit = u.un_name;\n\nCREATE VIEW shoe_ready AS\n    SELECT rsh.shoename,\n           rsh.sh_avail,\n           rsl.sl_name,\n           rsl.sl_avail,\n           min(rsh.sh_avail, rsl.sl_avail) AS total_avail\n      FROM shoe rsh, shoelace rsl\n     WHERE rsl.sl_color = rsh.slcolor\n       AND rsl.sl_len_cm &gt;= rsh.slminlen_cm\n       AND rsl.sl_len_cm &lt;= rsh.slmaxlen_cm;\n"
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:387(para) 
msgid "The views are created as: <placeholder-1/> The <command>CREATE VIEW</command> command for the <literal>shoelace</literal> view (which is the simplest one we have) will create a relation <literal>shoelace</literal> and an entry in <structname>pg_rewrite</structname> that tells that there is a rewrite rule that must be applied whenever the relation <literal>shoelace</literal> is referenced in a query's range table. The rule has no rule qualification (discussed later, with the non-<command>SELECT</command> rules, since <command>SELECT</command> rules currently cannot have them) and it is <literal>INSTEAD</literal>. Note that rule qualifications are not the same as query qualifications. The action of our rule has a query qualification. The action of the rule is one query tree that is a copy of the <command>SELECT</command> statement in the view creation command."
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:440(para) 
msgid "The two extra range table entries for <literal>NEW</literal> and <literal>OLD</literal> that you can see in the <structname>pg_rewrite</structname> entry aren't of interest for <command>SELECT</command> rules."
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:452(programlisting) 
#, no-wrap
msgid "\nINSERT INTO unit VALUES ('cm', 1.0);\nINSERT INTO unit VALUES ('m', 100.0);\nINSERT INTO unit VALUES ('inch', 2.54);\n\nINSERT INTO shoe_data VALUES ('sh1', 2, 'black', 70.0, 90.0, 'cm');\nINSERT INTO shoe_data VALUES ('sh2', 0, 'black', 30.0, 40.0, 'inch');\nINSERT INTO shoe_data VALUES ('sh3', 4, 'brown', 50.0, 65.0, 'cm');\nINSERT INTO shoe_data VALUES ('sh4', 3, 'brown', 40.0, 50.0, 'inch');\n\nINSERT INTO shoelace_data VALUES ('sl1', 5, 'black', 80.0, 'cm');\nINSERT INTO shoelace_data VALUES ('sl2', 6, 'black', 100.0, 'cm');\nINSERT INTO shoelace_data VALUES ('sl3', 0, 'black', 35.0 , 'inch');\nINSERT INTO shoelace_data VALUES ('sl4', 8, 'black', 40.0 , 'inch');\nINSERT INTO shoelace_data VALUES ('sl5', 4, 'brown', 1.0 , 'm');\nINSERT INTO shoelace_data VALUES ('sl6', 0, 'brown', 0.9 , 'm');\nINSERT INTO shoelace_data VALUES ('sl7', 7, 'brown', 60 , 'cm');\nINSERT INTO shoelace_data VALUES ('sl8', 1, 'brown', 40 , 'inch');\n\nSELECT * FROM shoelace;\n\n sl_name   | sl_avail | sl_color | sl_len | sl_unit | sl_len_cm\n-----------+----------+----------+--------+---------+-----------\n sl1       |        5 | black    |     80 | cm      |        80\n sl2       |        6 | black    |    100 | cm      |       100\n sl7       |        7 | brown    |     60 | cm      |        60\n sl3       |        0 | black    |     35 | inch    |      88.9\n sl4       |        8 | black    |     40 | inch    |     101.6\n sl8       |        1 | brown    |     40 | inch    |     101.6\n sl5       |        4 | brown    |      1 | m       |       100\n sl6       |        0 | brown    |    0.9 | m       |        90\n(8 rows)\n"
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:448(para) 
msgid "Now we populate <literal>unit</literal>, <literal>shoe_data</literal> and <literal>shoelace_data</literal> and run a simple query on a view: <placeholder-1/>"
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:493(programlisting) 
#, no-wrap
msgid "\nSELECT shoelace.sl_name, shoelace.sl_avail,\n       shoelace.sl_color, shoelace.sl_len,\n       shoelace.sl_unit, shoelace.sl_len_cm\n  FROM shoelace shoelace;\n"
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:506(programlisting) 
#, no-wrap
msgid "\nSELECT s.sl_name, s.sl_avail,\n       s.sl_color, s.sl_len, s.sl_unit,\n       s.sl_len * u.un_fact AS sl_len_cm\n  FROM shoelace old, shoelace new,\n       shoelace_data s, unit u\n WHERE s.sl_unit = u.un_name;\n"
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:487(para) 
msgid "This is the simplest <command>SELECT</command> you can do on our views, so we take this opportunity to explain the basics of view rules. The <literal>SELECT * FROM shoelace</literal> was interpreted by the parser and produced the query tree: <placeholder-1/> and this is given to the rule system. The rule system walks through the range table and checks if there are rules for any relation. When processing the range table entry for <literal>shoelace</literal> (the only one up to now) it finds the <literal>_RETURN</literal> rule with the query tree: <placeholder-2/>"
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:522(programlisting) 
#, no-wrap
msgid "\nSELECT shoelace.sl_name, shoelace.sl_avail,\n       shoelace.sl_color, shoelace.sl_len,\n       shoelace.sl_unit, shoelace.sl_len_cm\n  FROM (SELECT s.sl_name,\n               s.sl_avail,\n               s.sl_color,\n               s.sl_len,\n               s.sl_unit,\n               s.sl_len * u.un_fact AS sl_len_cm\n          FROM shoelace_data s, unit u\n         WHERE s.sl_unit = u.un_name) shoelace;\n"
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:516(para) 
msgid "To expand the view, the rewriter simply creates a subquery range-table entry containing the rule's action query tree, and substitutes this range table entry for the original one that referenced the view. The resulting rewritten query tree is almost the same as if you had typed: <placeholder-1/> There is one difference however: the subquery's range table has two extra entries <literal>shoelace old</literal> and <literal>shoelace new</literal>. These entries don't participate directly in the query, since they aren't referenced by the subquery's join tree or target list. The rewriter uses them to store the access privilege check information that was originally present in the range-table entry that referenced the view. In this way, the executor will still check that the user has proper privileges to access the view, even though there's no direct use of the view in the rewritten query."
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:547(para) 
msgid "That was the first rule applied. The rule system will continue checking the remaining range-table entries in the top query (in this example there are no more), and it will recursively check the range-table entries in the added subquery to see if any of them reference views. (But it won't expand <literal>old</literal> or <literal>new</literal> â€” otherwise we'd have infinite recursion!) In this example, there are no rewrite rules for <literal>shoelace_data</literal> or <literal>unit</literal>, so rewriting is complete and the above is the final result given to the planner."
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:563(programlisting) 
#, no-wrap
msgid "\nSELECT * FROM shoe_ready WHERE total_avail &gt;= 2;\n\n shoename | sh_avail | sl_name | sl_avail | total_avail\n----------+----------+---------+----------+-------------\n sh1      |        2 | sl1     |        5 |           2\n sh3      |        4 | sl7     |        7 |           4\n(2 rows)\n"
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:558(para) 
msgid "Now we want to write a query that finds out for which shoes currently in the store we have the matching shoelaces (color and length) and where the total number of exactly matching pairs is greater or equal to two. <placeholder-1/>"
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:577(programlisting) 
#, no-wrap
msgid "\nSELECT shoe_ready.shoename, shoe_ready.sh_avail,\n       shoe_ready.sl_name, shoe_ready.sl_avail,\n       shoe_ready.total_avail\n  FROM shoe_ready shoe_ready\n WHERE shoe_ready.total_avail &gt;= 2;\n"
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:589(programlisting) 
#, no-wrap
msgid "\nSELECT shoe_ready.shoename, shoe_ready.sh_avail,\n       shoe_ready.sl_name, shoe_ready.sl_avail,\n       shoe_ready.total_avail\n  FROM (SELECT rsh.shoename,\n               rsh.sh_avail,\n               rsl.sl_name,\n               rsl.sl_avail,\n               min(rsh.sh_avail, rsl.sl_avail) AS total_avail\n          FROM shoe rsh, shoelace rsl\n         WHERE rsl.sl_color = rsh.slcolor\n           AND rsl.sl_len_cm &gt;= rsh.slminlen_cm\n           AND rsl.sl_len_cm &lt;= rsh.slmaxlen_cm) shoe_ready\n WHERE shoe_ready.total_avail &gt;= 2;\n"
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:609(programlisting) 
#, no-wrap
msgid "\nSELECT shoe_ready.shoename, shoe_ready.sh_avail,\n       shoe_ready.sl_name, shoe_ready.sl_avail,\n       shoe_ready.total_avail\n  FROM (SELECT rsh.shoename,\n               rsh.sh_avail,\n               rsl.sl_name,\n               rsl.sl_avail,\n               min(rsh.sh_avail, rsl.sl_avail) AS total_avail\n          FROM (SELECT sh.shoename,\n                       sh.sh_avail,\n                       sh.slcolor,\n                       sh.slminlen,\n                       sh.slminlen * un.un_fact AS slminlen_cm,\n                       sh.slmaxlen,\n                       sh.slmaxlen * un.un_fact AS slmaxlen_cm,\n                       sh.slunit\n                  FROM shoe_data sh, unit un\n                 WHERE sh.slunit = un.un_name) rsh,\n               (SELECT s.sl_name,\n                       s.sl_avail,\n                       s.sl_color,\n                       s.sl_len,\n                       s.sl_unit,\n                       s.sl_len * u.un_fact AS sl_len_cm\n                  FROM shoelace_data s, unit u\n                 WHERE s.sl_unit = u.un_name) rsl\n         WHERE rsl.sl_color = rsh.slcolor\n           AND rsl.sl_len_cm &gt;= rsh.slminlen_cm\n           AND rsl.sl_len_cm &lt;= rsh.slmaxlen_cm) shoe_ready\n WHERE shoe_ready.total_avail &gt; 2;\n"
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:574(para) 
msgid "The output of the parser this time is the query tree: <placeholder-1/> The first rule applied will be the one for the <literal>shoe_ready</literal> view and it results in the query tree: <placeholder-2/> Similarly, the rules for <literal>shoe</literal> and <literal>shoelace</literal> are substituted into the range table of the subquery, leading to a three-level final query tree: <placeholder-3/>"
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:643(para) 
msgid "It turns out that the planner will collapse this tree into a two-level query tree: the bottommost <command>SELECT</command> commands will be <quote>pulled up</quote> into the middle <command>SELECT</command> since there's no need to process them separately. But the middle <command>SELECT</command> will remain separate from the top, because it contains aggregate functions. If we pulled those up it would change the behavior of the topmost <command>SELECT</command>, which we don't want. However, collapsing the query tree is an optimization that the rewrite system doesn't have to concern itself with."
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:658(title) 
msgid "View Rules in Non-<command>SELECT</command> Statements"
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:660(para) 
msgid "Two details of the query tree aren't touched in the description of view rules above. These are the command type and the result relation. In fact, the command type is not needed by view rules, but the result relation may affect the way in which the query rewriter works, because special care needs to be taken if the result relation is a view."
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:678(programlisting) 
#, no-wrap
msgid "\nSELECT t2.b FROM t1, t2 WHERE t1.a = t2.a;\n\nUPDATE t1 SET b = t2.b FROM t2 WHERE t1.a = t2.a;\n"
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:688(para) 
msgid "The range tables contain entries for the tables <literal>t1</literal> and <literal>t2</literal>."
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:694(para) 
msgid "The target lists contain one variable that points to column <literal>b</literal> of the range table entry for table <literal>t2</literal>."
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:701(para) 
msgid "The qualification expressions compare the columns <literal>a</literal> of both range-table entries for equality."
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:708(para) 
msgid "The join trees show a simple join between <literal>t1</literal> and <literal>t2</literal>."
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:668(para) 
msgid "There are only a few differences between a query tree for a <command>SELECT</command> and one for any other command. Obviously, they have a different command type and for a command other than a <command>SELECT</command>, the result relation points to the range-table entry where the result should go. Everything else is absolutely the same. So having two tables <literal>t1</literal> and <literal>t2</literal> with columns <literal>a</literal> and <literal>b</literal>, the query trees for the two statements: <placeholder-1/> are nearly identical. In particular: <placeholder-2/>"
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:722(programlisting) 
#, no-wrap
msgid "\nUPDATE t1 SET a = t1.a, b = t2.b FROM t2 WHERE t1.a = t2.a;\n"
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:729(programlisting) 
#, no-wrap
msgid "\nSELECT t1.a, t2.b FROM t1, t2 WHERE t1.a = t2.a;\n"
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:715(para) 
msgid "The consequence is, that both query trees result in similar execution plans: They are both joins over the two tables. For the <command>UPDATE</command> the missing columns from <literal>t1</literal> are added to the target list by the planner and the final query tree will read as: <placeholder-1/> and thus the executor run over the join will produce exactly the same result set as: <placeholder-2/> But there is a little problem in <command>UPDATE</command>: the part of the executor plan that does the join does not care what the results from the join are meant for. It just produces a result set of rows. The fact that one is a <command>SELECT</command> command and the other is an <command>UPDATE</command> is handled higher up in the executor, where it knows that this is an <command>UPDATE</command>, and it knows that this result should go into table <literal>t1</literal>. But which of the rows that are there has to be replaced by the new row?"
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:755(programlisting) 
#, no-wrap
msgid "\nSELECT t1.a, t2.b, t1.ctid FROM t1, t2 WHERE t1.a = t2.a;\n"
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:744(para) 
msgid "To resolve this problem, another entry is added to the target list in <command>UPDATE</command> (and also in <command>DELETE</command>) statements: the current tuple ID (<acronym>CTID</acronym>).<indexterm><primary>CTID</primary></indexterm> This is a system column containing the file block number and position in the block for the row. Knowing the table, the <acronym>CTID</acronym> can be used to retrieve the original row of <literal>t1</literal> to be updated. After adding the <acronym>CTID</acronym> to the target list, the query actually looks like: <placeholder-1/> Now another detail of <productname>PostgreSQL</productname> enters the stage. Old table rows aren't overwritten, and this is why <command>ROLLBACK</command> is fast. In an <command>UPDATE</command>, the new result row is inserted into the table (after stripping the <acronym>CTID</acronym>) and in the row header of the old row, which the <acronym>CTID</acronym> pointed to, the <literal>cmax</literal> and <literal>xmax</literal> entries are set to the current command counter and current transaction ID. Thus the old row is hidden, and after the transaction commits the vacuum cleaner can eventually remove the dead row."
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:771(para) 
msgid "Knowing all that, we can simply apply view rules in absolutely the same way to any command. There is no difference."
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:778(title) 
msgid "The Power of Views in <productname>PostgreSQL</productname>"
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:780(para) 
msgid "The above demonstrates how the rule system incorporates view definitions into the original query tree. In the second example, a simple <command>SELECT</command> from one view created a final query tree that is a join of 4 tables (<literal>unit</literal> was used twice with different names)."
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:788(para) 
msgid "The benefit of implementing views with the rule system is, that the planner has all the information about which tables have to be scanned plus the relationships between these tables plus the restrictive qualifications from the views plus the qualifications from the original query in one single query tree. And this is still the situation when the original query is already a join over views. The planner has to decide which is the best path to execute the query, and the more information the planner has, the better this decision can be. And the rule system as implemented in <productname>PostgreSQL</productname> ensures, that this is all information available about the query up to that point."
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:807(title) 
msgid "Updating a View"
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:809(para) 
msgid "What happens if a view is named as the target relation for an <command>INSERT</command>, <command>UPDATE</command>, or <command>DELETE</command>? Simply doing the substitutions described above would give a query tree in which the result relation points at a subquery range-table entry, which will not work. Instead, the rewriter assumes that the operation will be handled by an <literal>INSTEAD OF</literal> trigger on the view. (If there is no such trigger, the executor will throw an error when execution starts.) Rewriting works slightly differently in this case. For <command>INSERT</command>, the rewriter does nothing at all with the view, leaving it as the result relation for the query. For <command>UPDATE</command> and <command>DELETE</command>, it's still necessary to expand the view query to produce the <quote>old</quote> rows that the command will attempt to update or delete. So the view is expanded as normal, but another unexpanded range-table entry is added to the query to represent the view in its capacity as the result relation."
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:829(para) 
msgid "The problem that now arises is how to identify the rows to be updated in the view. Recall that when the result relation is a table, a special <acronym>CTID</acronym> entry is added to the target list to identify the physical locations of the rows to be updated. This does not work if the result relation is a view, because a view does not have any <acronym>CTID</acronym>, since its rows do not have actual physical locations. Instead, for an <command>UPDATE</command> or <command>DELETE</command> operation, a special <literal>wholerow</literal> entry is added to the target list, which expands to include all columns from the view. The executor uses this value to supply the <quote>old</quote> row to the <literal>INSTEAD OF</literal> trigger. It is up to the trigger to work out what to update based on the old and new row values."
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:845(para) 
msgid "If there are no <literal>INSTEAD OF</literal> triggers to update the view, the executor will throw an error, because it cannot automatically update a view by itself. To change this, we can define rules that modify the behavior of <command>INSERT</command>, <command>UPDATE</command>, and <command>DELETE</command> commands on a view. These rules will rewrite the command, typically into a command that updates one or more tables, rather than views. That is the topic of the next section."
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:856(para) 
msgid "Note that rules are evaluated first, rewriting the original query before it is planned and executed. Therefore, if a view has <literal>INSTEAD OF</literal> triggers as well as rules on <command>INSERT</command>, <command>UPDATE</command>, or <command>DELETE</command>, then the rules will be evaluated first, and depending on the result, the triggers may not be used at all."
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:869(title) 
msgid "Rules on <command>INSERT</command>, <command>UPDATE</command>, and <command>DELETE</command>"
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:873(secondary) 
msgid "for INSERT"
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:878(secondary) 
msgid "for UPDATE"
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:883(secondary) 
msgid "for DELETE"
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:894(para) 
msgid "They are allowed to have no action."
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:900(para) 
msgid "They can have multiple actions."
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:906(para) 
msgid "They can be <literal>INSTEAD</literal> or <literal>ALSO</literal> (the default)."
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:912(para) 
msgid "The pseudorelations <literal>NEW</literal> and <literal>OLD</literal> become useful."
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:918(para) 
msgid "They can have rule qualifications."
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:886(para) 
msgid "Rules that are defined on <command>INSERT</command>, <command>UPDATE</command>, and <command>DELETE</command> are significantly different from the view rules described in the previous section. First, their <command>CREATE RULE</command> command allows more: <placeholder-1/> Second, they don't modify the query tree in place. Instead they create zero or more new query trees and can throw away the original one."
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:930(title) 
msgid "How Update Rules Work"
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:935(programlisting) 
#, no-wrap
msgid "\nCREATE [ OR REPLACE ] RULE <replaceable class=\"parameter\">name</replaceable> AS ON <replaceable class=\"parameter\">event</replaceable>\n    TO <replaceable class=\"parameter\">table</replaceable> [ WHERE <replaceable class=\"parameter\">condition</replaceable> ]\n    DO [ ALSO | INSTEAD ] { NOTHING | <replaceable class=\"parameter\">command</replaceable> | ( <replaceable class=\"parameter\">command</replaceable> ; <replaceable class=\"parameter\">command</replaceable> ... ) }\n"
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:932(para) 
msgid "Keep the syntax: <placeholder-1/> in mind. In the following, <firstterm>update rules</firstterm> means rules that are defined on <command>INSERT</command>, <command>UPDATE</command>, or <command>DELETE</command>."
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:946(para) 
msgid "Update rules get applied by the rule system when the result relation and the command type of a query tree are equal to the object and event given in the <command>CREATE RULE</command> command. For update rules, the rule system creates a list of query trees. Initially the query-tree list is empty. There can be zero (<literal>NOTHING</literal> key word), one, or multiple actions. To simplify, we will look at a rule with one action. This rule can have a qualification or not and it can be <literal>INSTEAD</literal> or <literal>ALSO</literal> (the default)."
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:958(para) 
msgid "What is a rule qualification? It is a restriction that tells when the actions of the rule should be done and when not. This qualification can only reference the pseudorelations <literal>NEW</literal> and/or <literal>OLD</literal>, which basically represent the relation that was given as object (but with a special meaning)."
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:972(term) 
msgid "No qualification, with either <literal>ALSO</literal> or <literal>INSTEAD</literal>"
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:975(para) 
msgid "the query tree from the rule action with the original query tree's qualification added"
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:983(term) 
msgid "Qualification given and <literal>ALSO</literal>"
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:985(para) 
msgid "the query tree from the rule action with the rule qualification and the original query tree's qualification added"
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:994(term) 
msgid "Qualification given and <literal>INSTEAD</literal>"
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:996(para) 
msgid "the query tree from the rule action with the rule qualification and the original query tree's qualification; and the original query tree with the negated rule qualification added"
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:966(para) 
msgid "So we have three cases that produce the following query trees for a one-action rule. <placeholder-1/> Finally, if the rule is <literal>ALSO</literal>, the unchanged original query tree is added to the list. Since only qualified <literal>INSTEAD</literal> rules already add the original query tree, we end up with either one or two output query trees for a rule with one action."
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:1012(para) 
msgid "For <literal>ON INSERT</literal> rules, the original query (if not suppressed by <literal>INSTEAD</literal>) is done before any actions added by rules. This allows the actions to see the inserted row(s). But for <literal>ON UPDATE</literal> and <literal>ON DELETE</literal> rules, the original query is done after the actions added by rules. This ensures that the actions can see the to-be-updated or to-be-deleted rows; otherwise, the actions might do nothing because they find no rows matching their qualifications."
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:1022(para) 
msgid "The query trees generated from rule actions are thrown into the rewrite system again, and maybe more rules get applied resulting in more or less query trees. So a rule's actions must have either a different command type or a different result relation than the rule itself is on, otherwise this recursive process will end up in an infinite loop. (Recursive expansion of a rule will be detected and reported as an error.)"
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:1033(para) 
msgid "The query trees found in the actions of the <structname>pg_rewrite</structname> system catalog are only templates. Since they can reference the range-table entries for <literal>NEW</literal> and <literal>OLD</literal>, some substitutions have to be made before they can be used. For any reference to <literal>NEW</literal>, the target list of the original query is searched for a corresponding entry. If found, that entry's expression replaces the reference. Otherwise, <literal>NEW</literal> means the same as <literal>OLD</literal> (for an <command>UPDATE</command>) or is replaced by a null value (for an <command>INSERT</command>). Any reference to <literal>OLD</literal> is replaced by a reference to the range-table entry that is the result relation."
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:1047(para) 
msgid "After the system is done applying update rules, it applies view rules to the produced query tree(s). Views cannot insert new update actions so there is no need to apply update rules to the output of view rewriting."
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:1054(title) 
msgid "A First Rule Step by Step"
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:1063(programlisting) 
#, no-wrap
msgid "\nCREATE TABLE shoelace_log (\n    sl_name    text,          -- shoelace changed\n    sl_avail   integer,       -- new available value\n    log_who    text,          -- who did it\n    log_when   timestamp      -- when\n);\n\nCREATE RULE log_shoelace AS ON UPDATE TO shoelace_data\n    WHERE NEW.sl_avail &lt;&gt; OLD.sl_avail\n    DO INSERT INTO shoelace_log VALUES (\n                                    NEW.sl_name,\n                                    NEW.sl_avail,\n                                    current_user,\n                                    current_timestamp\n                                );\n"
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:1056(para) 
msgid "Say we want to trace changes to the <literal>sl_avail</literal> column in the <literal>shoelace_data</literal> relation. So we set up a log table and a rule that conditionally writes a log entry when an <command>UPDATE</command> is performed on <literal>shoelace_data</literal>. <placeholder-1/>"
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:1085(programlisting) 
#, no-wrap
msgid "\nUPDATE shoelace_data SET sl_avail = 6 WHERE sl_name = 'sl7';\n"
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:1091(programlisting) 
#, no-wrap
msgid "\nSELECT * FROM shoelace_log;\n\n sl_name | sl_avail | log_who | log_when                        \n---------+----------+---------+----------------------------------\n sl7     |        6 | Al      | Tue Oct 20 16:14:45 1998 MET DST\n(1 row)\n"
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:1082(para) 
msgid "Now someone does: <placeholder-1/> and we look at the log table: <placeholder-2/>"
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:1105(programlisting) 
#, no-wrap
msgid "\nUPDATE shoelace_data SET sl_avail = 6\n  FROM shoelace_data shoelace_data\n WHERE shoelace_data.sl_name = 'sl7';\n"
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:1114(programlisting) 
#, no-wrap
msgid "\nNEW.sl_avail &lt;&gt; OLD.sl_avail\n"
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:1120(programlisting) 
#, no-wrap
msgid "\nINSERT INTO shoelace_log VALUES (\n       new.sl_name, new.sl_avail,\n       current_user, current_timestamp )\n  FROM shoelace_data new, shoelace_data old;\n"
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:1101(para) 
msgid "That's what we expected. What happened in the background is the following. The parser created the query tree: <placeholder-1/> There is a rule <literal>log_shoelace</literal> that is <literal>ON UPDATE</literal> with the rule qualification expression: <placeholder-2/> and the action: <placeholder-3/> (This looks a little strange since you cannot normally write <literal>INSERT ... VALUES ... FROM</literal>. The <literal>FROM</literal> clause here is just to indicate that there are range-table entries in the query tree for <literal>new</literal> and <literal>old</literal>. These are needed so that they can be referenced by variables in the <command>INSERT</command> command's query tree.)"
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:1141(programlisting) 
#, no-wrap
msgid "\nINSERT INTO shoelace_log VALUES (\n       new.sl_name, new.sl_avail,\n       current_user, current_timestamp )\n  FROM shoelace_data new, shoelace_data old,\n       <emphasis>shoelace_data shoelace_data</emphasis>;\n"
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:1152(programlisting) 
#, no-wrap
msgid "\nINSERT INTO shoelace_log VALUES (\n       new.sl_name, new.sl_avail,\n       current_user, current_timestamp )\n  FROM shoelace_data new, shoelace_data old,\n       shoelace_data shoelace_data\n <emphasis>WHERE new.sl_avail &lt;&gt; old.sl_avail</emphasis>;\n"
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:1135(para) 
msgid "The rule is a qualified <literal>ALSO</literal> rule, so the rule system has to return two query trees: the modified rule action and the original query tree. In step 1, the range table of the original query is incorporated into the rule's action query tree. This results in: <placeholder-1/> In step 2, the rule qualification is added to it, so the result set is restricted to rows where <literal>sl_avail</literal> changes: <placeholder-2/> (This looks even stranger, since <literal>INSERT ... VALUES</literal> doesn't have a <literal>WHERE</literal> clause either, but the planner and executor will have no difficulty with it. They need to support this same functionality anyway for <literal>INSERT ... SELECT</literal>.)"
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:1172(programlisting) 
#, no-wrap
msgid "\nINSERT INTO shoelace_log VALUES (\n       new.sl_name, new.sl_avail,\n       current_user, current_timestamp )\n  FROM shoelace_data new, shoelace_data old,\n       shoelace_data shoelace_data\n WHERE new.sl_avail &lt;&gt; old.sl_avail\n   <emphasis>AND shoelace_data.sl_name = 'sl7'</emphasis>;\n"
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:1167(para) 
msgid "In step 3, the original query tree's qualification is added, restricting the result set further to only the rows that would have been touched by the original query: <placeholder-1/>"
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:1188(programlisting) 
#, no-wrap
msgid "\nINSERT INTO shoelace_log VALUES (\n       <emphasis>shoelace_data.sl_name</emphasis>, <emphasis>6</emphasis>,\n       current_user, current_timestamp )\n  FROM shoelace_data new, shoelace_data old,\n       shoelace_data shoelace_data\n WHERE <emphasis>6</emphasis> &lt;&gt; old.sl_avail\n   AND shoelace_data.sl_name = 'sl7';\n"
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:1183(para) 
msgid "Step 4 replaces references to <literal>NEW</literal> by the target list entries from the original query tree or by the matching variable references from the result relation: <placeholder-1/>"
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:1203(programlisting) 
#, no-wrap
msgid "\nINSERT INTO shoelace_log VALUES (\n       shoelace_data.sl_name, 6,\n       current_user, current_timestamp )\n  FROM shoelace_data new, shoelace_data old,\n       shoelace_data shoelace_data\n WHERE 6 &lt;&gt; <emphasis>shoelace_data.sl_avail</emphasis>\n   AND shoelace_data.sl_name = 'sl7';\n"
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:1200(para) 
msgid "Step 5 changes <literal>OLD</literal> references into result relation references: <placeholder-1/>"
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:1219(programlisting) 
#, no-wrap
msgid "\nINSERT INTO shoelace_log VALUES (\n       shoelace_data.sl_name, 6,\n       current_user, current_timestamp )\n  FROM shoelace_data\n WHERE 6 &lt;&gt; shoelace_data.sl_avail\n   AND shoelace_data.sl_name = 'sl7';\n\nUPDATE shoelace_data SET sl_avail = 6\n WHERE sl_name = 'sl7';\n"
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:1214(para) 
msgid "That's it. Since the rule is <literal>ALSO</literal>, we also output the original query tree. In short, the output from the rule system is a list of two query trees that correspond to these statements: <placeholder-1/> These are executed in this order, and that is exactly what the rule was meant to do."
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:1239(programlisting) 
#, no-wrap
msgid "\nUPDATE shoelace_data SET sl_color = 'green'\n WHERE sl_name = 'sl7';\n"
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:1250(programlisting) 
#, no-wrap
msgid "\nINSERT INTO shoelace_log VALUES (\n       shoelace_data.sl_name, <emphasis>shoelace_data.sl_avail</emphasis>,\n       current_user, current_timestamp )\n  FROM shoelace_data\n WHERE <emphasis>shoelace_data.sl_avail</emphasis> &lt;&gt; shoelace_data.sl_avail\n   AND shoelace_data.sl_name = 'sl7';\n"
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:1235(para) 
msgid "The substitutions and the added qualifications ensure that, if the original query would be, say: <placeholder-1/> no log entry would get written. In that case, the original query tree does not contain a target list entry for <literal>sl_avail</literal>, so <literal>NEW.sl_avail</literal> will get replaced by <literal>shoelace_data.sl_avail</literal>. Thus, the extra command generated by the rule is: <placeholder-2/> and that qualification will never be true."
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:1266(programlisting) 
#, no-wrap
msgid "\nUPDATE shoelace_data SET sl_avail = 0\n WHERE sl_color = 'black';\n"
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:1276(programlisting) 
#, no-wrap
msgid "\nINSERT INTO shoelace_log\nSELECT shoelace_data.sl_name, 0,\n       current_user, current_timestamp\n  FROM shoelace_data\n WHERE 0 &lt;&gt; shoelace_data.sl_avail\n   AND <emphasis>shoelace_data.sl_color = 'black'</emphasis>;\n"
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:1262(para) 
msgid "It will also work if the original query modifies multiple rows. So if someone issued the command: <placeholder-1/> four rows in fact get updated (<literal>sl1</literal>, <literal>sl2</literal>, <literal>sl3</literal>, and <literal>sl4</literal>). But <literal>sl3</literal> already has <literal>sl_avail = 0</literal>. In this case, the original query trees qualification is different and that results in the extra query tree: <placeholder-2/> being generated by the rule. This query tree will surely insert three new log entries. And that's absolutely correct."
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:1289(para) 
msgid "Here we can see why it is important that the original query tree is executed last. If the <command>UPDATE</command> had been executed first, all the rows would have already been set to zero, so the logging <command>INSERT</command> would not find any row where <literal>0 &lt;&gt; shoelace_data.sl_avail</literal>."
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:1301(title) 
msgid "Cooperation with Views"
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:1303(secondary) 
msgid "updating"
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:1311(programlisting) 
#, no-wrap
msgid "\nCREATE RULE shoe_ins_protect AS ON INSERT TO shoe\n    DO INSTEAD NOTHING;\nCREATE RULE shoe_upd_protect AS ON UPDATE TO shoe\n    DO INSTEAD NOTHING;\nCREATE RULE shoe_del_protect AS ON DELETE TO shoe\n    DO INSTEAD NOTHING;\n"
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:1305(para) 
msgid "A simple way to protect view relations from the mentioned possibility that someone can try to run <command>INSERT</command>, <command>UPDATE</command>, or <command>DELETE</command> on them is to let those query trees get thrown away. So we could create the rules: <placeholder-1/> If someone now tries to do any of these operations on the view relation <literal>shoe</literal>, the rule system will apply these rules. Since the rules have no actions and are <literal>INSTEAD</literal>, the resulting list of query trees will be empty and the whole query will become nothing because there is nothing left to be optimized or executed after the rule system is done with it."
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:1336(programlisting) 
#, no-wrap
msgid "\nCREATE RULE shoelace_ins AS ON INSERT TO shoelace\n    DO INSTEAD\n    INSERT INTO shoelace_data VALUES (\n           NEW.sl_name,\n           NEW.sl_avail,\n           NEW.sl_color,\n           NEW.sl_len,\n           NEW.sl_unit\n    );\n\nCREATE RULE shoelace_upd AS ON UPDATE TO shoelace\n    DO INSTEAD\n    UPDATE shoelace_data\n       SET sl_name = NEW.sl_name,\n           sl_avail = NEW.sl_avail,\n           sl_color = NEW.sl_color,\n           sl_len = NEW.sl_len,\n           sl_unit = NEW.sl_unit\n     WHERE sl_name = OLD.sl_name;\n\nCREATE RULE shoelace_del AS ON DELETE TO shoelace\n    DO INSTEAD\n    DELETE FROM shoelace_data\n     WHERE sl_name = OLD.sl_name;\n"
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:1329(para) 
msgid "A more sophisticated way to use the rule system is to create rules that rewrite the query tree into one that does the right operation on the real tables. To do that on the <literal>shoelace</literal> view, we create the following rules: <placeholder-1/>"
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:1371(programlisting) 
#, no-wrap
msgid "\nCREATE RULE shoelace_ins AS ON INSERT TO shoelace\n    DO INSTEAD\n    INSERT INTO shoelace_data VALUES (\n           NEW.sl_name,\n           NEW.sl_avail,\n           NEW.sl_color,\n           NEW.sl_len,\n           NEW.sl_unit\n    )\n    RETURNING\n           shoelace_data.*,\n           (SELECT shoelace_data.sl_len * u.un_fact\n            FROM unit u WHERE shoelace_data.sl_unit = u.un_name);\n"
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:1364(para) 
msgid "If you want to support <literal>RETURNING</literal> queries on the view, you need to make the rules include <literal>RETURNING</literal> clauses that compute the view rows. This is usually pretty trivial for views on a single table, but it's a bit tedious for join views such as <literal>shoelace</literal>. An example for the insert case is: <placeholder-1/> Note that this one rule supports both <command>INSERT</command> and <command>INSERT RETURNING</command> queries on the view â€” the <literal>RETURNING</literal> clause is simply ignored for <command>INSERT</command>."
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:1400(programlisting) 
#, no-wrap
msgid "\nCREATE TABLE shoelace_arrive (\n    arr_name    text,\n    arr_quant   integer\n);\n\nCREATE TABLE shoelace_ok (\n    ok_name     text,\n    ok_quant    integer\n);\n\nCREATE RULE shoelace_ok_ins AS ON INSERT TO shoelace_ok\n    DO INSTEAD\n    UPDATE shoelace\n       SET sl_avail = sl_avail + NEW.ok_quant\n     WHERE sl_name = NEW.ok_name;\n"
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:1421(programlisting) 
#, no-wrap
msgid "\nSELECT * FROM shoelace_arrive;\n\n arr_name | arr_quant\n----------+-----------\n sl3      |        10\n sl6      |        20\n sl8      |        20\n(3 rows)\n"
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:1434(programlisting) 
#, no-wrap
msgid "\nSELECT * FROM shoelace;\n\n sl_name  | sl_avail | sl_color | sl_len | sl_unit | sl_len_cm\n----------+----------+----------+--------+---------+-----------\n sl1      |        5 | black    |     80 | cm      |        80\n sl2      |        6 | black    |    100 | cm      |       100\n sl7      |        6 | brown    |     60 | cm      |        60\n sl3      |        0 | black    |     35 | inch    |      88.9\n sl4      |        8 | black    |     40 | inch    |     101.6\n sl8      |        1 | brown    |     40 | inch    |     101.6\n sl5      |        4 | brown    |      1 | m       |       100\n sl6      |        0 | brown    |    0.9 | m       |        90\n(8 rows)\n"
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:1452(programlisting) 
#, no-wrap
msgid "\nINSERT INTO shoelace_ok SELECT * FROM shoelace_arrive;\n"
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:1458(programlisting) 
#, no-wrap
msgid "\nSELECT * FROM shoelace ORDER BY sl_name;\n\n sl_name  | sl_avail | sl_color | sl_len | sl_unit | sl_len_cm\n----------+----------+----------+--------+---------+-----------\n sl1      |        5 | black    |     80 | cm      |        80\n sl2      |        6 | black    |    100 | cm      |       100\n sl7      |        6 | brown    |     60 | cm      |        60\n sl4      |        8 | black    |     40 | inch    |     101.6\n sl3      |       10 | black    |     35 | inch    |      88.9\n sl8      |       21 | brown    |     40 | inch    |     101.6\n sl5      |        4 | brown    |      1 | m       |       100\n sl6      |       20 | brown    |    0.9 | m       |        90\n(8 rows)\n\nSELECT * FROM shoelace_log;\n\n sl_name | sl_avail | log_who| log_when                        \n---------+----------+--------+----------------------------------\n sl7     |        6 | Al     | Tue Oct 20 19:14:45 1998 MET DST\n sl3     |       10 | Al     | Tue Oct 20 19:25:16 1998 MET DST\n sl6     |       20 | Al     | Tue Oct 20 19:25:16 1998 MET DST\n sl8     |       21 | Al     | Tue Oct 20 19:25:16 1998 MET DST\n(4 rows)\n"
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:1392(para) 
msgid "Now assume that once in a while, a pack of shoelaces arrives at the shop and a big parts list along with it. But you don't want to manually update the <literal>shoelace</literal> view every time. Instead we setup two little tables: one where you can insert the items from the part list, and one with a special trick. The creation commands for these are: <placeholder-1/> Now you can fill the table <literal>shoelace_arrive</literal> with the data from the parts list: <placeholder-2/> Take a quick look at the current data: <placeholder-3/> Now move the arrived shoelaces in: <placeholder-4/> and check the results: <placeholder-5/>"
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:1491(programlisting) 
#, no-wrap
msgid "\nINSERT INTO shoelace_ok\nSELECT shoelace_arrive.arr_name, shoelace_arrive.arr_quant\n  FROM shoelace_arrive shoelace_arrive, shoelace_ok shoelace_ok;\n"
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:1500(programlisting) 
#, no-wrap
msgid "\nUPDATE shoelace\n   SET sl_avail = shoelace.sl_avail + shoelace_arrive.arr_quant\n  FROM shoelace_arrive shoelace_arrive, shoelace_ok shoelace_ok,\n       shoelace_ok old, shoelace_ok new,\n       shoelace shoelace\n WHERE shoelace.sl_name = shoelace_arrive.arr_name;\n"
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:1514(programlisting) 
#, no-wrap
msgid "\nUPDATE shoelace_data\n   SET sl_name = shoelace.sl_name,\n       sl_avail = shoelace.sl_avail + shoelace_arrive.arr_quant,\n       sl_color = shoelace.sl_color,\n       sl_len = shoelace.sl_len,\n       sl_unit = shoelace.sl_unit\n  FROM shoelace_arrive shoelace_arrive, shoelace_ok shoelace_ok,\n       shoelace_ok old, shoelace_ok new,\n       shoelace shoelace, shoelace old,\n       shoelace new, shoelace_data shoelace_data\n WHERE shoelace.sl_name = shoelace_arrive.arr_name\n   AND shoelace_data.sl_name = shoelace.sl_name;\n"
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:1534(programlisting) 
#, no-wrap
msgid "\nUPDATE shoelace_data\n   SET sl_name = s.sl_name,\n       sl_avail = s.sl_avail + shoelace_arrive.arr_quant,\n       sl_color = s.sl_color,\n       sl_len = s.sl_len,\n       sl_unit = s.sl_unit\n  FROM shoelace_arrive shoelace_arrive, shoelace_ok shoelace_ok,\n       shoelace_ok old, shoelace_ok new,\n       shoelace shoelace, shoelace old,\n       shoelace new, shoelace_data shoelace_data,\n       shoelace old, shoelace new,\n       shoelace_data s, unit u\n WHERE s.sl_name = shoelace_arrive.arr_name\n   AND shoelace_data.sl_name = s.sl_name;\n"
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:1554(programlisting) 
#, no-wrap
msgid "\nINSERT INTO shoelace_log\nSELECT s.sl_name,\n       s.sl_avail + shoelace_arrive.arr_quant,\n       current_user,\n       current_timestamp\n  FROM shoelace_arrive shoelace_arrive, shoelace_ok shoelace_ok,\n       shoelace_ok old, shoelace_ok new,\n       shoelace shoelace, shoelace old,\n       shoelace new, shoelace_data shoelace_data,\n       shoelace old, shoelace new,\n       shoelace_data s, unit u,\n       shoelace_data old, shoelace_data new\n       shoelace_log shoelace_log\n WHERE s.sl_name = shoelace_arrive.arr_name\n   AND shoelace_data.sl_name = s.sl_name\n   AND (s.sl_avail + shoelace_arrive.arr_quant) &lt;&gt; s.sl_avail;\n"
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:1485(para) 
msgid "It's a long way from the one <literal>INSERT ... SELECT</literal> to these results. And the description of the query-tree transformation will be the last in this chapter. First, there is the parser's output: <placeholder-1/> Now the first rule <literal>shoelace_ok_ins</literal> is applied and turns this into: <placeholder-2/> and throws away the original <command>INSERT</command> on <literal>shoelace_ok</literal>. This rewritten query is passed to the rule system again, and the second applied rule <literal>shoelace_upd</literal> produces: <placeholder-3/> Again it's an <literal>INSTEAD</literal> rule and the previous query tree is trashed. Note that this query still uses the view <literal>shoelace</literal>. But the rule system isn't finished with this step, so it continues and applies the <literal>_RETURN</literal> rule on it, and we get: <placeholder-4/> Finally, the rule <literal>log_shoelace</literal> gets applied, producing the extra query tree: <placeholder-5/> After that the rule system runs out of rules and returns the generated query trees."
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:1581(programlisting) 
#, no-wrap
msgid "\nINSERT INTO shoelace_log\nSELECT s.sl_name,\n       s.sl_avail + shoelace_arrive.arr_quant,\n       current_user,\n       current_timestamp\n  FROM shoelace_arrive shoelace_arrive, shoelace_data shoelace_data,\n       shoelace_data s\n WHERE s.sl_name = shoelace_arrive.arr_name\n   AND shoelace_data.sl_name = s.sl_name\n   AND s.sl_avail + shoelace_arrive.arr_quant &lt;&gt; s.sl_avail;\n\nUPDATE shoelace_data\n   SET sl_avail = shoelace_data.sl_avail + shoelace_arrive.arr_quant\n  FROM shoelace_arrive shoelace_arrive,\n       shoelace_data shoelace_data,\n       shoelace_data s\n WHERE s.sl_name = shoelace_arrive.sl_name\n   AND shoelace_data.sl_name = s.sl_name;\n"
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:1577(para) 
msgid "So we end up with two final query trees that are equivalent to the <acronym>SQL</acronym> statements: <placeholder-1/> The result is that data coming from one relation inserted into another, changed into updates on a third, changed into updating a fourth plus logging that final update in a fifth gets reduced into two queries."
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:1608(para) 
msgid "There is a little detail that's a bit ugly. Looking at the two queries, it turns out that the <literal>shoelace_data</literal> relation appears twice in the range table where it could definitely be reduced to one. The planner does not handle it and so the execution plan for the rule systems output of the <command>INSERT</command> will be <literallayout class=\"monospaced\">\nNested Loop\n  -&gt;  Merge Join\n        -&gt;  Seq Scan\n              -&gt;  Sort\n                    -&gt;  Seq Scan on s\n        -&gt;  Seq Scan\n              -&gt;  Sort\n                    -&gt;  Seq Scan on shoelace_arrive\n  -&gt;  Seq Scan on shoelace_data\n</literallayout> while omitting the extra range table entry would result in a <literallayout class=\"monospaced\">\nMerge Join\n  -&gt;  Seq Scan\n        -&gt;  Sort\n              -&gt;  Seq Scan on s\n  -&gt;  Seq Scan\n        -&gt;  Sort\n              -&gt;  Seq Scan on shoelace_arrive\n</literallayout> which produces exactly the same entries in the log table. Thus, the rule system caused one extra scan on the table <literal>shoelace_data</literal> that is absolutely not necessary. And the same redundant scan is done once more in the <command>UPDATE</command>. But it was a really hard job to make that all possible at all."
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:1654(programlisting) 
#, no-wrap
msgid "\nINSERT INTO shoelace VALUES ('sl9', 0, 'pink', 35.0, 'inch', 0.0);\nINSERT INTO shoelace VALUES ('sl10', 1000, 'magenta', 40.0, 'inch', 0.0);\n"
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:1663(programlisting) 
#, no-wrap
msgid "\nCREATE VIEW shoelace_mismatch AS\n    SELECT * FROM shoelace WHERE NOT EXISTS\n        (SELECT shoename FROM shoe WHERE slcolor = sl_color);\n"
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:1671(programlisting) 
#, no-wrap
msgid "\nSELECT * FROM shoelace_mismatch;\n\n sl_name | sl_avail | sl_color | sl_len | sl_unit | sl_len_cm\n---------+----------+----------+--------+---------+-----------\n sl9     |        0 | pink     |     35 | inch    |      88.9\n sl10    |     1000 | magenta  |     40 | inch    |     101.6\n"
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:1648(para) 
msgid "Now we make a final demonstration of the <productname>PostgreSQL</productname> rule system and its power. Say you add some shoelaces with extraordinary colors to your database: <placeholder-1/> We would like to make a view to check which <literal>shoelace</literal> entries do not fit any shoe in color. The view for this is: <placeholder-2/> Its output is: <placeholder-3/>"
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:1687(programlisting) 
#, no-wrap
msgid "\nCREATE VIEW shoelace_can_delete AS\n    SELECT * FROM shoelace_mismatch WHERE sl_avail = 0;\n"
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:1694(programlisting) 
#, no-wrap
msgid "\nDELETE FROM shoelace WHERE EXISTS\n    (SELECT * FROM shoelace_can_delete\n             WHERE sl_name = shoelace.sl_name);\n"
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:1702(programlisting) 
#, no-wrap
msgid "\nSELECT * FROM shoelace;\n\n sl_name | sl_avail | sl_color | sl_len | sl_unit | sl_len_cm\n---------+----------+----------+--------+---------+-----------\n sl1     |        5 | black    |     80 | cm      |        80\n sl2     |        6 | black    |    100 | cm      |       100\n sl7     |        6 | brown    |     60 | cm      |        60\n sl4     |        8 | black    |     40 | inch    |     101.6\n sl3     |       10 | black    |     35 | inch    |      88.9\n sl8     |       21 | brown    |     40 | inch    |     101.6\n sl10    |     1000 | magenta  |     40 | inch    |     101.6\n sl5     |        4 | brown    |      1 | m       |       100\n sl6     |       20 | brown    |    0.9 | m       |        90\n(9 rows)\n"
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:1681(para) 
msgid "Now we want to set it up so that mismatching shoelaces that are not in stock are deleted from the database. To make it a little harder for <productname>PostgreSQL</productname>, we don't delete it directly. Instead we create one more view: <placeholder-1/> and do it this way: <placeholder-2/><foreignphrase>VoilÃ </foreignphrase>: <placeholder-3/>"
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:1720(para) 
msgid "A <command>DELETE</command> on a view, with a subquery qualification that in total uses 4 nesting/joined views, where one of them itself has a subquery qualification containing a view and where calculated view columns are used, gets rewritten into one single query tree that deletes the requested data from a real table."
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:1730(para) 
msgid "There are probably only a few situations out in the real world where such a construct is necessary. But it makes you feel comfortable that it works."
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:1740(title) 
msgid "Rules and Privileges"
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:1743(primary) /tmp/cicero-PnJu/rules.xml:1748(primary) 
msgid "privilege"
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:1744(secondary) 
msgid "with rules"
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:1749(secondary) 
msgid "with views"
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:1752(para) 
msgid "Due to rewriting of queries by the <productname>PostgreSQL</productname> rule system, other tables/views than those used in the original query get accessed. When update rules are used, this can include write access to tables."
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:1759(para) 
msgid "Rewrite rules don't have a separate owner. The owner of a relation (table or view) is automatically the owner of the rewrite rules that are defined for it. The <productname>PostgreSQL</productname> rule system changes the behavior of the default access control system. Relations that are used due to rules get checked against the privileges of the rule owner, not the user invoking the rule. This means that a user only needs the required privileges for the tables/views that he names explicitly in his queries."
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:1776(programlisting) 
#, no-wrap
msgid "\nCREATE TABLE phone_data (person text, phone text, private boolean);\nCREATE VIEW phone_number AS\n    SELECT person, CASE WHEN NOT private THEN phone END AS phone\n    FROM phone_data;\nGRANT SELECT ON phone_number TO secretary;\n"
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:1771(para) 
msgid "For example: A user has a list of phone numbers where some of them are private, the others are of interest for the secretary of the office. He can construct the following: <placeholder-1/> Nobody except him (and the database superusers) can access the <literal>phone_data</literal> table. But because of the <command>GRANT</command>, the secretary can run a <command>SELECT</command> on the <literal>phone_number</literal> view. The rule system will rewrite the <command>SELECT</command> from <literal>phone_number</literal> into a <command>SELECT</command> from <literal>phone_data</literal>. Since the user is the owner of <literal>phone_number</literal> and therefore the owner of the rule, the read access to <literal>phone_data</literal> is now checked against his privileges and the query is permitted. The check for accessing <literal>phone_number</literal> is also performed, but this is done against the invoking user, so nobody but the user and the secretary can use it."
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:1799(para) 
msgid "The privileges are checked rule by rule. So the secretary is for now the only one who can see the public phone numbers. But the secretary can setup another view and grant access to that to the public. Then, anyone can see the <literal>phone_number</literal> data through the secretary's view. What the secretary cannot do is to create a view that directly accesses <literal>phone_data</literal>. (Actually he can, but it will not work since every access will be denied during the permission checks.) And as soon as the user will notice, that the secretary opened his <literal>phone_number</literal> view, he can revoke his access. Immediately, any access to the secretary's view would fail."
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:1812(para) 
msgid "One might think that this rule-by-rule checking is a security hole, but in fact it isn't. But if it did not work this way, the secretary could set up a table with the same columns as <literal>phone_number</literal> and copy the data to there once per day. Then it's his own data and he can grant access to everyone he wants. A <command>GRANT</command> command means, <quote>I trust you</quote>. If someone you trust does the thing above, it's time to think it over and then use <command>REVOKE</command>."
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:1828(programlisting) 
#, no-wrap
msgid "\nCREATE VIEW phone_number AS\n    SELECT person, phone FROM phone_data WHERE phone NOT LIKE '412%';\n"
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:1840(programlisting) 
#, no-wrap
msgid "\nCREATE FUNCTION tricky(text, text) RETURNS bool AS $$\nBEGIN\n    RAISE NOTICE '% =&gt; %', $1, $2;\n    RETURN true;\nEND\n$$ LANGUAGE plpgsql COST 0.0000000000000000000001;\n\nSELECT * FROM phone_number WHERE tricky(person, phone);\n"
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:1823(para) 
msgid "Note that while views can be used to hide the contents of certain columns using the technique shown above, they cannot be used to reliably conceal the data in unseen rows. For example, the following view is insecure: <placeholder-1/> This view might seem secure, since the rule system will rewrite any <command>SELECT</command> from <literal>phone_number</literal> into a <command>SELECT</command> from <literal>phone_data</literal> and add the qualification that only entries where <literal>phone</literal> does not begin with 412 are wanted. But if the user can create his or her own functions, it is not difficult to convince the planner to execute the user-defined function prior to the <function>NOT LIKE</function> expression. For example: <placeholder-2/> Every person and phone number in the <literal>phone_data</literal> table will be printed as a <literal>NOTICE</literal>, because the planner will choose to execute the inexpensive <function>tricky</function> function before the more expensive <function>NOT LIKE</function>. Even if the user is prevented from defining new functions, built-in functions can be used in similar attacks. (For example, most casting functions include their input values in the error messages they produce.)"
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:1859(para) 
msgid "Similar considerations apply to update rules. In the examples of the previous section, the owner of the tables in the example database could grant the privileges <literal>SELECT</literal>, <literal>INSERT</literal>, <literal>UPDATE</literal>, and <literal>DELETE</literal> on the <literal>shoelace</literal> view to someone else, but only <literal>SELECT</literal> on <literal>shoelace_log</literal>. The rule action to write log entries will still be executed successfully, and that other user could see the log entries. But he cannot create fake entries, nor could he manipulate or remove existing ones. In this case, there is no possibility of subverting the rules by convincing the planner to alter the order of operations, because the only rule which references <literal>shoelace_log</literal> is an unqualified <literal>INSERT</literal>. This might not be true in more complex scenarios."
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:1877(title) 
msgid "Rules and Command Status"
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:1879(para) 
msgid "The <productname>PostgreSQL</productname> server returns a command status string, such as <literal>INSERT 149592 1</literal>, for each command it receives. This is simple enough when there are no rules involved, but what happens when the query is rewritten by rules?"
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:1891(para) 
msgid "If there is no unconditional <literal>INSTEAD</literal> rule for the query, then the originally given query will be executed, and its command status will be returned as usual. (But note that if there were any conditional <literal>INSTEAD</literal> rules, the negation of their qualifications will have been added to the original query. This might reduce the number of rows it processes, and if so the reported status will be affected.)"
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:1903(para) 
msgid "If there is any unconditional <literal>INSTEAD</literal> rule for the query, then the original query will not be executed at all. In this case, the server will return the command status for the last query that was inserted by an <literal>INSTEAD</literal> rule (conditional or unconditional) and is of the same command type (<command>INSERT</command>, <command>UPDATE</command>, or <command>DELETE</command>) as the original query. If no query meeting those requirements is added by any rule, then the returned command status shows the original query type and zeroes for the row-count and OID fields."
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:1886(para) 
msgid "Rules affect the command status as follows: <placeholder-1/> (This system was established in <productname>PostgreSQL</productname> 7.3. In versions before that, the command status might show different results when rules exist.)"
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:1923(para) 
msgid "The programmer can ensure that any desired <literal>INSTEAD</literal> rule is the one that sets the command status in the second case, by giving it the alphabetically last rule name among the active rules, so that it gets applied last."
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:1932(title) 
msgid "Rules Versus Triggers"
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:1936(secondary) 
msgid "compared with triggers"
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:1940(primary) 
msgid "trigger"
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:1941(secondary) 
msgid "compared with rules"
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:1944(para) 
msgid "Many things that can be done using triggers can also be implemented using the <productname>PostgreSQL</productname> rule system. One of the things that cannot be implemented by rules are some kinds of constraints, especially foreign keys. It is possible to place a qualified rule that rewrites a command to <literal>NOTHING</literal> if the value of a column does not appear in another table. But then the data is silently thrown away and that's not a good idea. If checks for valid values are required, and in the case of an invalid value an error message should be generated, it must be done by a trigger."
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:1957(para) 
msgid "In this chapter, we focused on using rules to update views. All of the update rule examples in this chapter can also be implemented using <literal>INSTEAD OF</literal> triggers on the views. Writing such triggers is often easier than writing rules, particularly if complex logic is required to perform the update."
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:1965(para) 
msgid "For the things that can be implemented by both, which is best depends on the usage of the database. A trigger is fired once for each affected row. A rule modifies the query or generates an additional query. So if many rows are affected in one statement, a rule issuing one extra command is likely to be faster than a trigger that is called for every single row and must re-determine what to do many times. However, the trigger approach is conceptually far simpler than the rule approach, and is easier for novices to get right."
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:1981(programlisting) 
#, no-wrap
msgid "\nCREATE TABLE computer (\n    hostname        text,    -- indexed\n    manufacturer    text     -- indexed\n);\n\nCREATE TABLE software (\n    software        text,    -- indexed\n    hostname        text     -- indexed\n);\n"
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:1998(programlisting) 
#, no-wrap
msgid "\nDELETE FROM software WHERE hostname = $1;\n"
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:2007(programlisting) 
#, no-wrap
msgid "\nCREATE RULE computer_del AS ON DELETE TO computer\n    DO DELETE FROM software WHERE hostname = OLD.hostname;\n"
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:1977(para) 
msgid "Here we show an example of how the choice of rules versus triggers plays out in one situation. There are two tables: <placeholder-1/> Both tables have many thousands of rows and the indexes on <structfield>hostname</structfield> are unique. The rule or trigger should implement a constraint that deletes rows from <literal>software</literal> that reference a deleted computer. The trigger would use this command: <placeholder-2/> Since the trigger is called for each individual row deleted from <literal>computer</literal>, it can prepare and save the plan for this command and pass the <structfield>hostname</structfield> value in the parameter. The rule would be written as: <placeholder-3/>"
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:2016(programlisting) 
#, no-wrap
msgid "\nDELETE FROM computer WHERE hostname = 'mypc.local.net';\n"
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:2024(programlisting) 
#, no-wrap
msgid "\nDELETE FROM software WHERE computer.hostname = 'mypc.local.net'\n                       AND software.hostname = computer.hostname;\n"
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:2013(para) 
msgid "Now we look at different types of deletes. In the case of a: <placeholder-1/> the table <literal>computer</literal> is scanned by index (fast), and the command issued by the trigger would also use an index scan (also fast). The extra command from the rule would be: <placeholder-2/> Since there are appropriate indexes setup, the planner will create a plan of <literallayout class=\"monospaced\">\nNestloop\n  -&gt;  Index Scan using comp_hostidx on computer\n  -&gt;  Index Scan using soft_hostidx on software\n</literallayout> So there would be not that much difference in speed between the trigger and the rule implementation."
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:2048(programlisting) 
#, no-wrap
msgid "\nDELETE FROM computer WHERE hostname &gt;= 'old'\n                       AND hostname &lt;  'ole'\n"
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:2055(programlisting) 
#, no-wrap
msgid "\nDELETE FROM software WHERE computer.hostname &gt;= 'old' AND computer.hostname &lt; 'ole'\n                       AND software.hostname = computer.hostname;\n"
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:2071(programlisting) 
#, no-wrap
msgid "\nDELETE FROM computer WHERE hostname ~ '^old';\n"
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:2042(para) 
msgid "With the next delete we want to get rid of all the 2000 computers where the <structfield>hostname</structfield> starts with <literal>old</literal>. There are two possible commands to do that. One is: <placeholder-1/> The command added by the rule will be: <placeholder-2/> with the plan <literallayout class=\"monospaced\">\nHash Join\n  -&gt;  Seq Scan on software\n  -&gt;  Hash\n    -&gt;  Index Scan using comp_hostidx on computer\n</literallayout> The other possible command is: <placeholder-3/> which results in the following executing plan for the command added by the rule: <literallayout class=\"monospaced\">\nNestloop\n  -&gt;  Index Scan using comp_hostidx on computer\n  -&gt;  Index Scan using soft_hostidx on software\n</literallayout> This shows, that the planner does not realize that the qualification for <structfield>hostname</structfield> in <literal>computer</literal> could also be used for an index scan on <literal>software</literal> when there are multiple qualification expressions combined with <literal>AND</literal>, which is what it does in the regular-expression version of the command. The trigger will get invoked once for each of the 2000 old computers that have to be deleted, and that will result in one index scan over <literal>computer</literal> and 2000 index scans over <literal>software</literal>. The rule implementation will do it with two commands that use indexes. And it depends on the overall size of the table <literal>software</literal> whether the rule will still be faster in the sequential scan situation. 2000 command executions from the trigger over the SPI manager take some time, even if all the index blocks will soon be in the cache."
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:2103(programlisting) 
#, no-wrap
msgid "\nDELETE FROM computer WHERE manufacturer = 'bim';\n"
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:2111(programlisting) 
#, no-wrap
msgid "\nDELETE FROM software WHERE computer.manufacturer = 'bim'\n                       AND software.hostname = computer.hostname;\n"
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:2119(programlisting) 
#, no-wrap
msgid "\nNestloop\n  -&gt;  Index Scan using comp_manufidx on computer\n  -&gt;  Index Scan using soft_hostidx on software\n"
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:2100(para) 
msgid "The last command we look at is: <placeholder-1/> Again this could result in many rows to be deleted from <literal>computer</literal>. So the trigger will again run many commands through the executor. The command generated by the rule will be: <placeholder-2/> The plan for that command will again be the nested loop over two index scans, only using a different index on <literal>computer</literal>: <placeholder-3/> In any of these cases, the extra commands from the rule system will be more or less independent from the number of affected rows in a command."
msgstr ""

#: /tmp/cicero-PnJu/rules.xml:2132(para) 
msgid "The summary is, rules will only be significantly slower than triggers if their actions result in large and badly qualified joins, a situation where the planner fails."
msgstr ""

#. Put one translator per line, in the form of NAME <EMAIL>, YEAR1, YEAR2.
#: /tmp/cicero-PnJu/rules.xml:0(None) 
msgid "translator-credits"
msgstr ""

