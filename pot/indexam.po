msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2011-09-26 06:58+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: /tmp/cicero-ZVyl/indexam.xml:5(title) 
msgid "Index Access Method Interface Definition"
msgstr ""

#: /tmp/cicero-ZVyl/indexam.xml:7(para) 
msgid "This chapter defines the interface between the core <productname>PostgreSQL</productname> system and <firstterm>index access methods</firstterm>, which manage individual index types. The core system knows nothing about indexes beyond what is specified here, so it is possible to develop entirely new index types by writing add-on code."
msgstr ""

#: /tmp/cicero-ZVyl/indexam.xml:15(para) 
msgid "All indexes in <productname>PostgreSQL</productname> are what are known technically as <firstterm>secondary indexes</firstterm>; that is, the index is physically separate from the table file that it describes. Each index is stored as its own physical <firstterm>relation</firstterm> and so is described by an entry in the <structname>pg_class</structname> catalog. The contents of an index are entirely under the control of its index access method. In practice, all index access methods divide indexes into standard-size pages so that they can use the regular storage manager and buffer manager to access the index contents. (All the existing index access methods furthermore use the standard page layout described in <xref linkend=\"storage-page-layout\"/>, and they all use the same format for index tuple headers; but these decisions are not forced on an access method.)"
msgstr ""

#: /tmp/cicero-ZVyl/indexam.xml:30(para) 
msgid "An index is effectively a mapping from some data key values to <firstterm>tuple identifiers</firstterm>, or <acronym>TIDs</acronym>, of row versions (tuples) in the index's parent table. A TID consists of a block number and an item number within that block (see <xref linkend=\"storage-page-layout\"/>). This is sufficient information to fetch a particular row version from the table. Indexes are not directly aware that under MVCC, there might be multiple extant versions of the same logical row; to an index, each tuple is an independent object that needs its own index entry. Thus, an update of a row always creates all-new index entries for the row, even if the key values did not change. (HOT tuples are an exception to this statement; but indexes do not deal with those, either.) Index entries for dead tuples are reclaimed (by vacuuming) when the dead tuples themselves are reclaimed."
msgstr ""

#: /tmp/cicero-ZVyl/indexam.xml:48(title) 
msgid "Catalog Entries for Indexes"
msgstr ""

#: /tmp/cicero-ZVyl/indexam.xml:50(para) 
msgid "Each index access method is described by a row in the <structname>pg_am</structname> system catalog (see <xref linkend=\"catalog-pg-am\"/>). The principal contents of a <structname>pg_am</structname> row are references to <link linkend=\"catalog-pg-proc\"><structname>pg_proc</structname></link> entries that identify the index access functions supplied by the access method. The APIs for these functions are defined later in this chapter. In addition, the <structname>pg_am</structname> row specifies a few fixed properties of the access method, such as whether it can support multicolumn indexes. There is not currently any special support for creating or deleting <structname>pg_am</structname> entries; anyone able to write a new access method is expected to be competent to insert an appropriate row for themselves."
msgstr ""

#: /tmp/cicero-ZVyl/indexam.xml:67(para) 
msgid "To be useful, an index access method must also have one or more <firstterm>operator families</firstterm> and <firstterm>operator classes</firstterm> defined in <link linkend=\"catalog-pg-opfamily\"><structname>pg_opfamily</structname></link>, <link linkend=\"catalog-pg-opclass\"><structname>pg_opclass</structname></link>, <link linkend=\"catalog-pg-amop\"><structname>pg_amop</structname></link>, and <link linkend=\"catalog-pg-amproc\"><structname>pg_amproc</structname></link>. These entries allow the planner to determine what kinds of query qualifications can be used with indexes of this access method. Operator families and classes are described in <xref linkend=\"xindex\"/>, which is prerequisite material for reading this chapter."
msgstr ""

#: /tmp/cicero-ZVyl/indexam.xml:82(para) 
msgid "An individual index is defined by a <link linkend=\"catalog-pg-class\"><structname>pg_class</structname></link> entry that describes it as a physical relation, plus a <link linkend=\"catalog-pg-index\"><structname>pg_index</structname></link> entry that shows the logical content of the index â€” that is, the set of index columns it has and the semantics of those columns, as captured by the associated operator classes. The index columns (key values) can be either simple columns of the underlying table or expressions over the table rows. The index access method normally has no interest in where the index key values come from (it is always handed precomputed key values) but it will be very interested in the operator class information in <structname>pg_index</structname>. Both of these catalog entries can be accessed as part of the <structname>Relation</structname> data structure that is passed to all operations on the index."
msgstr ""

#: /tmp/cicero-ZVyl/indexam.xml:99(para) 
msgid "Some of the flag columns of <structname>pg_am</structname> have nonobvious implications. The requirements of <structfield>amcanunique</structfield> are discussed in <xref linkend=\"index-unique-checks\"/>. The <structfield>amcanmulticol</structfield> flag asserts that the access method supports multicolumn indexes, while <structfield>amoptionalkey</structfield> asserts that it allows scans where no indexable restriction clause is given for the first index column. When <structfield>amcanmulticol</structfield> is false, <structfield>amoptionalkey</structfield> essentially says whether the access method supports full-index scans without any restriction clause. Access methods that support multiple index columns <emphasis>must</emphasis> support scans that omit restrictions on any or all of the columns after the first; however they are permitted to require some restriction to appear for the first index column, and this is signaled by setting <structfield>amoptionalkey</structfield> false. One reason that an index AM might set <structfield>amoptionalkey</structfield> false is if it doesn't index NULLs. Since most indexable operators are strict and hence cannot return TRUE for NULL inputs, it is at first sight attractive to not store index entries for null values: they could never be returned by an index scan anyway. However, this argument fails when an index scan has no restriction clause for a given index column. In practice this means that indexes that have <structfield>amoptionalkey</structfield> true must index nulls, since the planner might decide to use such an index with no scan keys at all. A related restriction is that an index access method that supports multiple index columns <emphasis>must</emphasis> support indexing null values in columns after the first, because the planner will assume the index can be used for queries that do not restrict these columns. For example, consider an index on (a,b) and a query with <literal>WHERE a = 4</literal>. The system will assume the index can be used to scan for rows with <literal>a = 4</literal>, which is wrong if the index omits rows where <literal>b</literal> is null. It is, however, OK to omit rows where the first indexed column is null. An index access method that does index nulls may also set <structfield>amsearchnulls</structfield>, indicating that it supports <literal>IS NULL</literal> and <literal>IS NOT NULL</literal> clauses as search conditions."
msgstr ""

#: /tmp/cicero-ZVyl/indexam.xml:143(title) 
msgid "Index Access Method Functions"
msgstr ""

#: /tmp/cicero-ZVyl/indexam.xml:145(para) 
msgid "The index construction and maintenance functions that an index access method must provide are:"
msgstr ""

#: /tmp/cicero-ZVyl/indexam.xml:151(programlisting) 
#, no-wrap
msgid "\nIndexBuildResult *\nambuild (Relation heapRelation,\n         Relation indexRelation,\n         IndexInfo *indexInfo);\n"
msgstr ""

#: /tmp/cicero-ZVyl/indexam.xml:150(para) 
msgid "<placeholder-1/> Build a new index. The index relation has been physically created, but is empty. It must be filled in with whatever fixed data the access method requires, plus entries for all tuples already existing in the table. Ordinarily the <function>ambuild</function> function will call <function>IndexBuildHeapScan()</function> to scan the table for existing tuples and compute the keys that need to be inserted into the index. The function must return a palloc'd struct containing statistics about the new index."
msgstr ""

#: /tmp/cicero-ZVyl/indexam.xml:168(programlisting) 
#, no-wrap
msgid "\nvoid\nambuildempty (Relation indexRelation);\n"
msgstr ""

#: /tmp/cicero-ZVyl/indexam.xml:167(para) 
msgid "<placeholder-1/> Build an empty index, and write it to the initialization fork (INIT_FORKNUM) of the given relation. This method is called only for unlogged tables; the empty index written to the initialization fork will be copied over the main relation fork on each server restart."
msgstr ""

#: /tmp/cicero-ZVyl/indexam.xml:179(programlisting) 
#, no-wrap
msgid "\nbool\naminsert (Relation indexRelation,\n          Datum *values,\n          bool *isnull,\n          ItemPointer heap_tid,\n          Relation heapRelation,\n          IndexUniqueCheck checkUnique);\n"
msgstr ""

#: /tmp/cicero-ZVyl/indexam.xml:178(para) 
msgid "<placeholder-1/> Insert a new tuple into an existing index. The <literal>values</literal> and <literal>isnull</literal> arrays give the key values to be indexed, and <literal>heap_tid</literal> is the TID to be indexed. If the access method supports unique indexes (its <structname>pg_am</structname>.<structfield>amcanunique</structfield> flag is true) then <literal>checkUnique</literal> indicates the type of uniqueness check to perform. This varies depending on whether the unique constraint is deferrable; see <xref linkend=\"index-unique-checks\"/> for details. Normally the access method only needs the <literal>heapRelation</literal> parameter when performing uniqueness checking (since then it will have to look into the heap to verify tuple liveness)."
msgstr ""

#: /tmp/cicero-ZVyl/indexam.xml:201(para) 
msgid "The function's Boolean result value is significant only when <literal>checkUnique</literal> is <literal>UNIQUE_CHECK_PARTIAL</literal>. In this case a TRUE result means the new entry is known unique, whereas FALSE means it might be non-unique (and a deferred uniqueness check must be scheduled). For other cases a constant FALSE result is recommended."
msgstr ""

#: /tmp/cicero-ZVyl/indexam.xml:209(para) 
msgid "Some indexes might not index all tuples. If the tuple is not to be indexed, <function>aminsert</function> should just return without doing anything."
msgstr ""

#: /tmp/cicero-ZVyl/indexam.xml:215(programlisting) 
#, no-wrap
msgid "\nIndexBulkDeleteResult *\nambulkdelete (IndexVacuumInfo *info,\n              IndexBulkDeleteResult *stats,\n              IndexBulkDeleteCallback callback,\n              void *callback_state);\n"
msgstr ""

#: /tmp/cicero-ZVyl/indexam.xml:214(para) 
msgid "<placeholder-1/> Delete tuple(s) from the index. This is a <quote>bulk delete</quote> operation that is intended to be implemented by scanning the whole index and checking each entry to see if it should be deleted. The passed-in <literal>callback</literal> function must be called, in the style <literal>callback(<replaceable>TID</replaceable>, callback_state) returns bool</literal>, to determine whether any particular index entry, as identified by its referenced TID, is to be deleted. Must return either NULL or a palloc'd struct containing statistics about the effects of the deletion operation. It is OK to return NULL if no information needs to be passed on to <function>amvacuumcleanup</function>."
msgstr ""

#: /tmp/cicero-ZVyl/indexam.xml:234(para) 
msgid "Because of limited <varname>maintenance_work_mem</varname>, <function>ambulkdelete</function> might need to be called more than once when many tuples are to be deleted. The <literal>stats</literal> argument is the result of the previous call for this index (it is NULL for the first call within a <command>VACUUM</command> operation). This allows the AM to accumulate statistics across the whole operation. Typically, <function>ambulkdelete</function> will modify and return the same struct if the passed <literal>stats</literal> is not null."
msgstr ""

#: /tmp/cicero-ZVyl/indexam.xml:246(programlisting) 
#, no-wrap
msgid "\nIndexBulkDeleteResult *\namvacuumcleanup (IndexVacuumInfo *info,\n                 IndexBulkDeleteResult *stats);\n"
msgstr ""

#: /tmp/cicero-ZVyl/indexam.xml:245(para) 
msgid "<placeholder-1/> Clean up after a <command>VACUUM</command> operation (zero or more <function>ambulkdelete</function> calls). This does not have to do anything beyond returning index statistics, but it might perform bulk cleanup such as reclaiming empty index pages. <literal>stats</literal> is whatever the last <function>ambulkdelete</function> call returned, or NULL if <function>ambulkdelete</function> was not called because no tuples needed to be deleted. If the result is not NULL it must be a palloc'd struct. The statistics it contains will be used to update <structname>pg_class</structname>, and will be reported by <command>VACUUM</command> if <literal>VERBOSE</literal> is given. It is OK to return NULL if the index was not changed at all during the <command>VACUUM</command> operation, but otherwise correct stats should be returned."
msgstr ""

#: /tmp/cicero-ZVyl/indexam.xml:265(para) 
msgid "As of <productname>PostgreSQL</productname> 8.4, <function>amvacuumcleanup</function> will also be called at completion of an <command>ANALYZE</command> operation. In this case <literal>stats</literal> is always NULL and any return value will be ignored. This case can be distinguished by checking <literal>info-&gt;analyze_only</literal>. It is recommended that the access method do nothing except post-insert cleanup in such a call, and that only in an autovacuum worker process."
msgstr ""

#: /tmp/cicero-ZVyl/indexam.xml:276(programlisting) /tmp/cicero-ZVyl/indexam.xml:890(programlisting) 
#, no-wrap
msgid "\nvoid\namcostestimate (PlannerInfo *root,\n                IndexOptInfo *index,\n                List *indexQuals,\n                List *indexOrderBys,\n                RelOptInfo *outer_rel,\n                Cost *indexStartupCost,\n                Cost *indexTotalCost,\n                Selectivity *indexSelectivity,\n                double *indexCorrelation);\n"
msgstr ""

#: /tmp/cicero-ZVyl/indexam.xml:275(para) 
msgid "<placeholder-1/> Estimate the costs of an index scan. This function is described fully in <xref linkend=\"index-cost-estimation\"/>, below."
msgstr ""

#: /tmp/cicero-ZVyl/indexam.xml:293(programlisting) 
#, no-wrap
msgid "\nbytea *\namoptions (ArrayType *reloptions,\n           bool validate);\n"
msgstr ""

#: /tmp/cicero-ZVyl/indexam.xml:292(para) 
msgid "<placeholder-1/> Parse and validate the reloptions array for an index. This is called only when a non-null reloptions array exists for the index. <parameter>reloptions</parameter> is a <type>text</type> array containing entries of the form <replaceable>name</replaceable><literal>=</literal><replaceable>value</replaceable>. The function should construct a <type>bytea</type> value, which will be copied into the <structfield>rd_options</structfield> field of the index's relcache entry. The data contents of the <type>bytea</type> value are open for the access method to define; most of the standard access methods use struct <structname>StdRdOptions</structname>. When <parameter>validate</parameter> is true, the function should report a suitable error message if any of the options are unrecognized or have invalid values; when <parameter>validate</parameter> is false, invalid entries should be silently ignored. (<parameter>validate</parameter> is false when loading options already stored in <structname>pg_catalog</structname>; an invalid entry could only be found if the access method has changed its rules for options, and in that case ignoring obsolete entries is appropriate.) It is OK to return NULL if default behavior is wanted."
msgstr ""

#: /tmp/cicero-ZVyl/indexam.xml:317(para) 
msgid "The purpose of an index, of course, is to support scans for tuples matching an indexable <literal>WHERE</literal> condition, often called a <firstterm>qualifier</firstterm> or <firstterm>scan key</firstterm>. The semantics of index scanning are described more fully in <xref linkend=\"index-scanning\"/>, below. An index access method can support <quote>plain</quote> index scans, <quote>bitmap</quote> index scans, or both. The scan-related functions that an index access method must or may provide are:"
msgstr ""

#: /tmp/cicero-ZVyl/indexam.xml:328(programlisting) 
#, no-wrap
msgid "\nIndexScanDesc\nambeginscan (Relation indexRelation,\n             int nkeys,\n             int norderbys);\n"
msgstr ""

#: /tmp/cicero-ZVyl/indexam.xml:327(para) 
msgid "<placeholder-1/> Prepare for an index scan. The <literal>nkeys</literal> and <literal>norderbys</literal> parameters indicate the number of quals and ordering operators that will be used in the scan; these may be useful for space allocation purposes. Note that the actual values of the scan keys aren't provided yet. The result must be a palloc'd struct. For implementation reasons the index access method <emphasis>must</emphasis> create this struct by calling <function>RelationGetIndexScan()</function>. In most cases <function>ambeginscan</function> does little beyond making that call and perhaps acquiring locks; the interesting parts of index-scan startup are in <function>amrescan</function>."
msgstr ""

#: /tmp/cicero-ZVyl/indexam.xml:348(programlisting) 
#, no-wrap
msgid "\nvoid\namrescan (IndexScanDesc scan,\n          ScanKey keys,\n          int nkeys,\n          ScanKey orderbys,\n          int norderbys);\n"
msgstr ""

#: /tmp/cicero-ZVyl/indexam.xml:347(para) 
msgid "<placeholder-1/> Start or restart an indexscan, possibly with new scan keys. (To restart using previously-passed keys, NULL is passed for <literal>keys</literal> and/or <literal>orderbys</literal>.) Note that it is not allowed for the number of keys or order-by operators to be larger than what was passed to <function>ambeginscan</function>. In practice the restart feature is used when a new outer tuple is selected by a nested-loop join and so a new key comparison value is needed, but the scan key structure remains the same."
msgstr ""

#: /tmp/cicero-ZVyl/indexam.xml:367(programlisting) 
#, no-wrap
msgid "\nboolean\namgettuple (IndexScanDesc scan,\n            ScanDirection direction);\n"
msgstr ""

#: /tmp/cicero-ZVyl/indexam.xml:366(para) 
msgid "<placeholder-1/> Fetch the next tuple in the given scan, moving in the given direction (forward or backward in the index). Returns TRUE if a tuple was obtained, FALSE if no matching tuples remain. In the TRUE case the tuple TID is stored into the <literal>scan</literal> structure. Note that <quote>success</quote> means only that the index contains an entry that matches the scan keys, not that the tuple necessarily still exists in the heap or will pass the caller's snapshot test. On success, <function>amgettuple</function> must also set <literal>scan-&gt;xs_recheck</literal> to TRUE or FALSE. FALSE means it is certain that the index entry matches the scan keys. TRUE means this is not certain, and the conditions represented by the scan keys must be rechecked against the heap tuple after fetching it. This provision supports <quote>lossy</quote> index operators. Note that rechecking will extend only to the scan conditions; a partial index predicate (if any) is never rechecked by <function>amgettuple</function> callers."
msgstr ""

#: /tmp/cicero-ZVyl/indexam.xml:389(para) 
msgid "The <function>amgettuple</function> function need only be provided if the access method supports <quote>plain</quote> index scans. If it doesn't, the <structfield>amgettuple</structfield> field in its <structname>pg_am</structname> row must be set to zero."
msgstr ""

#: /tmp/cicero-ZVyl/indexam.xml:397(programlisting) 
#, no-wrap
msgid "\nint64\namgetbitmap (IndexScanDesc scan,\n             TIDBitmap *tbm);\n"
msgstr ""

#: /tmp/cicero-ZVyl/indexam.xml:396(para) 
msgid "<placeholder-1/> Fetch all tuples in the given scan and add them to the caller-supplied <type>TIDBitmap</type> (that is, OR the set of tuple IDs into whatever set is already in the bitmap). The number of tuples fetched is returned (this might be just an approximate count, for instance some AMs do not detect duplicates). While inserting tuple IDs into the bitmap, <function>amgetbitmap</function> can indicate that rechecking of the scan conditions is required for specific tuple IDs. This is analogous to the <literal>xs_recheck</literal> output parameter of <function>amgettuple</function>. Note: in the current implementation, support for this feature is conflated with support for lossy storage of the bitmap itself, and therefore callers recheck both the scan conditions and the partial index predicate (if any) for recheckable tuples. That might not always be true, however. <function>amgetbitmap</function> and <function>amgettuple</function> cannot be used in the same index scan; there are other restrictions too when using <function>amgetbitmap</function>, as explained in <xref linkend=\"index-scanning\"/>."
msgstr ""

#: /tmp/cicero-ZVyl/indexam.xml:420(para) 
msgid "The <function>amgetbitmap</function> function need only be provided if the access method supports <quote>bitmap</quote> index scans. If it doesn't, the <structfield>amgetbitmap</structfield> field in its <structname>pg_am</structname> row must be set to zero."
msgstr ""

#: /tmp/cicero-ZVyl/indexam.xml:428(programlisting) 
#, no-wrap
msgid "\nvoid\namendscan (IndexScanDesc scan);\n"
msgstr ""

#: /tmp/cicero-ZVyl/indexam.xml:427(para) 
msgid "<placeholder-1/> End a scan and release resources. The <literal>scan</literal> struct itself should not be freed, but any locks or pins taken internally by the access method must be released."
msgstr ""

#: /tmp/cicero-ZVyl/indexam.xml:438(programlisting) 
#, no-wrap
msgid "\nvoid\nammarkpos (IndexScanDesc scan);\n"
msgstr ""

#: /tmp/cicero-ZVyl/indexam.xml:437(para) 
msgid "<placeholder-1/> Mark current scan position. The access method need only support one remembered scan position per scan."
msgstr ""

#: /tmp/cicero-ZVyl/indexam.xml:447(programlisting) 
#, no-wrap
msgid "\nvoid\namrestrpos (IndexScanDesc scan);\n"
msgstr ""

#: /tmp/cicero-ZVyl/indexam.xml:446(para) 
msgid "<placeholder-1/> Restore the scan to the most recently marked position."
msgstr ""

#: /tmp/cicero-ZVyl/indexam.xml:454(para) 
msgid "By convention, the <literal>pg_proc</literal> entry for an index access method function should show the correct number of arguments, but declare them all as type <type>internal</type> (since most of the arguments have types that are not known to SQL, and we don't want users calling the functions directly anyway). The return type is declared as <type>void</type>, <type>internal</type>, or <type>boolean</type> as appropriate. The only exception is <function>amoptions</function>, which should be correctly declared as taking <type>text[]</type> and <type>bool</type> and returning <type>bytea</type>. This provision allows client code to execute <function>amoptions</function> to test validity of options settings."
msgstr ""

#: /tmp/cicero-ZVyl/indexam.xml:470(title) 
msgid "Index Scanning"
msgstr ""

#: /tmp/cicero-ZVyl/indexam.xml:472(para) 
msgid "In an index scan, the index access method is responsible for regurgitating the TIDs of all the tuples it has been told about that match the <firstterm>scan keys</firstterm>. The access method is <emphasis>not</emphasis> involved in actually fetching those tuples from the index's parent table, nor in determining whether they pass the scan's time qualification test or other conditions."
msgstr ""

#: /tmp/cicero-ZVyl/indexam.xml:481(para) 
msgid "A scan key is the internal representation of a <literal>WHERE</literal> clause of the form <replaceable>index_key</replaceable><replaceable>operator</replaceable><replaceable>constant</replaceable>, where the index key is one of the columns of the index and the operator is one of the members of the operator family associated with that index column. An index scan has zero or more scan keys, which are implicitly ANDed â€” the returned tuples are expected to satisfy all the indicated conditions."
msgstr ""

#: /tmp/cicero-ZVyl/indexam.xml:491(para) 
msgid "The access method can report that the index is <firstterm>lossy</firstterm>, or requires rechecks, for a particular query. This implies that the index scan will return all the entries that pass the scan key, plus possibly additional entries that do not. The core system's index-scan machinery will then apply the index conditions again to the heap tuple to verify whether or not it really should be selected. If the recheck option is not specified, the index scan must return exactly the set of matching entries."
msgstr ""

#: /tmp/cicero-ZVyl/indexam.xml:501(para) 
msgid "Note that it is entirely up to the access method to ensure that it correctly finds all and only the entries passing all the given scan keys. Also, the core system will simply hand off all the <literal>WHERE</literal> clauses that match the index keys and operator families, without any semantic analysis to determine whether they are redundant or contradictory. As an example, given <literal>WHERE x &gt; 4 AND x &gt; 14</literal> where <literal>x</literal> is a b-tree indexed column, it is left to the b-tree <function>amrescan</function> function to realize that the first scan key is redundant and can be discarded. The extent of preprocessing needed during <function>amrescan</function> will depend on the extent to which the index access method needs to reduce the scan keys to a <quote>normalized</quote> form."
msgstr ""

#: /tmp/cicero-ZVyl/indexam.xml:523(para) 
msgid "Access methods that always return entries in the natural ordering of their data (such as btree) should set <structname>pg_am</structname>.<structfield>amcanorder</structfield> to true. Currently, such access methods must use btree-compatible strategy numbers for their equality and ordering operators."
msgstr ""

#: /tmp/cicero-ZVyl/indexam.xml:532(para) 
msgid "Access methods that support ordering operators should set <structname>pg_am</structname>.<structfield>amcanorderbyop</structfield> to true. This indicates that the index is capable of returning entries in an order satisfying <literal>ORDER BY</literal><replaceable>index_key</replaceable><replaceable>operator</replaceable><replaceable>constant</replaceable>. Scan modifiers of that form can be passed to <function>amrescan</function> as described previously."
msgstr ""

#: /tmp/cicero-ZVyl/indexam.xml:516(para) 
msgid "Some access methods return index entries in a well-defined order, others do not. There are actually two different ways that an access method can support sorted output: <placeholder-1/>"
msgstr ""

#: /tmp/cicero-ZVyl/indexam.xml:545(para) 
msgid "The <function>amgettuple</function> function has a <literal>direction</literal> argument, which can be either <literal>ForwardScanDirection</literal> (the normal case) or <literal>BackwardScanDirection</literal>. If the first call after <function>amrescan</function> specifies <literal>BackwardScanDirection</literal>, then the set of matching index entries is to be scanned back-to-front rather than in the normal front-to-back direction, so <function>amgettuple</function> must return the last matching tuple in the index, rather than the first one as it normally would. (This will only occur for access methods that set <structfield>amcanorder</structfield> to true.) After the first call, <function>amgettuple</function> must be prepared to advance the scan in either direction from the most recently returned entry. (But if <structname>pg_am</structname>.<structfield>amcanbackward</structfield> is false, all subsequent calls will have the same direction as the first one.)"
msgstr ""

#: /tmp/cicero-ZVyl/indexam.xml:561(para) 
msgid "Access methods that support ordered scans must support <quote>marking</quote> a position in a scan and later returning to the marked position. The same position might be restored multiple times. However, only one position need be remembered per scan; a new <function>ammarkpos</function> call overrides the previously marked position. An access method that does not support ordered scans should still provide mark and restore functions in <structname>pg_am</structname>, but it is sufficient to have them throw errors if called."
msgstr ""

#: /tmp/cicero-ZVyl/indexam.xml:572(para) 
msgid "Both the scan position and the mark position (if any) must be maintained consistently in the face of concurrent insertions or deletions in the index. It is OK if a freshly-inserted entry is not returned by a scan that would have found the entry if it had existed when the scan started, or for the scan to return such an entry upon rescanning or backing up even though it had not been returned the first time through. Similarly, a concurrent delete might or might not be reflected in the results of a scan. What is important is that insertions or deletions not cause the scan to miss or multiply return entries that were not themselves being inserted or deleted."
msgstr ""

#: /tmp/cicero-ZVyl/indexam.xml:585(para) 
msgid "Instead of using <function>amgettuple</function>, an index scan can be done with <function>amgetbitmap</function> to fetch all tuples in one call. This can be noticeably more efficient than <function>amgettuple</function> because it allows avoiding lock/unlock cycles within the access method. In principle <function>amgetbitmap</function> should have the same effects as repeated <function>amgettuple</function> calls, but we impose several restrictions to simplify matters. First of all, <function>amgetbitmap</function> returns all tuples at once and marking or restoring scan positions isn't supported. Secondly, the tuples are returned in a bitmap which doesn't have any specific ordering, which is why <function>amgetbitmap</function> doesn't take a <literal>direction</literal> argument. (Ordering operators will never be supplied for such a scan, either.) Finally, <function>amgetbitmap</function> does not guarantee any locking of the returned tuples, with implications spelled out in <xref linkend=\"index-locking\"/>."
msgstr ""

#: /tmp/cicero-ZVyl/indexam.xml:602(para) 
msgid "Note that it is permitted for an access method to implement only <function>amgetbitmap</function> and not <function>amgettuple</function>, or vice versa, if its internal implementation is unsuited to one API or the other."
msgstr ""

#: /tmp/cicero-ZVyl/indexam.xml:611(title) 
msgid "Index Locking Considerations"
msgstr ""

#: /tmp/cicero-ZVyl/indexam.xml:613(para) 
msgid "Index access methods must handle concurrent updates of the index by multiple processes. The core <productname>PostgreSQL</productname> system obtains <literal>AccessShareLock</literal> on the index during an index scan, and <literal>RowExclusiveLock</literal> when updating the index (including plain <command>VACUUM</command>). Since these lock types do not conflict, the access method is responsible for handling any fine-grained locking it might need. An exclusive lock on the index as a whole will be taken only during index creation, destruction, or <command>REINDEX</command>."
msgstr ""

#: /tmp/cicero-ZVyl/indexam.xml:625(para) 
msgid "Building an index type that supports concurrent updates usually requires extensive and subtle analysis of the required behavior. For the b-tree and hash index types, you can read about the design decisions involved in <filename>src/backend/access/nbtree/README</filename> and <filename>src/backend/access/hash/README</filename>."
msgstr ""

#: /tmp/cicero-ZVyl/indexam.xml:644(para) 
msgid "A new heap entry is made before making its index entries. (Therefore a concurrent index scan is likely to fail to see the heap entry. This is okay because the index reader would be uninterested in an uncommitted row anyway. But see <xref linkend=\"index-unique-checks\"/>.)"
msgstr ""

#: /tmp/cicero-ZVyl/indexam.xml:652(para) 
msgid "When a heap entry is to be deleted (by <command>VACUUM</command>), all its index entries must be removed first."
msgstr ""

#: /tmp/cicero-ZVyl/indexam.xml:658(para) 
msgid "An index scan must maintain a pin on the index page holding the item last returned by <function>amgettuple</function>, and <function>ambulkdelete</function> cannot delete entries from pages that are pinned by other backends. The need for this rule is explained below."
msgstr ""

#: /tmp/cicero-ZVyl/indexam.xml:633(para) 
msgid "Aside from the index's own internal consistency requirements, concurrent updates create issues about consistency between the parent table (the <firstterm>heap</firstterm>) and the index. Because <productname>PostgreSQL</productname> separates accesses and updates of the heap from those of the index, there are windows in which the index might be inconsistent with the heap. We handle this problem with the following rules: <placeholder-1/> Without the third rule, it is possible for an index reader to see an index entry just before it is removed by <command>VACUUM</command>, and then to arrive at the corresponding heap entry after that was removed by <command>VACUUM</command>. This creates no serious problems if that item number is still unused when the reader reaches it, since an empty item slot will be ignored by <function>heap_fetch()</function>. But what if a third backend has already re-used the item slot for something else? When using an MVCC-compliant snapshot, there is no problem because the new occupant of the slot is certain to be too new to pass the snapshot test. However, with a non-MVCC-compliant snapshot (such as <literal>SnapshotNow</literal>), it would be possible to accept and return a row that does not in fact match the scan keys. We could defend against this scenario by requiring the scan keys to be rechecked against the heap row in all cases, but that is too expensive. Instead, we use a pin on an index page as a proxy to indicate that the reader might still be <quote>in flight</quote> from the index entry to the matching heap entry. Making <function>ambulkdelete</function> block on such a pin ensures that <command>VACUUM</command> cannot delete the heap entry before the reader is done with it. This solution costs little in run time, and adds blocking overhead only in the rare cases where there actually is a conflict."
msgstr ""

#: /tmp/cicero-ZVyl/indexam.xml:691(para) 
msgid "This solution requires that index scans be <quote>synchronous</quote>: we have to fetch each heap tuple immediately after scanning the corresponding index entry. This is expensive for a number of reasons. An <quote>asynchronous</quote> scan in which we collect many TIDs from the index, and only visit the heap tuples sometime later, requires much less index locking overhead and can allow a more efficient heap access pattern. Per the above analysis, we must use the synchronous approach for non-MVCC-compliant snapshots, but an asynchronous scan is workable for a query using an MVCC snapshot."
msgstr ""

#: /tmp/cicero-ZVyl/indexam.xml:703(para) 
msgid "In an <function>amgetbitmap</function> index scan, the access method does not keep an index pin on any of the returned tuples. Therefore it is only safe to use such scans with MVCC-compliant snapshots."
msgstr ""

#: /tmp/cicero-ZVyl/indexam.xml:709(para) 
msgid "When the <structfield>ampredlocks</structfield> flag is not set, any scan using that index access method within a serializable transaction will acquire a non-blocking predicate lock on the full index. This will generate a read-write conflict with the insert of any tuple into that index by a concurrent serializable transaction. If certain patterns of read-write conflicts are detected among a set of concurrent serializable transactions, one of those transactions may be canceled to protect data integrity. When the flag is set, it indicates that the index access method implements finer-grained predicate locking, which will tend to reduce the frequency of such transaction cancellations."
msgstr ""

#: /tmp/cicero-ZVyl/indexam.xml:725(title) 
msgid "Index Uniqueness Checks"
msgstr ""

#: /tmp/cicero-ZVyl/indexam.xml:727(para) 
msgid "<productname>PostgreSQL</productname> enforces SQL uniqueness constraints using <firstterm>unique indexes</firstterm>, which are indexes that disallow multiple entries with identical keys. An access method that supports this feature sets <structname>pg_am</structname>.<structfield>amcanunique</structfield> true. (At present, only b-tree supports it.)"
msgstr ""

#: /tmp/cicero-ZVyl/indexam.xml:745(para) 
msgid "If a conflicting valid row has been deleted by the current transaction, it's okay. (In particular, since an UPDATE always deletes the old row version before inserting the new version, this will allow an UPDATE on a row without changing the key.)"
msgstr ""

#: /tmp/cicero-ZVyl/indexam.xml:753(para) 
msgid "If a conflicting row has been inserted by an as-yet-uncommitted transaction, the would-be inserter must wait to see if that transaction commits. If it rolls back then there is no conflict. If it commits without deleting the conflicting row again, there is a uniqueness violation. (In practice we just wait for the other transaction to end and then redo the visibility check in toto.)"
msgstr ""

#: /tmp/cicero-ZVyl/indexam.xml:763(para) 
msgid "Similarly, if a conflicting valid row has been deleted by an as-yet-uncommitted transaction, the would-be inserter must wait for that transaction to commit or abort, and then repeat the test."
msgstr ""

#: /tmp/cicero-ZVyl/indexam.xml:735(para) 
msgid "Because of MVCC, it is always necessary to allow duplicate entries to exist physically in an index: the entries might refer to successive versions of a single logical row. The behavior we actually want to enforce is that no MVCC snapshot could include two rows with equal index keys. This breaks down into the following cases that must be checked when inserting a new row into a unique index: <placeholder-1/>"
msgstr ""

#: /tmp/cicero-ZVyl/indexam.xml:772(para) 
msgid "Furthermore, immediately before reporting a uniqueness violation according to the above rules, the access method must recheck the liveness of the row being inserted. If it is committed dead then no violation should be reported. (This case cannot occur during the ordinary scenario of inserting a row that's just been created by the current transaction. It can happen during <command>CREATE UNIQUE INDEX CONCURRENTLY</command>, however.)"
msgstr ""

#: /tmp/cicero-ZVyl/indexam.xml:782(para) 
msgid "We require the index access method to apply these tests itself, which means that it must reach into the heap to check the commit status of any row that is shown to have a duplicate key according to the index contents. This is without a doubt ugly and non-modular, but it saves redundant work: if we did a separate probe then the index lookup for a conflicting row would be essentially repeated while finding the place to insert the new row's index entry. What's more, there is no obvious way to avoid race conditions unless the conflict check is an integral part of insertion of the new index entry."
msgstr ""

#: /tmp/cicero-ZVyl/indexam.xml:811(para) 
msgid "<literal>UNIQUE_CHECK_NO</literal> indicates that no uniqueness checking should be done (this is not a unique index)."
msgstr ""

#: /tmp/cicero-ZVyl/indexam.xml:817(para) 
msgid "<literal>UNIQUE_CHECK_YES</literal> indicates that this is a non-deferrable unique index, and the uniqueness check must be done immediately, as described above."
msgstr ""

#: /tmp/cicero-ZVyl/indexam.xml:824(para) 
msgid "<literal>UNIQUE_CHECK_PARTIAL</literal> indicates that the unique constraint is deferrable. <productname>PostgreSQL</productname> will use this mode to insert each row's index entry. The access method must allow duplicate entries into the index, and report any potential duplicates by returning FALSE from <function>aminsert</function>. For each row for which FALSE is returned, a deferred recheck will be scheduled."
msgstr ""

#: /tmp/cicero-ZVyl/indexam.xml:834(para) 
msgid "The access method must identify any rows which might violate the unique constraint, but it is not an error for it to report false positives. This allows the check to be done without waiting for other transactions to finish; conflicts reported here are not treated as errors and will be rechecked later, by which time they may no longer be conflicts."
msgstr ""

#: /tmp/cicero-ZVyl/indexam.xml:844(para) 
msgid "<literal>UNIQUE_CHECK_EXISTING</literal> indicates that this is a deferred recheck of a row that was reported as a potential uniqueness violation. Although this is implemented by calling <function>aminsert</function>, the access method must <emphasis>not</emphasis> insert a new index entry in this case. The index entry is already present. Rather, the access method must check to see if there is another live index entry. If so, and if the target row is also still live, report error."
msgstr ""

#: /tmp/cicero-ZVyl/indexam.xml:854(para) 
msgid "It is recommended that in a <literal>UNIQUE_CHECK_EXISTING</literal> call, the access method further verify that the target row actually does have an existing entry in the index, and report error if not. This is a good idea because the index tuple values passed to <function>aminsert</function> will have been recomputed. If the index definition involves functions that are not really immutable, we might be checking the wrong area of the index. Checking that the target row is found in the recheck verifies that we are scanning for the same tuple values as were used in the original insertion."
msgstr ""

#: /tmp/cicero-ZVyl/indexam.xml:794(para) 
msgid "If the unique constraint is deferrable, there is additional complexity: we need to be able to insert an index entry for a new row, but defer any uniqueness-violation error until end of statement or even later. To avoid unnecessary repeat searches of the index, the index access method should do a preliminary uniqueness check during the initial insertion. If this shows that there is definitely no conflicting live tuple, we are done. Otherwise, we schedule a recheck to occur when it is time to enforce the constraint. If, at the time of the recheck, both the inserted tuple and some other tuple with the same key are live, then the error must be reported. (Note that for this purpose, <quote>live</quote> actually means <quote>any tuple in the index entry's HOT chain is live</quote>.) To implement this, the <function>aminsert</function> function is passed a <literal>checkUnique</literal> parameter having one of the following values: <placeholder-1/>"
msgstr ""

#: /tmp/cicero-ZVyl/indexam.xml:872(title) 
msgid "Index Cost Estimation Functions"
msgstr ""

#: /tmp/cicero-ZVyl/indexam.xml:874(para) 
msgid "The <function>amcostestimate</function> function is given information describing a possible index scan, including lists of WHERE and ORDER BY clauses that have been determined to be usable with the index. It must return estimates of the cost of accessing the index and the selectivity of the WHERE clauses (that is, the fraction of parent-table rows that will be retrieved during the index scan). For simple cases, nearly all the work of the cost estimator can be done by calling standard routines in the optimizer; the point of having an <function>amcostestimate</function> function is to allow index access methods to provide index-type-specific knowledge, in case it is possible to improve on the standard estimates."
msgstr ""

#: /tmp/cicero-ZVyl/indexam.xml:907(parameter) 
msgid "root"
msgstr ""

#: /tmp/cicero-ZVyl/indexam.xml:909(para) 
msgid "The planner's information about the query being processed."
msgstr ""

#: /tmp/cicero-ZVyl/indexam.xml:916(parameter) 
msgid "index"
msgstr ""

#: /tmp/cicero-ZVyl/indexam.xml:918(para) 
msgid "The index being considered."
msgstr ""

#: /tmp/cicero-ZVyl/indexam.xml:925(parameter) 
msgid "indexQuals"
msgstr ""

#: /tmp/cicero-ZVyl/indexam.xml:927(para) 
msgid "List of index qual clauses (implicitly ANDed); a <symbol>NIL</symbol> list indicates no qualifiers are available. Note that the list contains expression trees with RestrictInfo nodes at the top, not ScanKeys."
msgstr ""

#: /tmp/cicero-ZVyl/indexam.xml:937(parameter) 
msgid "indexOrderBys"
msgstr ""

#: /tmp/cicero-ZVyl/indexam.xml:939(para) 
msgid "List of indexable ORDER BY operators, or <symbol>NIL</symbol> if none. Note that the list contains expression trees, not ScanKeys."
msgstr ""

#: /tmp/cicero-ZVyl/indexam.xml:947(parameter) 
msgid "outer_rel"
msgstr ""

#: /tmp/cicero-ZVyl/indexam.xml:949(para) 
msgid "If the index is being considered for use in a join inner indexscan, the planner's information about the outer side of the join. Otherwise <symbol>NULL</symbol>. When non-<symbol>NULL</symbol>, some of the qual clauses will be join clauses with this rel rather than being simple restriction clauses. Also, the cost estimator should expect that the index scan will be repeated for each row of the outer rel."
msgstr ""

#: /tmp/cicero-ZVyl/indexam.xml:887(para) 
msgid "Each <function>amcostestimate</function> function must have the signature: <placeholder-1/> The first five parameters are inputs: <placeholder-2/>"
msgstr ""

#: /tmp/cicero-ZVyl/indexam.xml:967(parameter) 
msgid "*indexStartupCost"
msgstr ""

#: /tmp/cicero-ZVyl/indexam.xml:969(para) 
msgid "Set to cost of index start-up processing"
msgstr ""

#: /tmp/cicero-ZVyl/indexam.xml:976(parameter) 
msgid "*indexTotalCost"
msgstr ""

#: /tmp/cicero-ZVyl/indexam.xml:978(para) 
msgid "Set to total cost of index processing"
msgstr ""

#: /tmp/cicero-ZVyl/indexam.xml:985(parameter) 
msgid "*indexSelectivity"
msgstr ""

#: /tmp/cicero-ZVyl/indexam.xml:987(para) 
msgid "Set to index selectivity"
msgstr ""

#: /tmp/cicero-ZVyl/indexam.xml:994(parameter) 
msgid "*indexCorrelation"
msgstr ""

#: /tmp/cicero-ZVyl/indexam.xml:996(para) 
msgid "Set to correlation coefficient between index scan order and underlying table's order"
msgstr ""

#: /tmp/cicero-ZVyl/indexam.xml:962(para) 
msgid "The last four parameters are pass-by-reference outputs: <placeholder-1/>"
msgstr ""

#: /tmp/cicero-ZVyl/indexam.xml:1005(para) 
msgid "Note that cost estimate functions must be written in C, not in SQL or any available procedural language, because they must access internal data structures of the planner/optimizer."
msgstr ""

#: /tmp/cicero-ZVyl/indexam.xml:1011(para) 
msgid "The index access costs should be computed using the parameters used by <filename>src/backend/optimizer/path/costsize.c</filename>: a sequential disk block fetch has cost <varname>seq_page_cost</varname>, a nonsequential fetch has cost <varname>random_page_cost</varname>, and the cost of processing one index row should usually be taken as <varname>cpu_index_tuple_cost</varname>. In addition, an appropriate multiple of <varname>cpu_operator_cost</varname> should be charged for any comparison operators invoked during index processing (especially evaluation of the <literal>indexQuals</literal> themselves)."
msgstr ""

#: /tmp/cicero-ZVyl/indexam.xml:1022(para) 
msgid "The access costs should include all disk and CPU costs associated with scanning the index itself, but <emphasis>not</emphasis> the costs of retrieving or processing the parent-table rows that are identified by the index."
msgstr ""

#: /tmp/cicero-ZVyl/indexam.xml:1028(para) 
msgid "The <quote>start-up cost</quote> is the part of the total scan cost that must be expended before we can begin to fetch the first row. For most indexes this can be taken as zero, but an index type with a high start-up cost might want to set it nonzero."
msgstr ""

#: /tmp/cicero-ZVyl/indexam.xml:1035(para) 
msgid "The <parameter>indexSelectivity</parameter> should be set to the estimated fraction of the parent table rows that will be retrieved during the index scan. In the case of a lossy query, this will typically be higher than the fraction of rows that actually pass the given qual conditions."
msgstr ""

#: /tmp/cicero-ZVyl/indexam.xml:1042(para) 
msgid "The <parameter>indexCorrelation</parameter> should be set to the correlation (ranging between -1.0 and 1.0) between the index order and the table order. This is used to adjust the estimate for the cost of fetching rows from the parent table."
msgstr ""

#: /tmp/cicero-ZVyl/indexam.xml:1049(para) 
msgid "In the join case, the returned numbers should be averages expected for any one scan of the index."
msgstr ""

#: /tmp/cicero-ZVyl/indexam.xml:1055(title) 
msgid "Cost Estimation"
msgstr ""

#: /tmp/cicero-ZVyl/indexam.xml:1056(para) 
msgid "A typical cost estimator will proceed as follows:"
msgstr ""

#: /tmp/cicero-ZVyl/indexam.xml:1066(programlisting) 
#, no-wrap
msgid "\n*indexSelectivity = clauselist_selectivity(root, indexQuals,\n                                           index-&gt;rel-&gt;relid,\n                                           JOIN_INNER, NULL);\n"
msgstr ""

#: /tmp/cicero-ZVyl/indexam.xml:1061(para) 
msgid "Estimate and return the fraction of parent-table rows that will be visited based on the given qual conditions. In the absence of any index-type-specific knowledge, use the standard optimizer function <function>clauselist_selectivity()</function>: <placeholder-1/>"
msgstr ""

#: /tmp/cicero-ZVyl/indexam.xml:1075(para) 
msgid "Estimate the number of index rows that will be visited during the scan. For many index types this is the same as <parameter>indexSelectivity</parameter> times the number of rows in the index, but it might be more. (Note that the index's size in pages and rows is available from the <structname>IndexOptInfo</structname> struct.)"
msgstr ""

#: /tmp/cicero-ZVyl/indexam.xml:1084(para) 
msgid "Estimate the number of index pages that will be retrieved during the scan. This might be just <parameter>indexSelectivity</parameter> times the index's size in pages."
msgstr ""

#: /tmp/cicero-ZVyl/indexam.xml:1094(programlisting) 
#, no-wrap
msgid "\n/*\n * Our generic assumption is that the index pages will be read\n * sequentially, so they cost seq_page_cost each, not random_page_cost.\n * Also, we charge for evaluation of the indexquals at each index row.\n * All the costs are assumed to be paid incrementally during the scan.\n */\ncost_qual_eval(&amp;index_qual_cost, indexQuals, root);\n*indexStartupCost = index_qual_cost.startup;\n*indexTotalCost = seq_page_cost * numIndexPages +\n    (cpu_index_tuple_cost + index_qual_cost.per_tuple) * numIndexTuples;\n"
msgstr ""

#: /tmp/cicero-ZVyl/indexam.xml:1091(para) 
msgid "Compute the index access cost. A generic estimator might do this: <placeholder-1/> However, the above does not account for amortization of index reads across repeated index scans in the join case."
msgstr ""

#: /tmp/cicero-ZVyl/indexam.xml:1113(para) 
msgid "Estimate the index correlation. For a simple ordered index on a single field, this can be retrieved from pg_statistic. If the correlation is not known, the conservative estimate is zero (no correlation)."
msgstr ""

#: /tmp/cicero-ZVyl/indexam.xml:1121(para) 
msgid "Examples of cost estimator functions can be found in <filename>src/backend/utils/adt/selfuncs.c</filename>."
msgstr ""

#. Put one translator per line, in the form of NAME <EMAIL>, YEAR1, YEAR2.
#: /tmp/cicero-ZVyl/indexam.xml:0(None) 
msgid "translator-credits"
msgstr ""

