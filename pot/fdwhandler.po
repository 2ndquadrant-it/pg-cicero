msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2011-08-29 06:58+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: /tmp/cicero-qMnb/fdwhandler.xml:6(title) 
msgid "Writing A Foreign Data Wrapper"
msgstr ""

#: /tmp/cicero-qMnb/fdwhandler.xml:9(primary) 
msgid "foreign data wrapper"
msgstr ""

#: /tmp/cicero-qMnb/fdwhandler.xml:10(secondary) 
msgid "handler for"
msgstr ""

#: /tmp/cicero-qMnb/fdwhandler.xml:13(para) 
msgid "All operations on a foreign table are handled through its foreign data wrapper, which consists of a set of functions that the planner and executor call. The foreign data wrapper is responsible for fetching data from the remote data source and returning it to the <productname>PostgreSQL</productname> executor. This chapter outlines how to write a new foreign data wrapper."
msgstr ""

#: /tmp/cicero-qMnb/fdwhandler.xml:22(para) 
msgid "The foreign data wrappers included in the standard distribution are good references when trying to write your own. Look into the <filename>contrib/file_fdw</filename> subdirectory of the source tree. The <xref linkend=\"sql-createforeigndatawrapper\"/> reference page also has some useful details."
msgstr ""

#: /tmp/cicero-qMnb/fdwhandler.xml:31(para) 
msgid "The SQL standard specifies an interface for writing foreign data wrappers. However, PostgreSQL does not implement that API, because the effort to accommodate it into PostgreSQL would be large, and the standard API hasn't gained wide adoption anyway."
msgstr ""

#: /tmp/cicero-qMnb/fdwhandler.xml:40(title) 
msgid "Foreign Data Wrapper Functions"
msgstr ""

#: /tmp/cicero-qMnb/fdwhandler.xml:42(para) 
msgid "The FDW author needs to implement a handler function, and optionally a validator function. Both functions must be written in a compiled language such as C, using the version-1 interface. For details on C language calling conventions and dynamic loading, see <xref linkend=\"xfunc-c\"/>."
msgstr ""

#: /tmp/cicero-qMnb/fdwhandler.xml:50(para) 
msgid "The handler function simply returns a struct of function pointers to callback functions that will be called by the planner and executor. Most of the effort in writing an FDW is in implementing these callback functions. The handler function must be registered with <productname>PostgreSQL</productname> as taking no arguments and returning the special pseudo-type <type>fdw_handler</type>. The callback functions are plain C functions and are not visible or callable at the SQL level. The callback functions are described in <xref linkend=\"fdw-callbacks\"/>."
msgstr ""

#: /tmp/cicero-qMnb/fdwhandler.xml:63(para) 
msgid "The validator function is responsible for validating options given in <command>CREATE</command> and <command>ALTER</command> commands for its foreign data wrapper, as well as foreign servers, user mappings, and foreign tables using the wrapper. The validator function must be registered as taking two arguments, a text array containing the options to be validated, and an OID representing the type of object the options are associated with (in the form of the OID of the system catalog the object would be stored in, either <literal>ForeignDataWrapperRelationId</literal>, <literal>ForeignServerRelationId</literal>, <literal>UserMappingRelationId</literal>, or <literal>ForeignTableRelationId</literal>). If no validator function is supplied, options are not checked at object creation time or object alteration time."
msgstr ""

#: /tmp/cicero-qMnb/fdwhandler.xml:84(title) 
msgid "Foreign Data Wrapper Callback Routines"
msgstr ""

#: /tmp/cicero-qMnb/fdwhandler.xml:86(para) 
msgid "The FDW handler function returns a palloc'd <structname>FdwRoutine</structname> struct containing pointers to the following callback functions:"
msgstr ""

#: /tmp/cicero-qMnb/fdwhandler.xml:92(programlisting) 
#, no-wrap
msgid "\nFdwPlan *\nPlanForeignScan (Oid foreigntableid,\n                 PlannerInfo *root,\n                 RelOptInfo *baserel);\n"
msgstr ""

#: /tmp/cicero-qMnb/fdwhandler.xml:91(para) 
msgid "<placeholder-1/> Plan a scan on a foreign table. This is called when a query is planned. <literal>foreigntableid</literal> is the <structname>pg_class</structname> OID of the foreign table. <literal>root</literal> is the planner's global information about the query, and <literal>baserel</literal> is the planner's information about this table. The function must return a palloc'd struct that contains cost estimates plus any FDW-private information that is needed to execute the foreign scan at a later time. (Note that the private information must be represented in a form that <function>copyObject</function> knows how to copy.)"
msgstr ""

#: /tmp/cicero-qMnb/fdwhandler.xml:110(para) 
msgid "The information in <literal>root</literal> and <literal>baserel</literal> can be used to reduce the amount of information that has to be fetched from the foreign table (and therefore reduce the cost estimate). <literal>baserel-&gt;baserestrictinfo</literal> is particularly interesting, as it contains restriction quals (<literal>WHERE</literal> clauses) that can be used to filter the rows to be fetched. (The FDW is not required to enforce these quals, as the finished plan will recheck them anyway.) <literal>baserel-&gt;reltargetlist</literal> can be used to determine which columns need to be fetched."
msgstr ""

#: /tmp/cicero-qMnb/fdwhandler.xml:122(para) 
msgid "In addition to returning cost estimates, the function should update <literal>baserel-&gt;rows</literal> to be the expected number of rows returned by the scan, after accounting for the filtering done by the restriction quals. The initial value of <literal>baserel-&gt;rows</literal> is just a constant default estimate, which should be replaced if at all possible. The function may also choose to update <literal>baserel-&gt;width</literal> if it can compute a better estimate of the average result row width."
msgstr ""

#: /tmp/cicero-qMnb/fdwhandler.xml:133(programlisting) 
#, no-wrap
msgid "\nvoid\nExplainForeignScan (ForeignScanState *node,\n                    ExplainState *es);\n"
msgstr ""

#: /tmp/cicero-qMnb/fdwhandler.xml:132(para) 
msgid "<placeholder-1/> Print additional <command>EXPLAIN</command> output for a foreign table scan. This can just return if there is no need to print anything. Otherwise, it should call <function>ExplainPropertyText</function> and related functions to add fields to the <command>EXPLAIN</command> output. The flag fields in <literal>es</literal> can be used to determine what to print, and the state of the <structname>ForeignScanState</structname> node can be inspected to provide runtime statistics in the <command>EXPLAIN ANALYZE</command> case."
msgstr ""

#: /tmp/cicero-qMnb/fdwhandler.xml:150(programlisting) 
#, no-wrap
msgid "\nvoid\nBeginForeignScan (ForeignScanState *node,\n                  int eflags);\n"
msgstr ""

#: /tmp/cicero-qMnb/fdwhandler.xml:149(para) 
msgid "<placeholder-1/> Begin executing a foreign scan. This is called during executor startup. It should perform any initialization needed before the scan can start, but not start executing the actual scan (that should be done upon the first call to <function>IterateForeignScan</function>). The <structname>ForeignScanState</structname> node has already been created, but its <structfield>fdw_state</structfield> field is still NULL. Information about the table to scan is accessible through the <structname>ForeignScanState</structname> node (in particular, from the underlying <structname>ForeignScan</structname> plan node, which contains a pointer to the <structname>FdwPlan</structname> structure returned by <function>PlanForeignScan</function>)."
msgstr ""

#: /tmp/cicero-qMnb/fdwhandler.xml:169(para) 
msgid "Note that when <literal>(eflags &amp; EXEC_FLAG_EXPLAIN_ONLY)</literal> is true, this function should not perform any externally-visible actions; it should only do the minimum required to make the node state valid for <function>ExplainForeignScan</function> and <function>EndForeignScan</function>."
msgstr ""

#: /tmp/cicero-qMnb/fdwhandler.xml:177(programlisting) 
#, no-wrap
msgid "\nTupleTableSlot *\nIterateForeignScan (ForeignScanState *node);\n"
msgstr ""

#: /tmp/cicero-qMnb/fdwhandler.xml:176(para) 
msgid "<placeholder-1/> Fetch one row from the foreign source, returning it in a tuple table slot (the node's <structfield>ScanTupleSlot</structfield> should be used for this purpose). Return NULL if no more rows are available. The tuple table slot infrastructure allows either a physical or virtual tuple to be returned; in most cases the latter choice is preferable from a performance standpoint. Note that this is called in a short-lived memory context that will be reset between invocations. Create a memory context in <function>BeginForeignScan</function> if you need longer-lived storage, or use the <structfield>es_query_cxt</structfield> of the node's <structname>EState</structname>."
msgstr ""

#: /tmp/cicero-qMnb/fdwhandler.xml:193(para) 
msgid "The rows returned must match the column signature of the foreign table being scanned. If you choose to optimize away fetching columns that are not needed, you should insert nulls in those column positions."
msgstr ""

#: /tmp/cicero-qMnb/fdwhandler.xml:199(para) 
msgid "Note that <productname>PostgreSQL</productname>'s executor doesn't care whether the rows returned violate the <literal>NOT NULL</literal> constraints which were defined on the foreign table columns - but the planner does care, and may optimize queries incorrectly if <literal>NULL</literal> values are present in a column declared not to contain them. If a <literal>NULL</literal> value is encountered when the user has declared that none should be present, it may be appropriate to raise an error (just as you would need to do in the case of a data type mismatch)."
msgstr ""

#: /tmp/cicero-qMnb/fdwhandler.xml:211(programlisting) 
#, no-wrap
msgid "\nvoid\nReScanForeignScan (ForeignScanState *node);\n"
msgstr ""

#: /tmp/cicero-qMnb/fdwhandler.xml:210(para) 
msgid "<placeholder-1/> Restart the scan from the beginning. Note that any parameters the scan depends on may have changed value, so the new scan does not necessarily return exactly the same rows."
msgstr ""

#: /tmp/cicero-qMnb/fdwhandler.xml:222(programlisting) 
#, no-wrap
msgid "\nvoid\nEndForeignScan (ForeignScanState *node);\n"
msgstr ""

#: /tmp/cicero-qMnb/fdwhandler.xml:221(para) 
msgid "<placeholder-1/> End the scan and release resources. It is normally not important to release palloc'd memory, but for example open files and connections to remote servers should be cleaned up."
msgstr ""

#: /tmp/cicero-qMnb/fdwhandler.xml:232(para) 
msgid "The <structname>FdwRoutine</structname> and <structname>FdwPlan</structname> struct types are declared in <filename>src/include/foreign/fdwapi.h</filename>, which see for additional details."
msgstr ""

#. Put one translator per line, in the form of NAME <EMAIL>, YEAR1, YEAR2.
#: /tmp/cicero-qMnb/fdwhandler.xml:0(None) 
msgid "translator-credits"
msgstr ""

