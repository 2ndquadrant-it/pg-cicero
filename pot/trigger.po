msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2011-05-26 12:12+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/trigger.xml:5(title)
msgid "Triggers"
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/trigger.xml:8(primary) /home/carloratm/progetti/postgresql-source/doc-9.0.4/trigger.xml:294(primary)
msgid "trigger"
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/trigger.xml:11(para)
msgid "This chapter provides general information about writing trigger functions. Trigger functions can be written in most of the available procedural languages, including <application>PL/pgSQL</application> (<xref linkend=\"plpgsql\"/>), <application>PL/Tcl</application> (<xref linkend=\"pltcl\"/>), <application>PL/Perl</application> (<xref linkend=\"plperl\"/>), and <application>PL/Python</application> (<xref linkend=\"plpython\"/>). After reading this chapter, you should consult the chapter for your favorite procedural language to find out the language-specific details of writing a trigger in it."
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/trigger.xml:24(para)
msgid "It is also possible to write a trigger function in C, although most people find it easier to use one of the procedural languages. It is not currently possible to write a trigger function in the plain SQL function language."
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/trigger.xml:32(title)
msgid "Overview of Trigger Behavior"
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/trigger.xml:34(para)
msgid "A trigger is a specification that the database should automatically execute a particular function whenever a certain type of operation is performed. Triggers can be defined to execute either before or after any <command>INSERT</command>, <command>UPDATE</command>, or <command>DELETE</command> operation, either once per modified row, or once per <acronym>SQL</acronym> statement. <command>UPDATE</command> triggers can moreover be set to fire only if certain columns are mentioned in the <literal>SET</literal> clause of the <command>UPDATE</command> statement. Triggers can also fire for <command>TRUNCATE</command> statements. If a trigger event occurs, the trigger's function is called at the appropriate time to handle the event."
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/trigger.xml:49(para)
msgid "The trigger function must be defined before the trigger itself can be created. The trigger function must be declared as a function taking no arguments and returning type <literal>trigger</literal>. (The trigger function receives its input through a specially-passed <structname>TriggerData</structname> structure, not in the form of ordinary function arguments.)"
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/trigger.xml:58(para)
msgid "Once a suitable trigger function has been created, the trigger is established with <xref linkend=\"sql-createtrigger\"/>. The same trigger function can be used for multiple triggers."
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/trigger.xml:65(para)
msgid "<productname>PostgreSQL</productname> offers both <firstterm>per-row</firstterm> triggers and <firstterm>per-statement</firstterm> triggers. With a per-row trigger, the trigger function is invoked once for each row that is affected by the statement that fired the trigger. In contrast, a per-statement trigger is invoked only once when an appropriate statement is executed, regardless of the number of rows affected by that statement. In particular, a statement that affects zero rows will still result in the execution of any applicable per-statement triggers. These two types of triggers are sometimes called <firstterm>row-level</firstterm> triggers and <firstterm>statement-level</firstterm> triggers, respectively. Triggers on <command>TRUNCATE</command> may only be defined at statement-level."
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/trigger.xml:81(para)
msgid "Triggers are also classified as <firstterm>before</firstterm> triggers and <firstterm>after</firstterm> triggers. Statement-level before triggers naturally fire before the statement starts to do anything, while statement-level after triggers fire at the very end of the statement. Row-level before triggers fire immediately before a particular row is operated on, while row-level after triggers fire at the end of the statement (but before any statement-level after triggers)."
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/trigger.xml:102(para)
msgid "It can return <symbol>NULL</symbol> to skip the operation for the current row. This instructs the executor to not perform the row-level operation that invoked the trigger (the insertion or modification of a particular table row)."
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/trigger.xml:111(para)
msgid "For row-level <command>INSERT</command> and <command>UPDATE</command> triggers only, the returned row becomes the row that will be inserted or will replace the row being updated. This allows the trigger function to modify the row being inserted or updated."
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/trigger.xml:92(para)
msgid "Trigger functions invoked by per-statement triggers should always return <symbol>NULL</symbol>. Trigger functions invoked by per-row triggers can return a table row (a value of type <structname>HeapTuple</structname>) to the calling executor, if they choose. A row-level trigger fired before an operation has the following choices: <placeholder-1/> A row-level before trigger that does not intend to cause either of these behaviors must be careful to return as its result the same row that was passed in (that is, the <varname>NEW</varname> row for <command>INSERT</command> and <command>UPDATE</command> triggers, the <varname>OLD</varname> row for <command>DELETE</command> triggers)."
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/trigger.xml:129(para)
msgid "The return value is ignored for row-level triggers fired after an operation, and so they can return <symbol>NULL</symbol>."
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/trigger.xml:134(para)
msgid "If more than one trigger is defined for the same event on the same relation, the triggers will be fired in alphabetical order by trigger name. In the case of before triggers, the possibly-modified row returned by each trigger becomes the input to the next trigger. If any before trigger returns <symbol>NULL</symbol>, the operation is abandoned for that row and subsequent triggers are not fired."
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/trigger.xml:144(para)
msgid "A trigger definition can also specify a Boolean <literal>WHEN</literal> condition, which will be tested to see whether the trigger should be fired. In row-level triggers the <literal>WHEN</literal> condition can examine the old and/or new values of columns of the row. (Statement-level triggers can also have <literal>WHEN</literal> conditions, although the feature is not so useful for them.) In a before trigger, the <literal>WHEN</literal> condition is evaluated just before the function is or would be executed, so using <literal>WHEN</literal> is not materially different from testing the same condition at the beginning of the trigger function. However, in an after trigger, the <literal>WHEN</literal> condition is evaluated just after the row update occurs, and it determines whether an event is queued to fire the trigger at the end of statement. So when an after trigger's <literal>WHEN</literal> condition does not return true, it is not necessary to queue an event nor to re-fetch the row at end of statement. This can result in significant speedups in statements that modify many rows, if the trigger only needs to be fired for a few of the rows."
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/trigger.xml:163(para)
msgid "Typically, row before triggers are used for checking or modifying the data that will be inserted or updated. For example, a before trigger might be used to insert the current time into a <type>timestamp</type> column, or to check that two elements of the row are consistent. Row after triggers are most sensibly used to propagate the updates to other tables, or make consistency checks against other tables. The reason for this division of labor is that an after trigger can be certain it is seeing the final value of the row, while a before trigger cannot; there might be other before triggers firing after it. If you have no specific reason to make a trigger before or after, the before case is more efficient, since the information about the operation doesn't have to be saved until end of statement."
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/trigger.xml:178(para)
msgid "If a trigger function executes SQL commands then these commands might fire triggers again. This is known as cascading triggers. There is no direct limitation on the number of cascade levels. It is possible for cascades to cause a recursive invocation of the same trigger; for example, an <command>INSERT</command> trigger might execute a command that inserts an additional row into the same table, causing the <command>INSERT</command> trigger to be fired again. It is the trigger programmer's responsibility to avoid infinite recursion in such scenarios."
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/trigger.xml:190(para)
msgid "When a trigger is being defined, arguments can be specified for it.<indexterm><primary>trigger</primary><secondary>arguments for trigger functions</secondary></indexterm> The purpose of including arguments in the trigger definition is to allow different triggers with similar requirements to call the same function. As an example, there could be a generalized trigger function that takes as its arguments two column names and puts the current user in one and the current time stamp in the other. Properly written, this trigger function would be independent of the specific table it is triggering on. So the same function could be used for <command>INSERT</command> events on any table with suitable columns, to automatically track creation of records in a transaction table for example. It could also be used to track last-update events if defined as an <command>UPDATE</command> trigger."
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/trigger.xml:208(para)
msgid "Each programming language that supports triggers has its own method for making the trigger input data available to the trigger function. This input data includes the type of trigger event (e.g., <command>INSERT</command> or <command>UPDATE</command>) as well as any arguments that were listed in <command>CREATE TRIGGER</command>. For a row-level trigger, the input data also includes the <varname>NEW</varname> row for <command>INSERT</command> and <command>UPDATE</command> triggers, and/or the <varname>OLD</varname> row for <command>UPDATE</command> and <command>DELETE</command> triggers. Statement-level triggers do not currently have any way to examine the individual row(s) modified by the statement."
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/trigger.xml:225(title)
msgid "Visibility of Data Changes"
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/trigger.xml:237(para)
msgid "Statement-level triggers follow simple visibility rules: none of the changes made by a statement are visible to statement-level triggers that are invoked before the statement, whereas all modifications are visible to statement-level after triggers."
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/trigger.xml:246(para)
msgid "The data change (insertion, update, or deletion) causing the trigger to fire is naturally <emphasis>not</emphasis> visible to SQL commands executed in a row-level before trigger, because it hasn't happened yet."
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/trigger.xml:255(para)
msgid "However, SQL commands executed in a row-level before trigger <emphasis>will</emphasis> see the effects of data changes for rows previously processed in the same outer command. This requires caution, since the ordering of these change events is not in general predictable; a SQL command that affects multiple rows can visit the rows in any order."
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/trigger.xml:266(para)
msgid "When a row-level after trigger is fired, all data changes made by the outer command are already complete, and are visible to the invoked trigger function."
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/trigger.xml:227(para)
msgid "If you execute SQL commands in your trigger function, and these commands access the table that the trigger is for, then you need to be aware of the data visibility rules, because they determine whether these SQL commands will see the data change that the trigger is fired for. Briefly: <placeholder-1/>"
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/trigger.xml:275(para)
msgid "If your trigger function is written in any of the standard procedural languages, then the above statements apply only if the function is declared <literal>VOLATILE</literal>. Functions that are declared <literal>STABLE</literal> or <literal>IMMUTABLE</literal> will not see changes made by the calling command in any case."
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/trigger.xml:283(para)
msgid "Further information about data visibility rules can be found in <xref linkend=\"spi-visibility\"/>. The example in <xref linkend=\"trigger-example\"/> contains a demonstration of these rules."
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/trigger.xml:291(title)
msgid "Writing Trigger Functions in C"
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/trigger.xml:295(secondary)
msgid "in C"
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/trigger.xml:298(para)
msgid "This section describes the low-level details of the interface to a trigger function. This information is only needed when writing trigger functions in C. If you are using a higher-level language then these details are handled for you. In most cases you should consider using a procedural language before writing your triggers in C. The documentation of each procedural language explains how to write a trigger in that language."
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/trigger.xml:308(para)
msgid "Trigger functions must use the <quote>version 1</quote> function manager interface."
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/trigger.xml:319(programlisting)
#, no-wrap
msgid "\nCALLED_AS_TRIGGER(fcinfo)\n"
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/trigger.xml:323(programlisting)
#, no-wrap
msgid "\n((fcinfo)-&gt;context != NULL &amp;&amp; IsA((fcinfo)-&gt;context, TriggerData))\n"
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/trigger.xml:313(para)
msgid "When a function is called by the trigger manager, it is not passed any normal arguments, but it is passed a <quote>context</quote> pointer pointing to a <structname>TriggerData</structname> structure. C functions can check whether they were called from the trigger manager or not by executing the macro: <placeholder-1/> which expands to: <placeholder-2/> If this returns true, then it is safe to cast <literal>fcinfo-&gt;context</literal> to type <literal>TriggerData *</literal> and make use of the pointed-to <structname>TriggerData</structname> structure. The function must <emphasis>not</emphasis> alter the <structname>TriggerData</structname> structure or any of the data it points to."
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/trigger.xml:338(programlisting)
#, no-wrap
msgid "\ntypedef struct TriggerData\n{\n    NodeTag       type;\n    TriggerEvent  tg_event;\n    Relation      tg_relation;\n    HeapTuple     tg_trigtuple;\n    HeapTuple     tg_newtuple;\n    Trigger      *tg_trigger;\n    Buffer        tg_trigtuplebuf;\n    Buffer        tg_newtuplebuf;\n} TriggerData;\n"
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/trigger.xml:356(structfield)
msgid "type"
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/trigger.xml:358(para)
msgid "Always <literal>T_TriggerData</literal>."
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/trigger.xml:365(structfield)
msgid "tg_event"
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/trigger.xml:373(literal)
msgid "TRIGGER_FIRED_BEFORE(tg_event)"
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/trigger.xml:375(para)
msgid "Returns true if the trigger fired before the operation."
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/trigger.xml:382(literal)
msgid "TRIGGER_FIRED_AFTER(tg_event)"
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/trigger.xml:384(para)
msgid "Returns true if the trigger fired after the operation."
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/trigger.xml:391(literal)
msgid "TRIGGER_FIRED_FOR_ROW(tg_event)"
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/trigger.xml:393(para)
msgid "Returns true if the trigger fired for a row-level event."
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/trigger.xml:400(literal)
msgid "TRIGGER_FIRED_FOR_STATEMENT(tg_event)"
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/trigger.xml:402(para)
msgid "Returns true if the trigger fired for a statement-level event."
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/trigger.xml:409(literal)
msgid "TRIGGER_FIRED_BY_INSERT(tg_event)"
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/trigger.xml:411(para)
msgid "Returns true if the trigger was fired by an <command>INSERT</command> command."
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/trigger.xml:418(literal)
msgid "TRIGGER_FIRED_BY_UPDATE(tg_event)"
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/trigger.xml:420(para)
msgid "Returns true if the trigger was fired by an <command>UPDATE</command> command."
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/trigger.xml:427(literal)
msgid "TRIGGER_FIRED_BY_DELETE(tg_event)"
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/trigger.xml:429(para)
msgid "Returns true if the trigger was fired by a <command>DELETE</command> command."
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/trigger.xml:436(literal)
msgid "TRIGGER_FIRED_BY_TRUNCATE(tg_event)"
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/trigger.xml:438(para)
msgid "Returns true if the trigger was fired by a <command>TRUNCATE</command> command."
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/trigger.xml:367(para)
msgid "Describes the event for which the function is called. You can use the following macros to examine <literal>tg_event</literal>: <placeholder-1/>"
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/trigger.xml:449(structfield)
msgid "tg_relation"
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/trigger.xml:451(para)
msgid "A pointer to a structure describing the relation that the trigger fired for. Look at <filename>utils/rel.h</filename> for details about this structure. The most interesting things are <literal>tg_relation-&gt;rd_att</literal> (descriptor of the relation tuples) and <literal>tg_relation-&gt;rd_rel-&gt;relname</literal> (relation name; the type is not <type>char*</type> but <type>NameData</type>; use <literal>SPI_getrelname(tg_relation)</literal> to get a <type>char*</type> if you need a copy of the name)."
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/trigger.xml:466(structfield)
msgid "tg_trigtuple"
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/trigger.xml:468(para)
msgid "A pointer to the row for which the trigger was fired. This is the row being inserted, updated, or deleted. If this trigger was fired for an <command>INSERT</command> or <command>DELETE</command> then this is what you should return from the function if you don't want to replace the row with a different one (in the case of <command>INSERT</command>) or skip the operation."
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/trigger.xml:481(structfield)
msgid "tg_newtuple"
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/trigger.xml:483(para)
msgid "A pointer to the new version of the row, if the trigger was fired for an <command>UPDATE</command>, and <symbol>NULL</symbol> if it is for an <command>INSERT</command> or a <command>DELETE</command>. This is what you have to return from the function if the event is an <command>UPDATE</command> and you don't want to replace this row by a different one or skip the operation."
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/trigger.xml:496(structfield)
msgid "tg_trigger"
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/trigger.xml:502(programlisting)
#, no-wrap
msgid "\ntypedef struct Trigger\n{\n    Oid         tgoid;\n    char       *tgname;\n    Oid         tgfoid;\n    int16       tgtype;\n    bool        tgenabled;\n    bool        tgisinternal;\n    Oid         tgconstrrelid;\n    Oid         tgconstrindid;\n    Oid         tgconstraint;\n    bool        tgdeferrable;\n    bool        tginitdeferred;\n    int16       tgnargs;\n    int16       tgnattr;\n    int16      *tgattr;\n    char      **tgargs;\n    char       *tgqual;\n} Trigger;\n"
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/trigger.xml:498(para)
msgid "A pointer to a structure of type <structname>Trigger</structname>, defined in <filename>utils/rel.h</filename>: <placeholder-1/> where <structfield>tgname</structfield> is the trigger's name, <structfield>tgnargs</structfield> is the number of arguments in <structfield>tgargs</structfield>, and <structfield>tgargs</structfield> is an array of pointers to the arguments specified in the <command>CREATE TRIGGER</command> statement. The other members are for internal use only."
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/trigger.xml:535(structfield)
msgid "tg_trigtuplebuf"
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/trigger.xml:537(para)
msgid "The buffer containing <structfield>tg_trigtuple</structfield>, or <symbol>InvalidBuffer</symbol> if there is no such tuple or it is not stored in a disk buffer."
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/trigger.xml:545(structfield)
msgid "tg_newtuplebuf"
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/trigger.xml:547(para)
msgid "The buffer containing <structfield>tg_newtuple</structfield>, or <symbol>InvalidBuffer</symbol> if there is no such tuple or it is not stored in a disk buffer."
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/trigger.xml:334(para)
msgid "<structname>struct TriggerData</structname> is defined in <filename>commands/trigger.h</filename>: <placeholder-1/> where the members are defined as follows: <placeholder-2/>"
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/trigger.xml:557(para)
msgid "A trigger function must return either a <structname>HeapTuple</structname> pointer or a <symbol>NULL</symbol> pointer (<emphasis>not</emphasis> an SQL null value, that is, do not set <parameter>isNull</parameter> true). Be careful to return either <structfield>tg_trigtuple</structfield> or <structfield>tg_newtuple</structfield>, as appropriate, if you don't want to modify the row being operated on."
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/trigger.xml:568(title)
msgid "A Complete Trigger Example"
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/trigger.xml:570(para)
msgid "Here is a very simple example of a trigger function written in C. (Examples of triggers written in procedural languages can be found in the documentation of the procedural languages.)"
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/trigger.xml:576(para)
msgid "The function <function>trigf</function> reports the number of rows in the table <structname>ttest</structname> and skips the actual operation if the command attempts to insert a null value into the column <structfield>x</structfield>. (So the trigger acts as a not-null constraint but doesn't abort the transaction.)"
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/trigger.xml:586(programlisting)
#, no-wrap
msgid "\nCREATE TABLE ttest (\n    x integer\n);\n"
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/trigger.xml:584(para)
msgid "First, the table definition: <placeholder-1/>"
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/trigger.xml:593(para)
msgid "This is the source code of the trigger function: <placeholder-1/>"
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/trigger.xml:676(programlisting)
#, no-wrap
msgid "\nCREATE FUNCTION trigf() RETURNS trigger\n    AS '<replaceable>filename</replaceable>'\n    LANGUAGE C;\n\nCREATE TRIGGER tbefore BEFORE INSERT OR UPDATE OR DELETE ON ttest\n    FOR EACH ROW EXECUTE PROCEDURE trigf();\n\nCREATE TRIGGER tafter AFTER INSERT OR UPDATE OR DELETE ON ttest\n    FOR EACH ROW EXECUTE PROCEDURE trigf();\n"
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/trigger.xml:673(para)
msgid "After you have compiled the source code (see <xref linkend=\"dfunc\"/>), declare the function and the triggers: <placeholder-1/>"
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/trigger.xml:689(para)
msgid "Now you can test the operation of the trigger: <screen>\n=&gt; INSERT INTO ttest VALUES (NULL);\nINFO:  trigf (fired before): there are 0 rows in ttest\nINSERT 0 0\n\n-- Insertion skipped and AFTER trigger is not fired\n\n=&gt; SELECT * FROM ttest;\n x\n---\n(0 rows)\n\n=&gt; INSERT INTO ttest VALUES (1);\nINFO:  trigf (fired before): there are 0 rows in ttest\nINFO:  trigf (fired after ): there are 1 rows in ttest\n                                       ^^^^^^^^\n                             remember what we said about visibility.\nINSERT 167793 1\nvac=&gt; SELECT * FROM ttest;\n x\n---\n 1\n(1 row)\n\n=&gt; INSERT INTO ttest SELECT x * 2 FROM ttest;\nINFO:  trigf (fired before): there are 1 rows in ttest\nINFO:  trigf (fired after ): there are 2 rows in ttest\n                                       ^^^^^^\n                             remember what we said about visibility.\nINSERT 167794 1\n=&gt; SELECT * FROM ttest;\n x\n---\n 1\n 2\n(2 rows)\n\n=&gt; UPDATE ttest SET x = NULL WHERE x = 2;\nINFO:  trigf (fired before): there are 2 rows in ttest\nUPDATE 0\n=&gt; UPDATE ttest SET x = 4 WHERE x = 2;\nINFO:  trigf (fired before): there are 2 rows in ttest\nINFO:  trigf (fired after ): there are 2 rows in ttest\nUPDATE 1\nvac=&gt; SELECT * FROM ttest;\n x\n---\n 1\n 4\n(2 rows)\n\n=&gt; DELETE FROM ttest;\nINFO:  trigf (fired before): there are 2 rows in ttest\nINFO:  trigf (fired before): there are 1 rows in ttest\nINFO:  trigf (fired after ): there are 0 rows in ttest\nINFO:  trigf (fired after ): there are 0 rows in ttest\n                                       ^^^^^^\n                             remember what we said about visibility.\nDELETE 2\n=&gt; SELECT * FROM ttest;\n x\n---\n(0 rows)\n</screen>"
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/trigger.xml:758(para)
msgid "There are more complex examples in <filename>src/test/regress/regress.c</filename> and in <filename>contrib/spi</filename>."
msgstr ""

#. Put one translator per line, in the form of NAME <EMAIL>, YEAR1, YEAR2
#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/trigger.xml:0(None)
msgid "translator-credits"
msgstr ""

