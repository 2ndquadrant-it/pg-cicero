msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2011-08-22 17:54+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: /tmp/cicero-lkRf/xfunc.xml:6(title) 
msgid "User-defined Functions"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:9(primary) /tmp/cicero-lkRf/xfunc.xml:81(primary) /tmp/cicero-lkRf/xfunc.xml:533(primary) /tmp/cicero-lkRf/xfunc.xml:566(primary) /tmp/cicero-lkRf/xfunc.xml:652(primary) /tmp/cicero-lkRf/xfunc.xml:734(primary) /tmp/cicero-lkRf/xfunc.xml:832(primary) /tmp/cicero-lkRf/xfunc.xml:964(primary) /tmp/cicero-lkRf/xfunc.xml:1420(primary) /tmp/cicero-lkRf/xfunc.xml:1464(primary) 
msgid "function"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:10(secondary) /tmp/cicero-lkRf/xfunc.xml:82(secondary) /tmp/cicero-lkRf/xfunc.xml:1465(secondary) 
msgid "user-defined"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:19(para) 
msgid "query language functions (functions written in <acronym>SQL</acronym>) (<xref linkend=\"xfunc-sql\"/>)"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:25(para) 
msgid "procedural language functions (functions written in, for example, <application>PL/pgSQL</application> or <application>PL/Tcl</application>) (<xref linkend=\"xfunc-pl\"/>)"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:32(para) 
msgid "internal functions (<xref linkend=\"xfunc-internal\"/>)"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:37(para) 
msgid "C-language functions (<xref linkend=\"xfunc-c\"/>)"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:13(para) 
msgid "<productname>PostgreSQL</productname> provides four kinds of functions: <placeholder-1/>"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:44(para) 
msgid "Every kind of function can take base types, composite types, or combinations of these as arguments (parameters). In addition, every kind of function can return a base type or a composite type. Functions can also be defined to return sets of base or composite values."
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:53(para) 
msgid "Many kinds of functions can take or return certain pseudo-types (such as polymorphic types), but the available facilities vary. Consult the description of each kind of function for more details."
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:59(para) 
msgid "It's easiest to define <acronym>SQL</acronym> functions, so we'll start by discussing those. Most of the concepts presented for <acronym>SQL</acronym> functions will carry over to the other types of functions."
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:66(para) 
msgid "Throughout this chapter, it can be useful to look at the reference page of the <xref linkend=\"sql-createfunction\"/> command to understand the examples better. Some examples from this chapter can be found in <filename>funcs.sql</filename> and <filename>funcs.c</filename> in the <filename>src/tutorial</filename> directory in the <productname>PostgreSQL</productname> source distribution."
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:78(title) 
msgid "Query Language (<acronym>SQL</acronym>) Functions"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:83(tertiary) 
msgid "in SQL"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:86(para) 
msgid "SQL functions execute an arbitrary list of SQL statements, returning the result of the last query in the list. In the simple (non-set) case, the first row of the last query's result will be returned. (Bear in mind that <quote>the first row</quote> of a multirow result is not well-defined unless you use <literal>ORDER BY</literal>.) If the last query happens to return no rows at all, the null value will be returned."
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:97(para) 
msgid "Alternatively, an SQL function can be declared to return a set, by specifying the function's return type as <literal>SETOF <replaceable>sometype</replaceable></literal>, or equivalently by declaring it as <literal>RETURNS TABLE(<replaceable>columns</replaceable>)</literal>. In this case all rows of the last query's result are returned. Further details appear below."
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:106(para) 
msgid "The body of an SQL function must be a list of SQL statements separated by semicolons. A semicolon after the last statement is optional. Unless the function is declared to return <type>void</type>, the last statement must be a <command>SELECT</command>, or an <command>INSERT</command>, <command>UPDATE</command>, or <command>DELETE</command> that has a <literal>RETURNING</literal> clause."
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:115(para) 
msgid "Any collection of commands in the <acronym>SQL</acronym> language can be packaged together and defined as a function. Besides <command>SELECT</command> queries, the commands can include data modification queries (<command>INSERT</command>, <command>UPDATE</command>, and <command>DELETE</command>), as well as other SQL commands. (You cannot use transaction control commands, e.g. <command>COMMIT</command>, <command>SAVEPOINT</command>, and some utility commands, e.g. <literal>VACUUM</literal>, in <acronym>SQL</acronym> functions.) However, the final command must be a <command>SELECT</command> or have a <literal>RETURNING</literal> clause that returns whatever is specified as the function's return type. Alternatively, if you want to define a SQL function that performs actions but has no useful value to return, you can define it as returning <type>void</type>. For example, this function removes rows with negative salaries from the <literal>emp</literal> table: <screen>\nCREATE FUNCTION clean_emp() RETURNS void AS '\n    DELETE FROM emp\n        WHERE salary &lt; 0;\n' LANGUAGE SQL;\n\nSELECT clean_emp();\n\n clean_emp\n-----------\n\n(1 row)\n</screen>"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:148(para) 
msgid "The syntax of the <command>CREATE FUNCTION</command> command requires the function body to be written as a string constant. It is usually most convenient to use dollar quoting (see <xref linkend=\"sql-syntax-dollar-quoting\"/>) for the string constant. If you choose to use regular single-quoted string constant syntax, you must double single quote marks (<literal>'</literal>) and backslashes (<literal>\\</literal>) (assuming escape string syntax) in the body of the function (see <xref linkend=\"sql-syntax-strings\"/>)."
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:167(programlisting) 
#, no-wrap
msgid "\nINSERT INTO mytable VALUES ($1);\n"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:171(programlisting) 
#, no-wrap
msgid "\nINSERT INTO $1 VALUES (42);\n"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:159(para) 
msgid "Arguments to the SQL function are referenced in the function body using the syntax <literal>$<replaceable>n</replaceable></literal>: <literal>$1</literal> refers to the first argument, <literal>$2</literal> to the second, and so on. If an argument is of a composite type, then the dot notation, e.g., <literal>$1.name</literal>, can be used to access attributes of the argument. The arguments can only be used as data values, not as identifiers. Thus for example this is reasonable: <placeholder-1/> but this will not work: <placeholder-2/>"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:177(title) 
msgid "<acronym>SQL</acronym> Functions on Base Types"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:179(para) 
msgid "The simplest possible <acronym>SQL</acronym> function has no arguments and simply returns a base type, such as <type>integer</type>: <screen>\nCREATE FUNCTION one() RETURNS integer AS $$\n    SELECT 1 AS result;\n$$ LANGUAGE SQL;\n\n-- Alternative syntax for string literal:\nCREATE FUNCTION one() RETURNS integer AS '\n    SELECT 1 AS result;\n' LANGUAGE SQL;\n\nSELECT one();\n\n one\n-----\n   1\n</screen>"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:201(para) 
msgid "Notice that we defined a column alias within the function body for the result of the function (with the name <literal>result</literal>), but this column alias is not visible outside the function. Hence, the result is labeled <literal>one</literal> instead of <literal>result</literal>."
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:208(para) 
msgid "It is almost as easy to define <acronym>SQL</acronym> functions that take base types as arguments. In the example below, notice how we refer to the arguments within the function as <literal>$1</literal> and <literal>$2</literal>. <screen>\nCREATE FUNCTION add_em(integer, integer) RETURNS integer AS $$\n    SELECT $1 + $2;\n$$ LANGUAGE SQL;\n\nSELECT add_em(1, 2) AS answer;\n\n answer\n--------\n      3\n</screen>"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:231(programlisting) 
#, no-wrap
msgid "\nCREATE FUNCTION tf1 (integer, numeric) RETURNS integer AS $$\n    UPDATE bank\n        SET balance = balance - $2\n        WHERE accountno = $1;\n    SELECT 1;\n$$ LANGUAGE SQL;\n"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:243(programlisting) 
#, no-wrap
msgid "\nSELECT tf1(17, 100.0);\n"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:227(para) 
msgid "Here is a more useful function, which might be used to debit a bank account: <placeholder-1/> A user could execute this function to debit account 17 by $100.00 as follows: <placeholder-2/>"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:253(programlisting) 
#, no-wrap
msgid "\nCREATE FUNCTION tf1 (integer, numeric) RETURNS numeric AS $$\n    UPDATE bank\n        SET balance = balance - $2\n        WHERE accountno = $1;\n    SELECT balance FROM bank WHERE accountno = $1;\n$$ LANGUAGE SQL;\n"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:265(programlisting) 
#, no-wrap
msgid "\nCREATE FUNCTION tf1 (integer, numeric) RETURNS numeric AS $$\n    UPDATE bank\n        SET balance = balance - $2\n        WHERE accountno = $1\n    RETURNING balance;\n$$ LANGUAGE SQL;\n"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:248(para) 
msgid "In practice one would probably like a more useful result from the function than a constant 1, so a more likely definition is: <placeholder-1/> which adjusts the balance and returns the new balance. The same thing could be done in one command using <literal>RETURNING</literal>: <placeholder-2/>"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:277(title) 
msgid "<acronym>SQL</acronym> Functions on Composite Types"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:279(para) 
msgid "When writing functions with arguments of composite types, we must not only specify which argument we want (as we did above with <literal>$1</literal> and <literal>$2</literal>) but also the desired attribute (field) of that argument. For example, suppose that <type>emp</type> is a table containing employee data, and therefore also the name of the composite type of each row of the table. Here is a function <function>double_salary</function> that computes what someone's salary would be if it were doubled: <screen>\nCREATE TABLE emp (\n    name        text,\n    salary      numeric,\n    age         integer,\n    cubicle     point\n);\n\nINSERT INTO emp VALUES ('Bill', 4200, 45, '(2,1)');\n\nCREATE FUNCTION double_salary(emp) RETURNS numeric AS $$\n    SELECT $1.salary * 2 AS salary;\n$$ LANGUAGE SQL;\n\nSELECT name, double_salary(emp.*) AS dream\n    FROM emp\n    WHERE emp.cubicle ~= point '(2,1)';\n\n name | dream\n------+-------\n Bill |  8400\n</screen>"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:314(para) 
msgid "Notice the use of the syntax <literal>$1.salary</literal> to select one field of the argument row value. Also notice how the calling <command>SELECT</command> command uses <literal>*</literal> to select the entire current row of a table as a composite value. The table row can alternatively be referenced using just the table name, like this: <screen>\nSELECT name, double_salary(emp) AS dream\n    FROM emp\n    WHERE emp.cubicle ~= point '(2,1)';\n</screen> but this usage is deprecated since it's easy to get confused."
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:330(para) 
msgid "Sometimes it is handy to construct a composite argument value on-the-fly. This can be done with the <literal>ROW</literal> construct. For example, we could adjust the data being passed to the function: <screen>\nSELECT name, double_salary(ROW(name, salary*1.1, age, cubicle)) AS dream\n    FROM emp;\n</screen>"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:345(programlisting) 
#, no-wrap
msgid "\nCREATE FUNCTION new_emp() RETURNS emp AS $$\n    SELECT text 'None' AS name,\n        1000.0 AS salary,\n        25 AS age,\n        point '(2,2)' AS cubicle;\n$$ LANGUAGE SQL;\n"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:340(para) 
msgid "It is also possible to build a function that returns a composite type. This is an example of a function that returns a single <type>emp</type> row: <placeholder-1/> In this example we have specified each of the attributes with a constant value, but any computation could have been substituted for these constants."
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:364(para) 
msgid "The select list order in the query must be exactly the same as that in which the columns appear in the table associated with the composite type. (Naming the columns, as we did above, is irrelevant to the system.)"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:372(para) 
msgid "You must typecast the expressions to match the definition of the composite type, or you will get errors like this: <screen>\n<computeroutput>\nERROR:  function declared to return emp returns varchar instead of text at column 1\n</computeroutput>\n</screen>"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:359(para) 
msgid "Note two important things about defining the function: <placeholder-1/>"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:388(programlisting) 
#, no-wrap
msgid "\nCREATE FUNCTION new_emp() RETURNS emp AS $$\n    SELECT ROW('None', 1000.0, 25, '(2,2)')::emp;\n$$ LANGUAGE SQL;\n"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:385(para) 
msgid "A different way to define the same function is: <placeholder-1/> Here we wrote a <command>SELECT</command> that returns just a single column of the correct composite type. This isn't really better in this situation, but it is a handy alternative in some cases — for example, if we need to compute the result by calling another function that returns the desired composite value."
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:401(para) 
msgid "We could call this function directly in either of two ways: <screen>\nSELECT new_emp();\n\n         new_emp\n--------------------------\n (None,1000.0,25,\"(2,2)\")\n\nSELECT * FROM new_emp();\n\n name | salary | age | cubicle\n------+--------+-----+---------\n None | 1000.0 |  25 | (2,2)\n</screen> The second way is described more fully in <xref linkend=\"xfunc-sql-table-functions\"/>."
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:422(para) 
msgid "When you use a function that returns a composite type, you might want only one field (attribute) from its result. You can do that with syntax like this: <screen>\nSELECT (new_emp()).name;\n\n name\n------\n None\n</screen> The extra parentheses are needed to keep the parser from getting confused. If you try to do it without them, you get something like this: <screen>\nSELECT new_emp().name;\nERROR:  syntax error at or near \".\"\nLINE 1: SELECT new_emp().name;\n                        ^\n</screen>"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:446(para) 
msgid "Another option is to use functional notation for extracting an attribute. The simple way to explain this is that we can use the notations <literal>attribute(table)</literal> and <literal>table.attribute</literal> interchangeably. <screen>\nSELECT name(new_emp());\n\n name\n------\n None\n</screen><screen>\n-- This is the same as:\n-- SELECT emp.name AS youngster FROM emp WHERE emp.age &lt; 30;\n\nSELECT name(emp) AS youngster FROM emp WHERE age(emp) &lt; 30;\n\n youngster\n-----------\n Sam\n Andy\n</screen>"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:475(para) 
msgid "The equivalence between functional notation and attribute notation makes it possible to use functions on composite types to emulate <quote>computed fields</quote>. <indexterm><primary>computed field</primary></indexterm><indexterm><primary>field</primary><secondary>computed</secondary></indexterm> For example, using the previous definition for <literal>double_salary(emp)</literal>, we can write <screen>\nSELECT emp.name, emp.double_salary FROM emp;\n</screen> An application using this wouldn't need to be directly aware that <literal>double_salary</literal> isn't a real column of the table. (You can also emulate computed fields with views.)"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:498(para) 
msgid "Because of this behavior, it's unwise to give a function that takes a single composite-type argument the same name as any of the fields of that composite type."
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:505(para) 
msgid "Another way to use a function returning a composite type is to pass the result to another function that accepts the correct row type as input: <screen>\nCREATE FUNCTION getname(emp) RETURNS text AS $$\n    SELECT $1.name;\n$$ LANGUAGE SQL;\n\nSELECT getname(new_emp());\n getname\n---------\n None\n(1 row)\n</screen>"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:522(para) 
msgid "Still another way to use a function that returns a composite type is to call it as a table function, as described in <xref linkend=\"xfunc-sql-table-functions\"/>."
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:530(title) 
msgid "<acronym>SQL</acronym> Functions with Parameter Names"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:534(secondary) 
msgid "named parameter"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:540(programlisting) 
#, no-wrap
msgid "\nCREATE FUNCTION tf1 (acct_no integer, debit numeric) RETURNS numeric AS $$\n    UPDATE bank\n        SET balance = balance - $2\n        WHERE accountno = $1\n    RETURNING balance;\n$$ LANGUAGE SQL;\n"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:537(para) 
msgid "It is possible to attach names to a function's parameters, for example <placeholder-1/> Here the first parameter has been given the name <literal>acct_no</literal>, and the second parameter the name <literal>debit</literal>. So far as the SQL function itself is concerned, these names are just decoration; you must still refer to the parameters as <literal>$1</literal>, <literal>$2</literal>, etc within the function body. (Some procedural languages let you use the parameter names instead.) However, attaching names to the parameters is useful for documentation purposes. When a function has many parameters, it is also useful to use the names while calling the function, as described in <xref linkend=\"sql-syntax-calling-funcs\"/>."
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:563(title) 
msgid "<acronym>SQL</acronym> Functions with Output Parameters"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:567(secondary) 
msgid "output parameter"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:570(para) 
msgid "An alternative way of describing a function's results is to define it with <firstterm>output parameters</firstterm>, as in this example: <screen>\nCREATE FUNCTION add_em (IN x int, IN y int, OUT sum int)\nAS 'SELECT $1 + $2'\nLANGUAGE SQL;\n\nSELECT add_em(3,7);\n add_em\n--------\n     10\n(1 row)\n</screen> This is not essentially different from the version of <literal>add_em</literal> shown in <xref linkend=\"xfunc-sql-base-functions\"/>. The real value of output parameters is that they provide a convenient way of defining functions that return several columns. For example, <screen>\nCREATE FUNCTION sum_n_product (x int, y int, OUT sum int, OUT product int)\nAS 'SELECT $1 + $2, $1 * $2'\nLANGUAGE SQL;\n\n SELECT * FROM sum_n_product(11,42);\n sum | product\n-----+---------\n  53 |     462\n(1 row)\n</screen> What has essentially happened here is that we have created an anonymous composite type for the result of the function. The above example has the same end result as <screen>\nCREATE TYPE sum_prod AS (sum int, product int);\n\nCREATE FUNCTION sum_n_product (int, int) RETURNS sum_prod\nAS 'SELECT $1 + $2, $1 * $2'\nLANGUAGE SQL;\n</screen> but not having to bother with the separate composite type definition is often handy. Notice that the names attached to the output parameters are not just decoration, but determine the column names of the anonymous composite type. (If you omit a name for an output parameter, the system will choose a name on its own.)"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:622(para) 
msgid "Notice that output parameters are not included in the calling argument list when invoking such a function from SQL. This is because <productname>PostgreSQL</productname> considers only the input parameters to define the function's calling signature. That means also that only the input parameters matter when referencing the function for purposes such as dropping it. We could drop the above function with either of <screen>\nDROP FUNCTION sum_n_product (x int, y int, OUT sum int, OUT product int);\nDROP FUNCTION sum_n_product (int, int);\n</screen>"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:637(para) 
msgid "Parameters can be marked as <literal>IN</literal> (the default), <literal>OUT</literal>, <literal>INOUT</literal>, or <literal>VARIADIC</literal>. An <literal>INOUT</literal> parameter serves as both an input parameter (part of the calling argument list) and an output parameter (part of the result record type). <literal>VARIADIC</literal> parameters are input parameters, but are treated specially as described next."
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:649(title) 
msgid "<acronym>SQL</acronym> Functions with Variable Numbers of Arguments"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:653(secondary) 
msgid "variadic"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:657(primary) 
msgid "variadic function"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:660(para) 
msgid "<acronym>SQL</acronym> functions can be declared to accept variable numbers of arguments, so long as all the <quote>optional</quote> arguments are of the same data type. The optional arguments will be passed to the function as an array. The function is declared by marking the last parameter as <literal>VARIADIC</literal>; this parameter must be declared as being of an array type. For example: <screen>\nCREATE FUNCTION mleast(VARIADIC arr numeric[]) RETURNS numeric AS $$\n    SELECT min($1[i]) FROM generate_subscripts($1, 1) g(i);\n$$ LANGUAGE SQL;\n\nSELECT mleast(10, -1, 5, 4.4);\n mleast \n--------\n     -1\n(1 row)\n</screen> Effectively, all the actual arguments at or beyond the <literal>VARIADIC</literal> position are gathered up into a one-dimensional array, as if you had written <screen>\nSELECT mleast(ARRAY[10, -1, 5, 4.4]);    -- doesn't work\n</screen> You can't actually write that, though — or at least, it will not match this function definition. A parameter marked <literal>VARIADIC</literal> matches one or more occurrences of its element type, not of its own type."
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:694(para) 
msgid "Sometimes it is useful to be able to pass an already-constructed array to a variadic function; this is particularly handy when one variadic function wants to pass on its array parameter to another one. You can do that by specifying <literal>VARIADIC</literal> in the call: <screen>\nSELECT mleast(VARIADIC ARRAY[10, -1, 5, 4.4]);\n</screen> This prevents expansion of the function's variadic parameter into its element type, thereby allowing the array argument value to match normally. <literal>VARIADIC</literal> can only be attached to the last actual argument of a function call."
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:710(para) 
msgid "The array element parameters generated from a variadic parameter are treated as not having any names of their own. This means it is not possible to call a variadic function using named arguments (<xref linkend=\"sql-syntax-calling-funcs\"/>), except when you specify <literal>VARIADIC</literal>. For example, this will work: <screen>\nSELECT mleast(VARIADIC arr := ARRAY[10, -1, 5, 4.4]);\n</screen> but not these: <screen>\nSELECT mleast(arr := 10);\nSELECT mleast(arr := ARRAY[10, -1, 5, 4.4]);\n</screen>"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:731(title) 
msgid "<acronym>SQL</acronym> Functions with Default Values for Arguments"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:735(secondary) 
msgid "default values for arguments"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:738(para) 
msgid "Functions can be declared with default values for some or all input arguments. The default values are inserted whenever the function is called with insufficiently many actual arguments. Since arguments can only be omitted from the end of the actual argument list, all parameters after a parameter with a default value have to have default values as well. (Although the use of named argument notation could allow this restriction to be relaxed, it's still enforced so that positional argument notation works sensibly.)"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:749(para) 
msgid "For example: <screen>\nCREATE FUNCTION foo(a int, b int DEFAULT 2, c int DEFAULT 3)\nRETURNS int\nLANGUAGE SQL\nAS $$\n    SELECT $1 + $2 + $3;\n$$;\n\nSELECT foo(10, 20, 30);\n foo \n-----\n  60\n(1 row)\n\nSELECT foo(10, 20);\n foo \n-----\n  33\n(1 row)\n\nSELECT foo(10);\n foo \n-----\n  15\n(1 row)\n\nSELECT foo();  -- fails since there is no default for the first argument\nERROR:  function foo() does not exist\n</screen> The <literal>=</literal> sign can also be used in place of the key word <literal>DEFAULT</literal>."
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:786(title) 
msgid "<acronym>SQL</acronym> Functions as Table Sources"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:788(para) 
msgid "All SQL functions can be used in the <literal>FROM</literal> clause of a query, but it is particularly useful for functions returning composite types. If the function is defined to return a base type, the table function produces a one-column table. If the function is defined to return a composite type, the table function produces a column for each attribute of the composite type."
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:797(para) 
msgid "Here is an example: <screen>\nCREATE TABLE foo (fooid int, foosubid int, fooname text);\nINSERT INTO foo VALUES (1, 1, 'Joe');\nINSERT INTO foo VALUES (1, 2, 'Ed');\nINSERT INTO foo VALUES (2, 1, 'Mary');\n\nCREATE FUNCTION getfoo(int) RETURNS foo AS $$\n    SELECT * FROM foo WHERE fooid = $1;\n$$ LANGUAGE SQL;\n\nSELECT *, upper(fooname) FROM getfoo(1) AS t1;\n\n fooid | foosubid | fooname | upper\n-------+----------+---------+-------\n     1 |        1 | Joe     | JOE\n(1 row)\n</screen> As the example shows, we can work with the columns of the function's result just the same as if they were columns of a regular table."
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:822(para) 
msgid "Note that we only got one row out of the function. This is because we did not use <literal>SETOF</literal>. That is described in the next section."
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:829(title) 
msgid "<acronym>SQL</acronym> Functions Returning Sets"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:833(secondary) 
msgid "with SETOF"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:836(para) 
msgid "When an SQL function is declared as returning <literal>SETOF <replaceable>sometype</replaceable></literal>, the function's final query is executed to completion, and each row it outputs is returned as an element of the result set."
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:849(programlisting) 
#, no-wrap
msgid "\nCREATE FUNCTION getfoo(int) RETURNS SETOF foo AS $$\n    SELECT * FROM foo WHERE fooid = $1;\n$$ LANGUAGE SQL;\n\nSELECT * FROM getfoo(1) AS t1;\n"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:843(para) 
msgid "This feature is normally used when calling the function in the <literal>FROM</literal> clause. In this case each row returned by the function becomes a row of the table seen by the query. For example, assume that table <literal>foo</literal> has the same contents as above, and we say: <placeholder-1/> Then we would get: <screen>\n fooid | foosubid | fooname\n-------+----------+---------\n     1 |        1 | Joe\n     1 |        2 | Ed\n(2 rows)\n</screen>"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:871(programlisting) 
#, no-wrap
msgid "\nCREATE TABLE tab (y int, z int);\nINSERT INTO tab VALUES (1, 2), (3, 4), (5, 6), (7, 8);\n\nCREATE FUNCTION sum_n_product_with_tab (x int, OUT sum int, OUT product int)\nRETURNS SETOF record\nAS $$\n    SELECT $1 + tab.y, $1 * tab.y FROM tab;\n$$ LANGUAGE SQL;\n\nSELECT * FROM sum_n_product_with_tab(10);\n sum | product\n-----+---------\n  11 |      10\n  13 |      30\n  15 |      50\n  17 |      70\n(4 rows)\n"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:867(para) 
msgid "It is also possible to return multiple rows with the columns defined by output parameters, like this: <placeholder-1/> The key point here is that you must write <literal>RETURNS SETOF record</literal> to indicate that the function returns multiple rows instead of just one. If there is only one output parameter, write that parameter's type instead of <type>record</type>."
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:897(para) 
msgid "Currently, functions returning sets can also be called in the select list of a query. For each row that the query generates by itself, the function returning set is invoked, and an output row is generated for each element of the function's result set. Note, however, that this capability is deprecated and might be removed in future releases. The following is an example function returning a set from the select list: <screen>\nCREATE FUNCTION listchildren(text) RETURNS SETOF text AS $$\n    SELECT name FROM nodes WHERE parent = $1\n$$ LANGUAGE SQL;\n\nSELECT * FROM nodes;\n   name    | parent\n-----------+--------\n Top       |\n Child1    | Top\n Child2    | Top\n Child3    | Top\n SubChild1 | Child1\n SubChild2 | Child1\n(6 rows)\n\nSELECT listchildren('Top');\n listchildren\n--------------\n Child1\n Child2\n Child3\n(3 rows)\n\nSELECT name, listchildren(name) FROM nodes;\n  name  | listchildren\n--------+--------------\n Top    | Child1\n Top    | Child2\n Top    | Child3\n Child1 | SubChild1\n Child1 | SubChild2\n(5 rows)\n</screen> In the last <command>SELECT</command>, notice that no output row appears for <literal>Child2</literal>, <literal>Child3</literal>, etc. This happens because <function>listchildren</function> returns an empty set for those arguments, so no result rows are generated."
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:948(para) 
msgid "If a function's last command is <command>INSERT</command>, <command>UPDATE</command>, or <command>DELETE</command> with <literal>RETURNING</literal>, that command will always be executed to completion, even if the function is not declared with <literal>SETOF</literal> or the calling query does not fetch all the result rows. Any extra rows produced by the <literal>RETURNING</literal> clause are silently dropped, but the commanded table modifications still happen (and are all completed before returning from the function)."
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:961(title) 
msgid "<acronym>SQL</acronym> Functions Returning <literal>TABLE</literal>"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:965(secondary) 
msgid "RETURNS TABLE"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:968(para) 
msgid "There is another way to declare a function as returning a set, which is to use the syntax <literal>RETURNS TABLE(<replaceable>columns</replaceable>)</literal>. This is equivalent to using one or more <literal>OUT</literal> parameters plus marking the function as returning <literal>SETOF record</literal> (or <literal>SETOF</literal> a single output parameter's type, as appropriate). This notation is specified in recent versions of the SQL standard, and thus may be more portable than using <literal>SETOF</literal>."
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:983(programlisting) 
#, no-wrap
msgid "\nCREATE FUNCTION sum_n_product_with_tab (x int)\nRETURNS TABLE(sum int, product int) AS $$\n    SELECT $1 + tab.y, $1 * tab.y FROM tab;\n$$ LANGUAGE SQL;\n"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:979(para) 
msgid "For example, the preceding sum-and-product example could also be done this way: <placeholder-1/> It is not allowed to use explicit <literal>OUT</literal> or <literal>INOUT</literal> parameters with the <literal>RETURNS TABLE</literal> notation — you must put all the output columns in the <literal>TABLE</literal> list."
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:997(title) 
msgid "Polymorphic <acronym>SQL</acronym> Functions"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:999(para) 
msgid "<acronym>SQL</acronym> functions can be declared to accept and return the polymorphic types <type>anyelement</type>, <type>anyarray</type>, <type>anynonarray</type>, and <type>anyenum</type>. See <xref linkend=\"extend-types-polymorphic\"/> for a more detailed explanation of polymorphic functions. Here is a polymorphic function <function>make_array</function> that builds up an array from two arbitrary data type elements: <screen>\nCREATE FUNCTION make_array(anyelement, anyelement) RETURNS anyarray AS $$\n    SELECT ARRAY[$1, $2];\n$$ LANGUAGE SQL;\n\nSELECT make_array(1, 2) AS intarray, make_array('a'::text, 'b') AS textarray;\n intarray | textarray\n----------+-----------\n {1,2}    | {a,b}\n(1 row)\n</screen>"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1021(para) 
msgid "Notice the use of the typecast <literal>'a'::text</literal> to specify that the argument is of type <type>text</type>. This is required if the argument is just a string literal, since otherwise it would be treated as type <type>unknown</type>, and array of <type>unknown</type> is not a valid type. Without the typecast, you will get errors like this: <screen>\n<computeroutput>\nERROR:  could not determine polymorphic type because input has type \"unknown\"\n</computeroutput>\n</screen>"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1036(para) 
msgid "It is permitted to have polymorphic arguments with a fixed return type, but the converse is not. For example: <screen>\nCREATE FUNCTION is_greater(anyelement, anyelement) RETURNS boolean AS $$\n    SELECT $1 &gt; $2;\n$$ LANGUAGE SQL;\n\nSELECT is_greater(1, 2);\n is_greater\n------------\n f\n(1 row)\n\nCREATE FUNCTION invalid_func() RETURNS anyelement AS $$\n    SELECT 1;\n$$ LANGUAGE SQL;\nERROR:  cannot determine result data type\nDETAIL:  A function returning a polymorphic type must have at least one polymorphic argument.\n</screen>"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1058(para) 
msgid "Polymorphism can be used with functions that have output arguments. For example: <screen>\nCREATE FUNCTION dup (f1 anyelement, OUT f2 anyelement, OUT f3 anyarray)\nAS 'select $1, array[$1,$1]' LANGUAGE SQL;\n\nSELECT * FROM dup(22);\n f2 |   f3\n----+---------\n 22 | {22,22}\n(1 row)\n</screen>"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1073(para) 
msgid "Polymorphism can also be used with variadic functions. For example: <screen>\nCREATE FUNCTION anyleast (VARIADIC anyarray) RETURNS anyelement AS $$\n    SELECT min($1[i]) FROM generate_subscripts($1, 1) g(i);\n$$ LANGUAGE SQL;\n\nSELECT anyleast(10, -1, 5, 4);\n anyleast \n----------\n       -1\n(1 row)\n\nSELECT anyleast('abc'::text, 'def');\n anyleast \n----------\n abc\n(1 row)\n\nCREATE FUNCTION concat_values(text, VARIADIC anyarray) RETURNS text AS $$\n    SELECT array_to_string($2, $1);\n$$ LANGUAGE SQL;\n\nSELECT concat_values('|', 1, 4, 2);\n concat_values \n---------------\n 1|4|2\n(1 row)\n</screen>"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1107(title) 
msgid "<acronym>SQL</acronym> Functions with Collations"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1110(primary) 
msgid "collation"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1111(secondary) 
msgid "in SQL functions"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1124(programlisting) 
#, no-wrap
msgid "\nSELECT anyleast('abc'::text, 'ABC');\n"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1131(programlisting) 
#, no-wrap
msgid "\nSELECT anyleast('abc'::text, 'ABC' COLLATE \"C\");\n"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1139(programlisting) 
#, no-wrap
msgid "\nCREATE FUNCTION anyleast (VARIADIC anyarray) RETURNS anyelement AS $$\n    SELECT min($1[i] COLLATE \"en_US\") FROM generate_subscripts($1, 1) g(i);\n$$ LANGUAGE SQL;\n"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1114(para) 
msgid "When a SQL function has one or more parameters of collatable data types, a collation is identified for each function call depending on the collations assigned to the actual arguments, as described in <xref linkend=\"collation\"/>. If a collation is successfully identified (i.e., there are no conflicts of implicit collations among the arguments) then all the collatable parameters are treated as having that collation implicitly. This will affect the behavior of collation-sensitive operations within the function. For example, using the <function>anyleast</function> function described above, the result of <placeholder-1/> will depend on the database's default collation. In <literal>C</literal> locale the result will be <literal>ABC</literal>, but in many other locales it will be <literal>abc</literal>. The collation to use can be forced by adding a <literal>COLLATE</literal> clause to any of the arguments, for example <placeholder-2/> Alternatively, if you wish a function to operate with a particular collation regardless of what it is called with, insert <literal>COLLATE</literal> clauses as needed in the function definition. This version of <function>anyleast</function> would always use <literal>en_US</literal> locale to compare strings: <placeholder-3/> But note that this will throw an error if applied to a non-collatable data type."
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1148(para) 
msgid "If no common collation can be identified among the actual arguments, then a SQL function treats its parameters as having their data types' default collation (which is usually the database's default collation, but could be different for parameters of domain types)."
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1155(para) 
msgid "The behavior of collatable parameters can be thought of as a limited form of polymorphism, applicable only to textual data types."
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1163(title) 
msgid "Function Overloading"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1166(primary) 
msgid "overloading"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1167(secondary) /tmp/cicero-lkRf/xfunc.xml:1245(secondary) 
msgid "functions"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1170(para) 
msgid "More than one function can be defined with the same SQL name, so long as the arguments they take are different. In other words, function names can be <firstterm>overloaded</firstterm>. When a query is executed, the server will determine which function to call from the data types and the number of the provided arguments. Overloading can also be used to simulate functions with a variable number of arguments, up to a finite maximum number."
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1184(programlisting) 
#, no-wrap
msgid "\nCREATE FUNCTION test(int, real) RETURNS ...\nCREATE FUNCTION test(smallint, double precision) RETURNS ...\n"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1180(para) 
msgid "When creating a family of overloaded functions, one should be careful not to create ambiguities. For instance, given the functions: <placeholder-1/> it is not immediately clear which function would be called with some trivial input like <literal>test(1, 1.5)</literal>. The currently implemented resolution rules are described in <xref linkend=\"typeconv\"/>, but it is unwise to design a system that subtly relies on this behavior."
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1195(para) 
msgid "A function that takes a single argument of a composite type should generally not have the same name as any attribute (field) of that type. Recall that <literal>attribute(table)</literal> is considered equivalent to <literal>table.attribute</literal>. In the case that there is an ambiguity between a function on a composite type and an attribute of the composite type, the attribute will always be used. It is possible to override that choice by schema-qualifying the function name (that is, <literal>schema.func(table)</literal>) but it's better to avoid the problem by not choosing conflicting names."
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1207(para) 
msgid "Another possible conflict is between variadic and non-variadic functions. For instance, it is possible to create both <literal>foo(numeric)</literal> and <literal>foo(VARIADIC numeric[])</literal>. In this case it is unclear which one should be matched to a call providing a single numeric argument, such as <literal>foo(10.1)</literal>. The rule is that the function appearing earlier in the search path is used, or if the two functions are in the same schema, the non-variadic one is preferred."
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1228(programlisting) 
#, no-wrap
msgid "\nCREATE FUNCTION test(int) RETURNS int\n    AS '<replaceable>filename</replaceable>', 'test_1arg'\n    LANGUAGE C;\nCREATE FUNCTION test(int, int) RETURNS int\n    AS '<replaceable>filename</replaceable>', 'test_2arg'\n    LANGUAGE C;\n"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1217(para) 
msgid "When overloading C-language functions, there is an additional constraint: The C name of each function in the family of overloaded functions must be different from the C names of all other functions, either internal or dynamically loaded. If this rule is violated, the behavior is not portable. You might get a run-time linker error, or one of the functions will get called (usually the internal one). The alternative form of the <literal>AS</literal> clause for the SQL <command>CREATE FUNCTION</command> command decouples the SQL function name from the function name in the C source code. For instance: <placeholder-1/> The names of the C functions here reflect one of many possible conventions."
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1241(title) 
msgid "Function Volatility Categories"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1244(primary) 
msgid "volatility"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1248(primary) 
msgid "VOLATILE"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1251(primary) 
msgid "STABLE"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1254(primary) 
msgid "IMMUTABLE"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1267(para) 
msgid "A <literal>VOLATILE</literal> function can do anything, including modifying the database. It can return different results on successive calls with the same arguments. The optimizer makes no assumptions about the behavior of such functions. A query using a volatile function will re-evaluate the function at every row where its value is needed."
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1276(para) 
msgid "A <literal>STABLE</literal> function cannot modify the database and is guaranteed to return the same results given the same arguments for all rows within a single statement. This category allows the optimizer to optimize multiple calls of the function to a single call. In particular, it is safe to use an expression containing such a function in an index scan condition. (Since an index scan will evaluate the comparison value only once, not once at each row, it is not valid to use a <literal>VOLATILE</literal> function in an index scan condition.)"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1289(para) 
msgid "An <literal>IMMUTABLE</literal> function cannot modify the database and is guaranteed to return the same results given the same arguments forever. This category allows the optimizer to pre-evaluate the function when a query calls it with constant arguments. For example, a query like <literal>SELECT ... WHERE x = 2 + 2</literal> can be simplified on sight to <literal>SELECT ... WHERE x = 4</literal>, because the function underlying the integer addition operator is marked <literal>IMMUTABLE</literal>."
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1257(para) 
msgid "Every function has a <firstterm>volatility</firstterm> classification, with the possibilities being <literal>VOLATILE</literal>, <literal>STABLE</literal>, or <literal>IMMUTABLE</literal>. <literal>VOLATILE</literal> is the default if the <xref linkend=\"sql-createfunction\"/> command does not specify a category. The volatility category is a promise to the optimizer about the behavior of the function: <placeholder-1/>"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1302(para) 
msgid "For best optimization results, you should label your functions with the strictest volatility category that is valid for them."
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1307(para) 
msgid "Any function with side-effects <emphasis>must</emphasis> be labeled <literal>VOLATILE</literal>, so that calls to it cannot be optimized away. Even a function with no side-effects needs to be labeled <literal>VOLATILE</literal> if its value can change within a single query; some examples are <literal>random()</literal>, <literal>currval()</literal>, <literal>timeofday()</literal>."
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1316(para) 
msgid "Another important example is that the <function>current_timestamp</function> family of functions qualify as <literal>STABLE</literal>, since their values do not change within a transaction."
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1322(para) 
msgid "There is relatively little difference between <literal>STABLE</literal> and <literal>IMMUTABLE</literal> categories when considering simple interactive queries that are planned and immediately executed: it doesn't matter a lot whether a function is executed once during planning or once during query execution startup. But there is a big difference if the plan is saved and reused later. Labeling a function <literal>IMMUTABLE</literal> when it really isn't might allow it to be prematurely folded to a constant during planning, resulting in a stale value being re-used during subsequent uses of the plan. This is a hazard when using prepared statements or when using function languages that cache plans (such as <application>PL/pgSQL</application>)."
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1336(para) 
msgid "For functions written in SQL or in any of the standard procedural languages, there is a second important property determined by the volatility category, namely the visibility of any data changes that have been made by the SQL command that is calling the function. A <literal>VOLATILE</literal> function will see such changes, a <literal>STABLE</literal> or <literal>IMMUTABLE</literal> function will not. This behavior is implemented using the snapshotting behavior of MVCC (see <xref linkend=\"mvcc\"/>): <literal>STABLE</literal> and <literal>IMMUTABLE</literal> functions use a snapshot established as of the start of the calling query, whereas <literal>VOLATILE</literal> functions obtain a fresh snapshot at the start of each query they execute."
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1351(para) 
msgid "Functions written in C can manage snapshots however they want, but it's usually a good idea to make C functions work this way too."
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1357(para) 
msgid "Because of this snapshotting behavior, a function containing only <command>SELECT</command> commands can safely be marked <literal>STABLE</literal>, even if it selects from tables that might be undergoing modifications by concurrent queries. <productname>PostgreSQL</productname> will execute all commands of a <literal>STABLE</literal> function using the snapshot established for the calling query, and so it will see a fixed view of the database throughout that query."
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1368(para) 
msgid "The same snapshotting behavior is used for <command>SELECT</command> commands within <literal>IMMUTABLE</literal> functions. It is generally unwise to select from database tables within an <literal>IMMUTABLE</literal> function at all, since the immutability will be broken if the table contents ever change. However, <productname>PostgreSQL</productname> does not enforce that you do not do that."
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1377(para) 
msgid "A common error is to label a function <literal>IMMUTABLE</literal> when its results depend on a configuration parameter. For example, a function that manipulates timestamps might well have results that depend on the <xref linkend=\"guc-timezone\"/> setting. For safety, such functions should be labeled <literal>STABLE</literal> instead."
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1386(para) 
msgid "Before <productname>PostgreSQL</productname> release 8.0, the requirement that <literal>STABLE</literal> and <literal>IMMUTABLE</literal> functions cannot modify the database was not enforced by the system. Releases 8.0 and later enforce it by requiring SQL functions and procedural language functions of these categories to contain no SQL commands other than <command>SELECT</command>. (This is not a completely bulletproof test, since such functions could still call <literal>VOLATILE</literal> functions that modify the database. If you do that, you will find that the <literal>STABLE</literal> or <literal>IMMUTABLE</literal> function does not notice the database changes applied by the called function, since they are hidden from its snapshot.)"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1402(title) 
msgid "Procedural Language Functions"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1404(para) 
msgid "<productname>PostgreSQL</productname> allows user-defined functions to be written in other languages besides SQL and C. These other languages are generically called <firstterm>procedural languages</firstterm> (<acronym>PL</acronym>s). Procedural languages aren't built into the <productname>PostgreSQL</productname> server; they are offered by loadable modules. See <xref linkend=\"xplang\"/> and following chapters for more information."
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1418(title) 
msgid "Internal Functions"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1420(secondary) 
msgid "internal"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1422(para) 
msgid "Internal functions are functions written in C that have been statically linked into the <productname>PostgreSQL</productname> server. The <quote>body</quote> of the function definition specifies the C-language name of the function, which need not be the same as the name being declared for SQL use. (For reasons of backward compatibility, an empty body is accepted as meaning that the C-language function name is the same as the SQL name.)"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1442(programlisting) 
#, no-wrap
msgid "\nCREATE FUNCTION square_root(double precision) RETURNS double precision\n    AS 'dsqrt'\n    LANGUAGE internal\n    STRICT;\n"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1433(para) 
msgid "Normally, all internal functions present in the server are declared during the initialization of the database cluster (see <xref linkend=\"creating-cluster\"/>), but a user could use <command>CREATE FUNCTION</command> to create additional alias names for an internal function. Internal functions are declared in <command>CREATE FUNCTION</command> with language name <literal>internal</literal>. For instance, to create an alias for the <function>sqrt</function> function: <placeholder-1/> (Most internal functions expect to be declared <quote>strict</quote>.)"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1452(para) 
msgid "Not all <quote>predefined</quote> functions are <quote>internal</quote> in the above sense. Some predefined functions are written in SQL."
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1461(title) 
msgid "C-Language Functions"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1466(tertiary) 
msgid "in C"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1469(para) 
msgid "User-defined functions can be written in C (or a language that can be made compatible with C, such as C++). Such functions are compiled into dynamically loadable objects (also called shared libraries) and are loaded by the server on demand. The dynamic loading feature is what distinguishes <quote>C language</quote> functions from <quote>internal</quote> functions — the actual coding conventions are essentially the same for both. (Hence, the standard internal function library is a rich source of coding examples for user-defined C functions.)"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1481(para) 
msgid "Two different calling conventions are currently used for C functions. The newer <quote>version 1</quote> calling convention is indicated by writing a <literal>PG_FUNCTION_INFO_V1()</literal> macro call for the function, as illustrated below. Lack of such a macro indicates an old-style (<quote>version 0</quote>) function. The language name specified in <command>CREATE FUNCTION</command> is <literal>C</literal> in either case. Old-style functions are now deprecated because of portability problems and lack of functionality, but they are still supported for compatibility reasons."
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1493(title) 
msgid "Dynamic Loading"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1496(primary) 
msgid "dynamic loading"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1499(para) 
msgid "The first time a user-defined function in a particular loadable object file is called in a session, the dynamic loader loads that object file into memory so that the function can be called. The <command>CREATE FUNCTION</command> for a user-defined C function must therefore specify two pieces of information for the function: the name of the loadable object file, and the C name (link symbol) of the specific function to call within that object file. If the C name is not explicitly specified then it is assumed to be the same as the SQL function name."
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1518(para) 
msgid "If the name is an absolute path, the given file is loaded."
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1524(para) 
msgid "If the name starts with the string <literal>$libdir</literal>, that part is replaced by the <productname>PostgreSQL</productname> package library directory name, which is determined at build time.<indexterm><primary>$libdir</primary></indexterm>"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1533(para) 
msgid "If the name does not contain a directory part, the file is searched for in the path specified by the configuration variable <xref linkend=\"guc-dynamic-library-path\"/>.<indexterm><primary>dynamic_library_path</primary></indexterm>"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1541(para) 
msgid "Otherwise (the file was not found in the path, or it contains a non-absolute directory part), the dynamic loader will try to take the name as given, which will most likely fail. (It is unreliable to depend on the current working directory.)"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1511(para) 
msgid "The following algorithm is used to locate the shared object file based on the name given in the <command>CREATE FUNCTION</command> command: <placeholder-1/> If this sequence does not work, the platform-specific shared library file name extension (often <filename>.so</filename>) is appended to the given name and this sequence is tried again. If that fails as well, the load will fail."
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1556(para) 
msgid "It is recommended to locate shared libraries either relative to <literal>$libdir</literal> or through the dynamic library path. This simplifies version upgrades if the new installation is at a different location. The actual directory that <literal>$libdir</literal> stands for can be found out with the command <literal>pg_config --pkglibdir</literal>."
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1565(para) 
msgid "The user ID the <productname>PostgreSQL</productname> server runs as must be able to traverse the path to the file you intend to load. Making the file or a higher-level directory not readable and/or not executable by the <systemitem>postgres</systemitem> user is a common mistake."
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1573(para) 
msgid "In any case, the file name that is given in the <command>CREATE FUNCTION</command> command is recorded literally in the system catalogs, so if the file needs to be loaded again the same procedure is applied."
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1581(para) 
msgid "<productname>PostgreSQL</productname> will not compile a C function automatically. The object file must be compiled before it is referenced in a <command>CREATE FUNCTION</command> command. See <xref linkend=\"dfunc\"/> for additional information."
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1591(primary) 
msgid "magic block"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1605(programlisting) 
#, no-wrap
msgid "\n#ifdef PG_MODULE_MAGIC\nPG_MODULE_MAGIC;\n#endif\n"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1594(para) 
msgid "To ensure that a dynamically loaded object file is not loaded into an incompatible server, <productname>PostgreSQL</productname> checks that the file contains a <quote>magic block</quote> with the appropriate contents. This allows the server to detect obvious incompatibilities, such as code compiled for a different major version of <productname>PostgreSQL</productname>. A magic block is required as of <productname>PostgreSQL</productname> 8.2. To include a magic block, write this in one (and only one) of the module source files, after having included the header <filename>fmgr.h</filename>: <placeholder-1/> The <literal>#ifdef</literal> test can be omitted if the code doesn't need to compile against pre-8.2 <productname>PostgreSQL</productname> releases."
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1616(para) 
msgid "After it is used for the first time, a dynamically loaded object file is retained in memory. Future calls in the same session to the function(s) in that file will only incur the small overhead of a symbol table lookup. If you need to force a reload of an object file, for example after recompiling it, begin a fresh session."
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1625(primary) 
msgid "_PG_init"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1628(primary) 
msgid "_PG_fini"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1631(primary) 
msgid "library initialization function"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1634(primary) 
msgid "library finalization function"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1637(para) 
msgid "Optionally, a dynamically loaded file can contain initialization and finalization functions. If the file includes a function named <function>_PG_init</function>, that function will be called immediately after loading the file. The function receives no parameters and should return void. If the file includes a function named <function>_PG_fini</function>, that function will be called immediately before unloading the file. Likewise, the function receives no parameters and should return void. Note that <function>_PG_fini</function> will only be called during an unload of the file, not during process termination. (Presently, unloads are disabled and will never occur, but this may change in the future.)"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1654(title) 
msgid "Base Types in C-Language Functions"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1657(primary) 
msgid "data type"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1658(secondary) 
msgid "internal organization"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1661(para) 
msgid "To know how to write C-language functions, you need to know how <productname>PostgreSQL</productname> internally represents base data types and how they can be passed to and from functions. Internally, <productname>PostgreSQL</productname> regards a base type as a <quote>blob of memory</quote>. The user-defined functions that you define over a type in turn define the way that <productname>PostgreSQL</productname> can operate on it. That is, <productname>PostgreSQL</productname> will only store and retrieve the data from disk and use your user-defined functions to input, process, and output the data."
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1679(para) 
msgid "pass by value, fixed-length"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1684(para) 
msgid "pass by reference, fixed-length"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1689(para) 
msgid "pass by reference, variable-length"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1674(para) 
msgid "Base types can have one of three internal formats: <placeholder-1/>"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1706(programlisting) 
#, no-wrap
msgid "\n/* 4-byte integer, passed by value */\ntypedef int int4;\n"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1696(para) 
msgid "By-value types can only be 1, 2, or 4 bytes in length (also 8 bytes, if <literal>sizeof(Datum)</literal> is 8 on your machine). You should be careful to define your types such that they will be the same size (in bytes) on all architectures. For example, the <literal>long</literal> type is dangerous because it is 4 bytes on some machines and 8 bytes on others, whereas <type>int</type> type is 4 bytes on most Unix machines. A reasonable implementation of the <type>int4</type> type on Unix machines might be: <placeholder-1/>"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1717(programlisting) 
#, no-wrap
msgid "\n/* 16-byte structure, passed by reference */\ntypedef struct\n{\n    double  x, y;\n} Point;\n"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1712(para) 
msgid "On the other hand, fixed-length types of any size can be passed by-reference. For example, here is a sample implementation of a <productname>PostgreSQL</productname> type: <placeholder-1/> Only pointers to such types can be used when passing them in and out of <productname>PostgreSQL</productname> functions. To return a value of such a type, allocate the right amount of memory with <literal>palloc</literal>, fill in the allocated memory, and return a pointer to it. (Also, if you just want to return the same value as one of your input arguments that's of the same data type, you can skip the extra <literal>palloc</literal> and just return the pointer to the input value.)"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1735(para) 
msgid "Finally, all variable-length types must also be passed by reference. All variable-length types must begin with a length field of exactly 4 bytes, and all data to be stored within that type must be located in the memory immediately following that length field. The length field contains the total length of the structure, that is, it includes the size of the length field itself."
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1746(para) 
msgid "Another important point is to avoid leaving any uninitialized bits within data type values; for example, take care to zero out any alignment padding bytes that might be present in structs. Without this, logically-equivalent constants of your data type might be seen as unequal by the planner, leading to inefficient (though not incorrect) plans."
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1756(para) 
msgid "<emphasis>Never</emphasis> modify the contents of a pass-by-reference input value. If you do so you are likely to corrupt on-disk data, since the pointer you are given might point directly into a disk buffer. The sole exception to this rule is explained in <xref linkend=\"xaggr\"/>."
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1769(programlisting) 
#, no-wrap
msgid "\ntypedef struct {\n    int4 length;\n    char data[1];\n} text;\n"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1765(para) 
msgid "As an example, we can define the type <type>text</type> as follows: <placeholder-1/> Obviously, the data field declared here is not long enough to hold all possible strings. Since it's impossible to declare a variable-size structure in <acronym>C</acronym>, we rely on the knowledge that the <acronym>C</acronym> compiler won't range-check array subscripts. We just allocate the necessary amount of space and then access the array as if it were declared the right length. (This is a common trick, which you can read about in many textbooks about C.)"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1785(para) 
msgid "When manipulating variable-length types, we must be careful to allocate the correct amount of memory and set the length field correctly. For example, if we wanted to store 40 bytes in a <structname>text</structname> structure, we might use a code fragment like this: <placeholder-1/><literal>VARHDRSZ</literal> is the same as <literal>sizeof(int4)</literal>, but it's considered good style to use the macro <literal>VARHDRSZ</literal> to refer to the size of the overhead for a variable-length type. Also, the length field <emphasis>must</emphasis> be set using the <literal>SET_VARSIZE</literal> macro, not by simple assignment."
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1811(para) 
msgid "<xref linkend=\"xfunc-c-type-table\"/> specifies which C type corresponds to which SQL type when writing a C-language function that uses a built-in type of <productname>PostgreSQL</productname>. The <quote>Defined In</quote> column gives the header file that needs to be included to get the type definition. (The actual definition might be in a different file that is included by the listed file. It is recommended that users stick to the defined interface.) Note that you should always include <filename>postgres.h</filename> first in any source file, because it declares a number of things that you will need anyway."
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1825(title) 
msgid "Equivalent C Types for Built-in SQL Types"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1829(entry) 
msgid "SQL Type"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1832(entry) 
msgid "C Type"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1835(entry) 
msgid "Defined In"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1842(type) 
msgid "abstime"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1843(type) 
msgid "AbsoluteTime"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1844(filename) /tmp/cicero-lkRf/xfunc.xml:1949(filename) /tmp/cicero-lkRf/xfunc.xml:1979(filename) 
msgid "utils/nabstime.h"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1847(type) 
msgid "boolean"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1848(type) 
msgid "bool"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1849(filename) /tmp/cicero-lkRf/xfunc.xml:1859(filename) /tmp/cicero-lkRf/xfunc.xml:1869(filename) /tmp/cicero-lkRf/xfunc.xml:1874(filename) /tmp/cicero-lkRf/xfunc.xml:1884(filename) /tmp/cicero-lkRf/xfunc.xml:1889(filename) /tmp/cicero-lkRf/xfunc.xml:1894(filename) /tmp/cicero-lkRf/xfunc.xml:1899(filename) /tmp/cicero-lkRf/xfunc.xml:1904(filename) /tmp/cicero-lkRf/xfunc.xml:1919(filename) /tmp/cicero-lkRf/xfunc.xml:1924(filename) /tmp/cicero-lkRf/xfunc.xml:1929(filename) /tmp/cicero-lkRf/xfunc.xml:1944(filename) /tmp/cicero-lkRf/xfunc.xml:1954(filename) /tmp/cicero-lkRf/xfunc.xml:1984(filename) /tmp/cicero-lkRf/xfunc.xml:1989(filename) 
msgid "postgres.h"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1849(entry) 
msgid "<placeholder-1/> (maybe compiler built-in)"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1852(type) 
msgid "box"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1853(type) 
msgid "BOX*"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1854(filename) /tmp/cicero-lkRf/xfunc.xml:1914(filename) /tmp/cicero-lkRf/xfunc.xml:1934(filename) /tmp/cicero-lkRf/xfunc.xml:1939(filename) 
msgid "utils/geo_decls.h"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1857(type) 
msgid "bytea"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1858(type) 
msgid "bytea*"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1862(type) 
msgid "\"char\""
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1863(type) 
msgid "char"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1864(entry) 
msgid "(compiler built-in)"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1867(type) 
msgid "character"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1868(type) 
msgid "BpChar*"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1872(type) 
msgid "cid"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1873(type) 
msgid "CommandId"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1877(type) 
msgid "date"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1878(type) 
msgid "DateADT"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1879(filename) /tmp/cicero-lkRf/xfunc.xml:1964(filename) /tmp/cicero-lkRf/xfunc.xml:1969(filename) 
msgid "utils/date.h"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1882(type) 
msgid "smallint"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1882(type) /tmp/cicero-lkRf/xfunc.xml:1883(type) 
msgid "int2"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1882(entry) /tmp/cicero-lkRf/xfunc.xml:1892(entry) /tmp/cicero-lkRf/xfunc.xml:1897(entry) /tmp/cicero-lkRf/xfunc.xml:1902(entry) 
msgid "<placeholder-1/> (<placeholder-2/>)"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1883(type) 
msgid "int16"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1883(entry) /tmp/cicero-lkRf/xfunc.xml:1893(entry) 
msgid "<placeholder-1/> or <placeholder-2/>"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1887(type) 
msgid "int2vector"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1888(type) 
msgid "int2vector*"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1892(type) 
msgid "integer"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1892(type) /tmp/cicero-lkRf/xfunc.xml:1893(type) 
msgid "int4"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1893(type) 
msgid "int32"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1897(type) 
msgid "real"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1897(type) 
msgid "float4"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1898(type) 
msgid "float4*"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1902(type) 
msgid "double precision"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1902(type) 
msgid "float8"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1903(type) 
msgid "float8*"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1907(type) 
msgid "interval"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1908(type) 
msgid "Interval*"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1909(filename) /tmp/cicero-lkRf/xfunc.xml:1974(filename) 
msgid "utils/timestamp.h"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1912(type) 
msgid "lseg"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1913(type) 
msgid "LSEG*"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1917(type) 
msgid "name"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1918(type) 
msgid "Name"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1922(type) 
msgid "oid"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1923(type) 
msgid "Oid"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1927(type) 
msgid "oidvector"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1928(type) 
msgid "oidvector*"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1932(type) 
msgid "path"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1933(type) 
msgid "PATH*"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1937(type) 
msgid "point"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1938(type) 
msgid "POINT*"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1942(type) /tmp/cicero-lkRf/xfunc.xml:1943(type) 
msgid "regproc"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1947(type) 
msgid "reltime"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1948(type) 
msgid "RelativeTime"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1952(type) 
msgid "text"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1953(type) 
msgid "text*"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1957(type) 
msgid "tid"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1958(type) 
msgid "ItemPointer"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1959(filename) 
msgid "storage/itemptr.h"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1962(type) 
msgid "time"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1963(type) 
msgid "TimeADT"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1967(type) 
msgid "time with time zone"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1968(type) 
msgid "TimeTzADT"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1972(type) 
msgid "timestamp"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1973(type) 
msgid "Timestamp*"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1977(type) 
msgid "tinterval"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1978(type) 
msgid "TimeInterval"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1982(type) 
msgid "varchar"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1983(type) 
msgid "VarChar*"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1987(type) 
msgid "xid"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1988(type) 
msgid "TransactionId"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1995(para) 
msgid "Now that we've gone over all of the possible structures for base types, we can show some examples of real functions."
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:2002(title) 
msgid "Version 0 Calling Conventions"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:2004(para) 
msgid "We present the <quote>old style</quote> calling convention first — although this approach is now deprecated, it's easier to get a handle on initially. In the version-0 method, the arguments and result of the C function are just declared in normal C style, but being careful to use the C representation of each SQL data type as shown above."
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:2013(para) 
msgid "Here are some examples: <placeholder-1/>"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:2097(programlisting) 
#, no-wrap
msgid "\nCREATE FUNCTION add_one(integer) RETURNS integer\n     AS '<replaceable>DIRECTORY</replaceable>/funcs', 'add_one'\n     LANGUAGE C STRICT;\n\n-- note overloading of SQL function name \"add_one\"\nCREATE FUNCTION add_one(double precision) RETURNS double precision\n     AS '<replaceable>DIRECTORY</replaceable>/funcs', 'add_one_float8'\n     LANGUAGE C STRICT;\n\nCREATE FUNCTION makepoint(point, point) RETURNS point\n     AS '<replaceable>DIRECTORY</replaceable>/funcs', 'makepoint'\n     LANGUAGE C STRICT;\n\nCREATE FUNCTION copytext(text) RETURNS text\n     AS '<replaceable>DIRECTORY</replaceable>/funcs', 'copytext'\n     LANGUAGE C STRICT;\n\nCREATE FUNCTION concat_text(text, text) RETURNS text\n     AS '<replaceable>DIRECTORY</replaceable>/funcs', 'concat_text'\n     LANGUAGE C STRICT;\n"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:2091(para) 
msgid "Supposing that the above code has been prepared in file <filename>funcs.c</filename> and compiled into a shared object, we could define the functions to <productname>PostgreSQL</productname> with commands like this: <placeholder-1/>"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:2121(para) 
msgid "Here, <replaceable>DIRECTORY</replaceable> stands for the directory of the shared library file (for instance the <productname>PostgreSQL</productname> tutorial directory, which contains the code for the examples used in this section). (Better style would be to use just <literal>'funcs'</literal> in the <literal>AS</literal> clause, after having added <replaceable>DIRECTORY</replaceable> to the search path. In any case, we can omit the system-specific extension for a shared library, commonly <literal>.so</literal> or <literal>.sl</literal>.)"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:2134(para) 
msgid "Notice that we have specified the functions as <quote>strict</quote>, meaning that the system should automatically assume a null result if any input value is null. By doing this, we avoid having to check for null inputs in the function code. Without this, we'd have to check for null values explicitly, by checking for a null pointer for each pass-by-reference argument. (For pass-by-value arguments, we don't even have a way to check!)"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:2145(para) 
msgid "Although this calling convention is simple to use, it is not very portable; on some architectures there are problems with passing data types that are smaller than <type>int</type> this way. Also, there is no simple way to return a null result, nor to cope with null arguments in any way other than making the function strict. The version-1 convention, presented next, overcomes these objections."
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:2156(title) 
msgid "Version 1 Calling Conventions"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:2162(programlisting) 
#, no-wrap
msgid "\nDatum funcname(PG_FUNCTION_ARGS)\n"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:2166(programlisting) 
#, no-wrap
msgid "\nPG_FUNCTION_INFO_V1(funcname);\n"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:2158(para) 
msgid "The version-1 calling convention relies on macros to suppress most of the complexity of passing arguments and results. The C declaration of a version-1 function is always: <placeholder-1/> In addition, the macro call: <placeholder-2/> must appear in the same source file. (Conventionally, it's written just before the function itself.) This macro call is not needed for <literal>internal</literal>-language functions, since <productname>PostgreSQL</productname> assumes that all internal functions use the version-1 convention. It is, however, required for dynamically-loaded functions."
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:2177(para) 
msgid "In a version-1 function, each actual argument is fetched using a <function>PG_GETARG_<replaceable>xxx</replaceable>()</function> macro that corresponds to the argument's data type, and the result is returned using a <function>PG_RETURN_<replaceable>xxx</replaceable>()</function> macro for the return type. <function>PG_GETARG_<replaceable>xxx</replaceable>()</function> takes as its argument the number of the function argument to fetch, where the count starts at 0. <function>PG_RETURN_<replaceable>xxx</replaceable>()</function> takes as its argument the actual value to return."
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:2191(para) 
msgid "Here we show the same functions as above, coded in version-1 style: <placeholder-1/>"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:2287(para) 
msgid "The <command>CREATE FUNCTION</command> commands are the same as for the version-0 equivalents."
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:2292(para) 
msgid "At first glance, the version-1 coding conventions might appear to be just pointless obscurantism. They do, however, offer a number of improvements, because the macros can hide unnecessary detail. An example is that in coding <function>add_one_float8</function>, we no longer need to be aware that <type>float8</type> is a pass-by-reference type. Another example is that the <literal>GETARG</literal> macros for variable-length types allow for more efficient fetching of <quote>toasted</quote> (compressed or out-of-line) values."
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:2303(para) 
msgid "One big improvement in version-1 functions is better handling of null inputs and results. The macro <function>PG_ARGISNULL(<replaceable>n</replaceable>)</function> allows a function to test whether each input is null. (Of course, doing this is only necessary in functions not declared <quote>strict</quote>.) As with the <function>PG_GETARG_<replaceable>xxx</replaceable>()</function> macros, the input arguments are counted beginning at zero. Note that one should refrain from executing <function>PG_GETARG_<replaceable>xxx</replaceable>()</function> until one has verified that the argument isn't null. To return a null result, execute <function>PG_RETURN_NULL()</function>; this works in both strict and nonstrict functions."
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:2318(para) 
msgid "Other options provided in the new-style interface are two variants of the <function>PG_GETARG_<replaceable>xxx</replaceable>()</function> macros. The first of these, <function>PG_GETARG_<replaceable>xxx</replaceable>_COPY()</function>, guarantees to return a copy of the specified argument that is safe for writing into. (The normal macros will sometimes return a pointer to a value that is physically stored in a table, which must not be written to. Using the <function>PG_GETARG_<replaceable>xxx</replaceable>_COPY()</function> macros guarantees a writable result.) The second variant consists of the <function>PG_GETARG_<replaceable>xxx</replaceable>_SLICE()</function> macros which take three arguments. The first is the number of the function argument (as above). The second and third are the offset and length of the segment to be returned. Offsets are counted from zero, and a negative length requests that the remainder of the value be returned. These macros provide more efficient access to parts of large values in the case where they have storage type <quote>external</quote>. (The storage type of a column can be specified using <literal>ALTER TABLE <replaceable>tablename</replaceable> ALTER COLUMN <replaceable>colname</replaceable> SET STORAGE <replaceable>storagetype</replaceable></literal>. <replaceable>storagetype</replaceable> is one of <literal>plain</literal>, <literal>external</literal>, <literal>extended</literal>, or <literal>main</literal>.)"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:2346(para) 
msgid "Finally, the version-1 function call conventions make it possible to return set results (<xref linkend=\"xfunc-c-return-set\"/>) and implement trigger functions (<xref linkend=\"triggers\"/>) and procedural-language call handlers (<xref linkend=\"plhandler\"/>). Version-1 code is also more portable than version-0, because it does not break restrictions on function call protocol in the C standard. For more details see <filename>src/backend/utils/fmgr/README</filename> in the source distribution."
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:2360(title) 
msgid "Writing Code"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:2362(para) 
msgid "Before we turn to the more advanced topics, we should discuss some coding rules for <productname>PostgreSQL</productname> C-language functions. While it might be possible to load functions written in languages other than C into <productname>PostgreSQL</productname>, this is usually difficult (when it is possible at all) because other languages, such as C++, FORTRAN, or Pascal often do not follow the same calling convention as C. That is, other languages do not pass argument and return values between functions in the same way. For this reason, we will assume that your C-language functions are actually written in C."
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:2381(para) 
msgid "Use <literal>pg_config --includedir-server</literal><indexterm><primary>pg_config</primary><secondary>with user-defined C functions</secondary></indexterm> to find out where the <productname>PostgreSQL</productname> server header files are installed on your system (or the system that your users will be running on)."
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:2391(para) 
msgid "Compiling and linking your code so that it can be dynamically loaded into <productname>PostgreSQL</productname> always requires special flags. See <xref linkend=\"dfunc\"/> for a detailed explanation of how to do it for your particular operating system."
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:2401(para) 
msgid "Remember to define a <quote>magic block</quote> for your shared library, as described in <xref linkend=\"xfunc-c-dynload\"/>."
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:2408(para) 
msgid "When allocating memory, use the <productname>PostgreSQL</productname> functions <function>palloc</function><indexterm><primary>palloc</primary></indexterm> and <function>pfree</function><indexterm><primary>pfree</primary></indexterm> instead of the corresponding C library functions <function>malloc</function> and <function>free</function>. The memory allocated by <function>palloc</function> will be freed automatically at the end of each transaction, preventing memory leaks."
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:2421(para) 
msgid "Always zero the bytes of your structures using <function>memset</function> (or allocate them with <function>palloc0</function> in the first place). Even if you assign to each field of your structure, there might be alignment padding (holes in the structure) that contain garbage values. Without this, it's difficult to support hash indexes or hash joins, as you must pick out only the significant bits of your data structure to compute a hash. The planner also sometimes relies on comparing constants via bitwise equality, so you can get undesirable planning results if logically-equivalent values aren't bitwise equal."
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:2436(para) 
msgid "Most of the internal <productname>PostgreSQL</productname> types are declared in <filename>postgres.h</filename>, while the function manager interfaces (<symbol>PG_FUNCTION_ARGS</symbol>, etc.) are in <filename>fmgr.h</filename>, so you will need to include at least these two files. For portability reasons it's best to include <filename>postgres.h</filename><emphasis>first</emphasis>, before any other system or user header files. Including <filename>postgres.h</filename> will also include <filename>elog.h</filename> and <filename>palloc.h</filename> for you."
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:2452(para) 
msgid "Symbol names defined within object files must not conflict with each other or with symbols defined in the <productname>PostgreSQL</productname> server executable. You will have to rename your functions or variables if you get error messages to this effect."
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:2376(para) 
msgid "The basic rules for writing and building C functions are as follows: <placeholder-1/>"
msgstr ""

#: /tmp/cicero-lkRf/xfunc.xml:1460(sect1) 
msgid "<placeholder-1/><indexterm zone=\"xfunc-c\"><placeholder-2/><placeholder-3/><placeholder-4/></indexterm><placeholder-5/><placeholder-6/><sect2 id=\"xfunc-c-dynload\"><placeholder-7/><indexterm zone=\"xfunc-c-dynload\"><placeholder-8/></indexterm><placeholder-9/><placeholder-10/><placeholder-11/><placeholder-12/><placeholder-13/><placeholder-14/><indexterm zone=\"xfunc-c-dynload\"><placeholder-15/></indexterm><placeholder-16/><placeholder-17/><indexterm zone=\"xfunc-c-dynload\"><placeholder-18/></indexterm><indexterm zone=\"xfunc-c-dynload\"><placeholder-19/></indexterm><indexterm zone=\"xfunc-c-dynload\"><placeholder-20/></indexterm><indexterm zone=\"xfunc-c-dynload\"><placeholder-21/></indexterm><placeholder-22/></sect2><sect2 id=\"xfunc-c-basetype\"><placeholder-23/><indexterm zone=\"xfunc-c-basetype\"><placeholder-24/><placeholder-25/></indexterm><placeholder-26/><placeholder-27/><placeholder-28/><placeholder-29/><placeholder-30/><placeholder-31/><placeholder-32/><placeholder-33/><placeholder-34/><placeholder-35/><table tocentry=\"1\" id=\"xfunc-c-type-table\"><placeholder-36/><tgroup cols=\"3\"><thead><row><placeholder-37/><placeholder-38/><placeholder-39/></row></thead><tbody><row><entry><placeholder-40/></entry><entry><placeholder-41/></entry><entry><placeholder-42/></entry></row><row><entry><placeholder-43/></entry><entry><placeholder-44/></entry><placeholder-45/></row><row><entry><placeholder-46/></entry><entry><placeholder-47/></entry><entry><placeholder-48/></entry></row><row><entry><placeholder-49/></entry><entry><placeholder-50/></entry><entry><placeholder-51/></entry></row><row><entry><placeholder-52/></entry><entry><placeholder-53/></entry><placeholder-54/></row><row><entry><placeholder-55/></entry><entry><placeholder-56/></entry><entry><placeholder-57/></entry></row><row><entry><placeholder-58/></entry><entry><placeholder-59/></entry><entry><placeholder-60/></entry></row><row><entry><placeholder-61/></entry><entry><placeholder-62/></entry><entry><placeholder-63/></entry></row><row><placeholder-64/><placeholder-65/><entry><placeholder-66/></entry></row><row><entry><placeholder-67/></entry><entry><placeholder-68/></entry><entry><placeholder-69/></entry></row><row><placeholder-70/><placeholder-71/><entry><placeholder-72/></entry></row><row><placeholder-73/><entry><placeholder-74/></entry><entry><placeholder-75/></entry></row><row><placeholder-76/><entry><placeholder-77/></entry><entry><placeholder-78/></entry></row><row><entry><placeholder-79/></entry><entry><placeholder-80/></entry><entry><placeholder-81/></entry></row><row><entry><placeholder-82/></entry><entry><placeholder-83/></entry><entry><placeholder-84/></entry></row><row><entry><placeholder-85/></entry><entry><placeholder-86/></entry><entry><placeholder-87/></entry></row><row><entry><placeholder-88/></entry><entry><placeholder-89/></entry><entry><placeholder-90/></entry></row><row><entry><placeholder-91/></entry><entry><placeholder-92/></entry><entry><placeholder-93/></entry></row><row><entry><placeholder-94/></entry><entry><placeholder-95/></entry><entry><placeholder-96/></entry></row><row><entry><placeholder-97/></entry><entry><placeholder-98/></entry><entry><placeholder-99/></entry></row><row><entry><placeholder-100/></entry><entry><placeholder-101/></entry><entry><placeholder-102/></entry></row><row><entry><placeholder-103/></entry><entry><placeholder-104/></entry><entry><placeholder-105/></entry></row><row><entry><placeholder-106/></entry><entry><placeholder-107/></entry><entry><placeholder-108/></entry></row><row><entry><placeholder-109/></entry><entry><placeholder-110/></entry><entry><placeholder-111/></entry></row><row><entry><placeholder-112/></entry><entry><placeholder-113/></entry><entry><placeholder-114/></entry></row><row><entry><placeholder-115/></entry><entry><placeholder-116/></entry><entry><placeholder-117/></entry></row><row><entry><placeholder-118/></entry><entry><placeholder-119/></entry><entry><placeholder-120/></entry></row><row><entry><placeholder-121/></entry><entry><placeholder-122/></entry><entry><placeholder-123/></entry></row><row><entry><placeholder-124/></entry><entry><placeholder-125/></entry><entry><placeholder-126/></entry></row><row><entry><placeholder-127/></entry><entry><placeholder-128/></entry><entry><placeholder-129/></entry></row></tbody></tgroup></table><placeholder-130/></sect2><placeholder-131/><placeholder-132/><placeholder-133/> Composite-type Arguments Composite types do not have a fixed layout like C structures. Instances of a composite type can contain null fields. In addition, composite types that are part of an inheritance hierarchy can have different fields than other members of the same inheritance hierarchy. Therefore, PostgreSQL provides a function interface for accessing fields of composite types from C. Suppose we want to write a function to answer the query: SELECT name, c_overpaid(emp, 1500) AS overpaid FROM emp WHERE name = 'Bill' OR name = 'Sam'; Using call conventions version 0, we can define c_overpaid as: In version-1 coding, the above would look like this: GetAttributeByName is the PostgreSQL system function that returns attributes out of the specified row. It has three arguments: the argument of type HeapTupleHeader passed into the function, the name of the desired attribute, and a return parameter that tells whether the attribute is null. GetAttributeByName returns a Datum value that you can convert to the proper data type by using the appropriate DatumGetXXX() macro. Note that the return value is meaningless if the null flag is set; always check the null flag before trying to do anything with the result. There is also GetAttributeByNum, which selects the target attribute by column number instead of name. The following command declares the function c_overpaid in SQL: CREATE FUNCTION c_overpaid(emp, integer) RETURNS boolean AS 'DIRECTORY/funcs', 'c_overpaid' LANGUAGE C STRICT; Notice we have used STRICT so that we did not have to check whether the input arguments were NULL. Returning Rows (Composite Types) To return a row or composite-type value from a C-language function, you can use a special API that provides macros and functions to hide most of the complexity of building composite data types. To use this API, the source file must include: #include \"funcapi.h\" There are two ways you can build a composite data value (henceforth a tuple): you can build it from an array of Datum values, or from an array of C strings that can be passed to the input conversion functions of the tuple's column data types. In either case, you first need to obtain or construct a TupleDesc descriptor for the tuple structure. When working with Datums, you pass the TupleDesc to BlessTupleDesc, and then call heap_form_tuple for each row. When working with C strings, you pass the TupleDesc to TupleDescGetAttInMetadata, and then call BuildTupleFromCStrings for each row. In the case of a function returning a set of tuples, the setup steps can all be done once during the first call of the function. Several helper functions are available for setting up the needed TupleDesc. The recommended way to do this in most functions returning composite values is to call: TypeFuncClass get_call_result_type(FunctionCallInfo fcinfo, Oid *resultTypeId, TupleDesc *resultTupleDesc) passing the same fcinfo struct passed to the calling function itself. (This of course requires that you use the version-1 calling conventions.) resultTypeId can be specified as NULL or as the address of a local variable to receive the function's result type OID. resultTupleDesc should be the address of a local TupleDesc variable. Check that the result is TYPEFUNC_COMPOSITE; if so, resultTupleDesc has been filled with the needed TupleDesc. (If it is not, you can report an error along the lines of function returning record called in context that cannot accept type record.) get_call_result_type can resolve the actual type of a polymorphic function result; so it is useful in functions that return scalar polymorphic results, not only functions that return composites. The resultTypeId output is primarily useful for functions returning polymorphic scalars. get_call_result_type has a sibling get_expr_result_type, which can be used to resolve the expected output type for a function call represented by an expression tree. This can be used when trying to determine the result type from outside the function itself. There is also get_func_result_type, which can be used when only the function's OID is available. However these functions are not able to deal with functions declared to return record, and get_func_result_type cannot resolve polymorphic types, so you should preferentially use get_call_result_type. Older, now-deprecated functions for obtaining TupleDescs are: TupleDesc RelationNameGetTupleDesc(const char *relname) to get a TupleDesc for the row type of a named relation, and: TupleDesc TypeGetTupleDesc(Oid typeoid, List *colaliases) to get a TupleDesc based on a type OID. This can be used to get a TupleDesc for a base or composite type. It will not work for a function that returns record, however, and it cannot resolve polymorphic types. Once you have a TupleDesc, call: TupleDesc BlessTupleDesc(TupleDesc tupdesc) if you plan to work with Datums, or: AttInMetadata *TupleDescGetAttInMetadata(TupleDesc tupdesc) if you plan to work with C strings. If you are writing a function returning set, you can save the results of these functions in the FuncCallContext structure tuple_desc or attinmeta field respectively. When working with Datums, use: HeapTuple heap_form_tuple(TupleDesc tupdesc, Datum *values, bool *isnull) to build a HeapTuple given user data in Datum form. When working with C strings, use: HeapTuple BuildTupleFromCStrings(AttInMetadata *attinmeta, char **values) to build a HeapTuple given user data in C string form. values is an array of C strings, one for each attribute of the return row. Each C string should be in the form expected by the input function of the attribute data type. In order to return a null value for one of the attributes, the corresponding pointer in the values array should be set to NULL. This function will need to be called again for each row you return. Once you have built a tuple to return from your function, it must be converted into a Datum. Use: HeapTupleGetDatum(HeapTuple tuple) to convert a HeapTuple into a valid Datum. This Datum can be returned directly if you intend to return just a single row, or it can be used as the current return value in a set-returning function. An example appears in the next section. Returning Sets There is also a special API that provides support for returning sets (multiple rows) from a C-language function. A set-returning function must follow the version-1 calling conventions. Also, source files must include funcapi.h, as above. A set-returning function (SRF) is called once for each item it returns. The SRF must therefore save enough state to remember what it was doing and return the next item on each call. The structure FuncCallContext is provided to help control this process. Within a function, fcinfo-flinfo-fn_extra is used to hold a pointer to FuncCallContext across calls. typedef struct { /* * Number of times we've been called before * * call_cntr is initialized to 0 for you by SRF_FIRSTCALL_INIT(), and * incremented for you every time SRF_RETURN_NEXT() is called. */ uint32 call_cntr; /* * OPTIONAL maximum number of calls * * max_calls is here for convenience only and setting it is optional. * If not set, you must provide alternative means to know when the * function is done. */ uint32 max_calls; /* * OPTIONAL pointer to result slot * * This is obsolete and only present for backward compatibility, viz, * user-defined SRFs that use the deprecated TupleDescGetSlot(). */ TupleTableSlot *slot; /* * OPTIONAL pointer to miscellaneous user-provided context information * * user_fctx is for use as a pointer to your own data to retain * arbitrary context information between calls of your function. */ void *user_fctx; /* * OPTIONAL pointer to struct containing attribute type input metadata * * attinmeta is for use when returning tuples (i.e., composite data types) * and is not used when returning base data types. It is only needed * if you intend to use BuildTupleFromCStrings() to create the return * tuple. */ AttInMetadata *attinmeta; /* * memory context used for structures that must live for multiple calls * * multi_call_memory_ctx is set by SRF_FIRSTCALL_INIT() for you, and used * by SRF_RETURN_DONE() for cleanup. It is the most appropriate memory * context for any memory that is to be reused across multiple calls * of the SRF. */ MemoryContext multi_call_memory_ctx; /* * OPTIONAL pointer to struct containing tuple description * * tuple_desc is for use when returning tuples (i.e., composite data types) * and is only needed if you are going to build the tuples with * heap_form_tuple() rather than with BuildTupleFromCStrings(). Note that * the TupleDesc pointer stored here should usually have been run through * BlessTupleDesc() first. */ TupleDesc tuple_desc; } FuncCallContext; An SRF uses several functions and macros that automatically manipulate the FuncCallContext structure (and expect to find it via fn_extra). Use: SRF_IS_FIRSTCALL() to determine if your function is being called for the first or a subsequent time. On the first call (only) use: SRF_FIRSTCALL_INIT() to initialize the FuncCallContext. On every function call, including the first, use: SRF_PERCALL_SETUP() to properly set up for using the FuncCallContext and clearing any previously returned data left over from the previous pass. If your function has data to return, use: SRF_RETURN_NEXT(funcctx, result) to return it to the caller. (result must be of type Datum, either a single value or a tuple prepared as described above.) Finally, when your function is finished returning data, use: SRF_RETURN_DONE(funcctx) to clean up and end the SRF. The memory context that is current when the SRF is called is a transient context that will be cleared between calls. This means that you do not need to call pfree on everything you allocated using palloc; it will go away anyway. However, if you want to allocate any data structures to live across calls, you need to put them somewhere else. The memory context referenced by multi_call_memory_ctx is a suitable location for any data that needs to survive until the SRF is finished running. In most cases, this means that you should switch into multi_call_memory_ctx while doing the first-call setup. A complete pseudo-code example looks like the following: Datum my_set_returning_function(PG_FUNCTION_ARGS) { FuncCallContext *funcctx; Datum result; further declarations as needed if (SRF_IS_FIRSTCALL()) { MemoryContext oldcontext; funcctx = SRF_FIRSTCALL_INIT(); oldcontext = MemoryContextSwitchTo(funcctx-multi_call_memory_ctx); /* One-time setup code appears here: */ user code if returning composite build TupleDesc, and perhaps AttInMetadata endif returning composite user code MemoryContextSwitchTo(oldcontext); } /* Each-time setup code appears here: */ user code funcctx = SRF_PERCALL_SETUP(); user code /* this is just one way we might test whether we are done: */ if (funcctx-call_cntr funcctx-max_calls) { /* Here we want to return another item: */ user code obtain result Datum SRF_RETURN_NEXT(funcctx, result); } else { /* Here we are done returning items and just need to clean up: */ user code SRF_RETURN_DONE(funcctx); } } A complete example of a simple SRF returning a composite type looks like: One way to declare this function in SQL is: CREATE TYPE __retcomposite AS (f1 integer, f2 integer, f3 integer); CREATE OR REPLACE FUNCTION retcomposite(integer, integer) RETURNS SETOF __retcomposite AS 'filename', 'retcomposite' LANGUAGE C IMMUTABLE STRICT; A different way is to use OUT parameters: CREATE OR REPLACE FUNCTION retcomposite(IN integer, IN integer, OUT f1 integer, OUT f2 integer, OUT f3 integer) RETURNS SETOF record AS 'filename', 'retcomposite' LANGUAGE C IMMUTABLE STRICT; Notice that in this method the output type of the function is formally an anonymous record type. The directory contrib/tablefunc module in the source distribution contains more examples of set-returning functions. Polymorphic Arguments and Return Types C-language functions can be declared to accept and return the polymorphic types anyelement, anyarray, anynonarray, and anyenum. See for a more detailed explanation of polymorphic functions. When function arguments or return types are defined as polymorphic types, the function author cannot know in advance what data type it will be called with, or need to return. There are two routines provided in fmgr.h to allow a version-1 C function to discover the actual data types of its arguments and the type it is expected to return. The routines are called get_fn_expr_rettype(FmgrInfo *flinfo) and get_fn_expr_argtype(FmgrInfo *flinfo, int argnum). They return the result or argument type OID, or InvalidOid if the information is not available. The structure flinfo is normally accessed as fcinfo-flinfo. The parameter argnum is zero based. get_call_result_type can also be used as an alternative to get_fn_expr_rettype. For example, suppose we want to write a function to accept a single element of any type, and return a one-dimensional array of that type: PG_FUNCTION_INFO_V1(make_array); Datum make_array(PG_FUNCTION_ARGS) { ArrayType *result; Oid element_type = get_fn_expr_argtype(fcinfo-flinfo, 0); Datum element; bool isnull; int16 typlen; bool typbyval; char typalign; int ndims; int dims[MAXDIM]; int lbs[MAXDIM]; if (!OidIsValid(element_type)) elog(ERROR, \"could not determine data type of input\"); /* get the provided element, being careful in case it's NULL */ isnull = PG_ARGISNULL(0); if (isnull) element = (Datum) 0; else element = PG_GETARG_DATUM(0); /* we have one dimension */ ndims = 1; /* and one element */ dims[0] = 1; /* and lower bound is 1 */ lbs[0] = 1; /* get required info about the element type */ get_typlenbyvalalign(element_type, typlen, typbyval, typalign); /* now build the array */ result = construct_md_array(element, isnull, ndims, dims, lbs, element_type, typlen, typbyval, typalign); PG_RETURN_ARRAYTYPE_P(result); } The following command declares the function make_array in SQL: CREATE FUNCTION make_array(anyelement) RETURNS anyarray AS 'DIRECTORY/funcs', 'make_array' LANGUAGE C IMMUTABLE; There is a variant of polymorphism that is only available to C-language functions: they can be declared to take parameters of type \"any\". (Note that this type name must be double-quoted, since it's also a SQL reserved word.) This works like anyelement except that it does not constrain different \"any\" arguments to be the same type, nor do they help determine the function's result type. A C-language function can also declare its final parameter to be VARIADIC \"any\". This will match one or more actual arguments of any type (not necessarily the same type). These arguments will not be gathered into an array as happens with normal variadic functions; they will just be passed to the function separately. The PG_NARGS() macro and the methods described above must be used to determine the number of actual arguments and their types when using this feature. Shared Memory and LWLocks Add-ins can reserve LWLocks and an allocation of shared memory on server startup. The add-in's shared library must be preloaded by specifying it in shared_preload_libraries. Shared memory is reserved by calling: void RequestAddinShmemSpace(int size) from your _PG_init function. LWLocks are reserved by calling: void RequestAddinLWLocks(int n) from _PG_init. To avoid possible race-conditions, each backend should use the LWLock AddinShmemInitLock when connecting to and initializing its allocation of shared memory, as shown here: static mystruct *ptr = NULL; if (!ptr) { bool found; LWLockAcquire(AddinShmemInitLock, LW_EXCLUSIVE); ptr = ShmemInitStruct(\"my struct name\", size, found); if (!found) { initialize contents of shmem area; acquire any requested LWLocks using: ptr-&gt;mylockid = LWLockAssign(); } LWLockRelease(AddinShmemInitLock); } Using C++ for Extensibility C++ Although the PostgreSQL backend is written in C, it is possible to write extensions in C++ if these guidelines are followed: All functions accessed by the backend must present a C interface to the backend; these C functions can then call C++ functions. For example, extern C linkage is required for backend-accessed functions. This is also necessary for any functions that are passed as pointers between the backend and C++ code. Free memory using the appropriate deallocation method. For example, most backend memory is allocated using palloc(), so use pfree() to free it. Using C++ delete in such cases will fail. Prevent exceptions from propagating into the C code (use a catch-all block at the top level of all extern C functions). This is necessary even if the C++ code does not explicitly throw any exceptions, because events like out-of-memory can still throw exceptions. Any exceptions must be caught and appropriate errors passed back to the C interface. If possible, compile C++ with -fno-exceptions to eliminate exceptions entirely; in such cases, you must check for failures in your C++ code, e.g. check for NULL returned by new(). If calling backend functions from C++ code, be sure that the C++ call stack contains only plain old data structures (POD). This is necessary because backend errors generate a distant longjmp() that does not properly unroll a C++ call stack with non-POD objects. In summary, it is best to place C++ code behind a wall of extern C functions that interface to the backend, and avoid exception, memory, and call stack leakage."
msgstr ""

#. Put one translator per line, in the form of NAME <EMAIL>, YEAR1, YEAR2.
#: /tmp/cicero-lkRf/xfunc.xml:0(None) 
msgid "translator-credits"
msgstr ""

