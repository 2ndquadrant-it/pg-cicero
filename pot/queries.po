msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2011-09-08 06:57+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: /tmp/cicero-lWzA/queries.xml:5(title) 
msgid "Queries"
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:8(primary) 
msgid "query"
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:12(primary) /tmp/cicero-lWzA/queries.xml:1034(primary) 
msgid "SELECT"
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:15(para) 
msgid "The previous chapters explained how to create tables, how to fill them with data, and how to manipulate that data. Now we finally discuss how to retrieve the data from the database."
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:23(title) 
msgid "Overview"
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:25(para) 
msgid "The process of retrieving or the command to retrieve data from a database is called a <firstterm>query</firstterm>. In SQL the <xref linkend=\"sql-select\"/> command is used to specify queries. The general syntax of the <command>SELECT</command> command is <synopsis>\n<optional>WITH <replaceable>with_queries</replaceable></optional> SELECT <replaceable>select_list</replaceable> FROM <replaceable>table_expression</replaceable> <optional><replaceable>sort_specification</replaceable></optional>\n</synopsis> The following sections describe the details of the select list, the table expression, and the sort specification. <literal>WITH</literal> queries are treated last since they are an advanced feature."
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:41(programlisting) 
#, no-wrap
msgid "\nSELECT * FROM table1;\n"
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:58(programlisting) 
#, no-wrap
msgid "\nSELECT a, b + c FROM table1;\n"
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:39(para) 
msgid "A simple kind of query has the form: <placeholder-1/> Assuming that there is a table called <literal>table1</literal>, this command would retrieve all rows and all columns from <literal>table1</literal>. (The method of retrieval depends on the client application. For example, the <application>psql</application> program will display an ASCII-art table on the screen, while client libraries will offer functions to extract individual values from the query result.) The select list specification <literal>*</literal> means all columns that the table expression happens to provide. A select list can also select a subset of the available columns or make calculations using the columns. For example, if <literal>table1</literal> has columns named <literal>a</literal>, <literal>b</literal>, and <literal>c</literal> (and perhaps others) you can make the following query: <placeholder-2/> (assuming that <literal>b</literal> and <literal>c</literal> are of a numerical data type). See <xref linkend=\"queries-select-lists\"/> for more details."
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:72(programlisting) 
#, no-wrap
msgid "\nSELECT 3 * 4;\n"
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:77(programlisting) 
#, no-wrap
msgid "\nSELECT random();\n"
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:66(para) 
msgid "<literal>FROM table1</literal> is a simple kind of table expression: it reads just one table. In general, table expressions can be complex constructs of base tables, joins, and subqueries. But you can also omit the table expression entirely and use the <command>SELECT</command> command as a calculator: <placeholder-1/> This is more useful if the expressions in the select list return varying results. For example, you could call a function this way: <placeholder-2/>"
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:85(title) 
msgid "Table Expressions"
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:88(primary) 
msgid "table expression"
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:91(para) 
msgid "A <firstterm>table expression</firstterm> computes a table. The table expression contains a <literal>FROM</literal> clause that is optionally followed by <literal>WHERE</literal>, <literal>GROUP BY</literal>, and <literal>HAVING</literal> clauses. Trivial table expressions simply refer to a table on disk, a so-called base table, but more complex expressions can be used to modify or combine base tables in various ways."
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:101(para) 
msgid "The optional <literal>WHERE</literal>, <literal>GROUP BY</literal>, and <literal>HAVING</literal> clauses in the table expression specify a pipeline of successive transformations performed on the table derived in the <literal>FROM</literal> clause. All these transformations produce a virtual table that provides the rows that are passed to the select list to compute the output rows of the query."
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:111(title) 
msgid "The <literal>FROM</literal> Clause"
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:113(para) 
msgid "The <xref linkend=\"sql-from\" endterm=\"sql-from-title\"/> derives a table from one or more other tables given in a comma-separated table reference list. <synopsis>\nFROM <replaceable>table_reference</replaceable> <optional>, <replaceable>table_reference</replaceable> <optional>, ...</optional></optional>\n</synopsis> A table reference can be a table name (possibly schema-qualified), or a derived table such as a subquery, a table join, or complex combinations of these. If more than one table reference is listed in the <literal>FROM</literal> clause they are cross-joined (see below) to form the intermediate virtual table that can then be subject to transformations by the <literal>WHERE</literal>, <literal>GROUP BY</literal>, and <literal>HAVING</literal> clauses and is finally the result of the overall table expression."
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:132(primary) 
msgid "ONLY"
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:135(para) 
msgid "When a table reference names a table that is the parent of a table inheritance hierarchy, the table reference produces rows of not only that table but all of its descendant tables, unless the key word <literal>ONLY</literal> precedes the table name. However, the reference produces only the columns that appear in the named table â€” any columns added in subtables are ignored."
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:145(title) 
msgid "Joined Tables"
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:148(primary) /tmp/cicero-lWzA/queries.xml:164(primary) /tmp/cicero-lWzA/queries.xml:203(primary) /tmp/cicero-lWzA/queries.xml:294(primary) /tmp/cicero-lWzA/queries.xml:317(primary) 
msgid "join"
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:151(para) 
msgid "A joined table is a table derived from two other (real or derived) tables according to the rules of the particular join type. Inner, outer, and cross-joins are available."
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:158(title) 
msgid "Join Types"
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:161(term) 
msgid "Cross join"
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:165(secondary) 
msgid "cross"
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:169(primary) 
msgid "cross join"
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:174(replaceable) /tmp/cicero-lWzA/queries.xml:213(replaceable) /tmp/cicero-lWzA/queries.xml:214(replaceable) /tmp/cicero-lWzA/queries.xml:215(replaceable) 
msgid "T1"
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:174(replaceable) /tmp/cicero-lWzA/queries.xml:213(replaceable) /tmp/cicero-lWzA/queries.xml:214(replaceable) /tmp/cicero-lWzA/queries.xml:215(replaceable) 
msgid "T2"
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:173(synopsis) 
#, no-wrap
msgid "\n<placeholder-1/> CROSS JOIN <placeholder-2/>\n"
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:177(para) 
msgid "For every possible combination of rows from <replaceable>T1</replaceable> and <replaceable>T2</replaceable> (i.e., a Cartesian product), the joined table will contain a row consisting of all columns in <replaceable>T1</replaceable> followed by all columns in <replaceable>T2</replaceable>. If the tables have N and M rows respectively, the joined table will have N * M rows."
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:188(para) 
msgid "<literal>FROM <replaceable>T1</replaceable> CROSS JOIN <replaceable>T2</replaceable></literal> is equivalent to <literal>FROM <replaceable>T1</replaceable>, <replaceable>T2</replaceable></literal>. It is also equivalent to <literal>FROM <replaceable>T1</replaceable> INNER JOIN <replaceable>T2</replaceable> ON TRUE</literal> (see below)."
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:200(term) 
msgid "Qualified joins"
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:204(secondary) 
msgid "outer"
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:208(primary) 
msgid "outer join"
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:213(optional) /tmp/cicero-lWzA/queries.xml:214(optional) /tmp/cicero-lWzA/queries.xml:215(optional) 
msgid "INNER"
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:213(optional) /tmp/cicero-lWzA/queries.xml:214(optional) /tmp/cicero-lWzA/queries.xml:215(optional) 
msgid "OUTER"
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:213(replaceable) 
msgid "boolean_expression"
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:214(replaceable) 
msgid "join column list"
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:212(synopsis) 
#, no-wrap
msgid "\n<placeholder-1/> { <placeholder-2/> | { LEFT | RIGHT | FULL } <placeholder-3/> } JOIN <placeholder-4/> ON <placeholder-5/>\n<placeholder-6/> { <placeholder-7/> | { LEFT | RIGHT | FULL } <placeholder-8/> } JOIN <placeholder-9/> USING ( <placeholder-10/> )\n<placeholder-11/> NATURAL { <placeholder-12/> | { LEFT | RIGHT | FULL } <placeholder-13/> } JOIN <placeholder-14/>\n"
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:218(para) 
msgid "The words <literal>INNER</literal> and <literal>OUTER</literal> are optional in all forms. <literal>INNER</literal> is the default; <literal>LEFT</literal>, <literal>RIGHT</literal>, and <literal>FULL</literal> imply an outer join."
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:226(para) 
msgid "The <firstterm>join condition</firstterm> is specified in the <literal>ON</literal> or <literal>USING</literal> clause, or implicitly by the word <literal>NATURAL</literal>. The join condition determines which rows from the two source tables are considered to <quote>match</quote>, as explained in detail below."
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:234(para) 
msgid "The <literal>ON</literal> clause is the most general kind of join condition: it takes a Boolean value expression of the same kind as is used in a <literal>WHERE</literal> clause. A pair of rows from <replaceable>T1</replaceable> and <replaceable>T2</replaceable> match if the <literal>ON</literal> expression evaluates to true for them."
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:242(para) 
msgid "<literal>USING</literal> is a shorthand notation: it takes a comma-separated list of column names, which the joined tables must have in common, and forms a join condition specifying equality of each of these pairs of columns. Furthermore, the output of <literal>JOIN USING</literal> has one column for each of the equated pairs of input columns, followed by the remaining columns from each table. Thus, <literal>USING (a, b, c)</literal> is equivalent to <literal>ON (t1.a = t2.a AND t1.b = t2.b AND t1.c = t2.c)</literal> with the exception that if <literal>ON</literal> is used there will be two columns <literal>a</literal>, <literal>b</literal>, and <literal>c</literal> in the result, whereas with <literal>USING</literal> there will be only one of each (and they will appear first if <command>SELECT *</command> is used)."
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:258(para) 
msgid "<indexterm><primary>join</primary><secondary>natural</secondary></indexterm><indexterm><primary>natural join</primary></indexterm> Finally, <literal>NATURAL</literal> is a shorthand form of <literal>USING</literal>: it forms a <literal>USING</literal> list consisting of all column names that appear in both input tables. As with <literal>USING</literal>, these columns appear only once in the output table. If there are no common columns, <literal>NATURAL</literal> behaves like <literal>CROSS JOIN</literal>."
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:280(literal) 
msgid "INNER JOIN"
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:283(para) 
msgid "For each row R1 of T1, the joined table has a row for each row in T2 that satisfies the join condition with R1."
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:291(literal) 
msgid "LEFT OUTER JOIN"
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:295(secondary) 
msgid "left"
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:299(primary) 
msgid "left join"
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:303(para) 
msgid "First, an inner join is performed. Then, for each row in T1 that does not satisfy the join condition with any row in T2, a joined row is added with null values in columns of T2. Thus, the joined table always has at least one row for each row in T1."
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:314(literal) 
msgid "RIGHT OUTER JOIN"
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:318(secondary) 
msgid "right"
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:322(primary) 
msgid "right join"
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:326(para) 
msgid "First, an inner join is performed. Then, for each row in T2 that does not satisfy the join condition with any row in T1, a joined row is added with null values in columns of T1. This is the converse of a left join: the result table will always have a row for each row in T2."
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:337(literal) 
msgid "FULL OUTER JOIN"
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:340(para) 
msgid "First, an inner join is performed. Then, for each row in T1 that does not satisfy the join condition with any row in T2, a joined row is added with null values in columns of T2. Also, for each row of T2 that does not satisfy the join condition with any row in T1, a joined row with null values in the columns of T1 is added."
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:275(para) 
msgid "The possible types of qualified join are: <placeholder-1/>"
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:356(para) 
msgid "Joins of all types can be chained together or nested: either or both <replaceable>T1</replaceable> and <replaceable>T2</replaceable> can be joined tables. Parentheses can be used around <literal>JOIN</literal> clauses to control the join order. In the absence of parentheses, <literal>JOIN</literal> clauses nest left-to-right."
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:367(programlisting) 
#, no-wrap
msgid "\n num | name\n-----+------\n   1 | a\n   2 | b\n   3 | c\n"
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:375(programlisting) 
#, no-wrap
msgid "\n num | value\n-----+-------\n   1 | xxx\n   3 | yyy\n   5 | zzz\n"
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:365(para) 
msgid "To put this together, assume we have tables <literal>t1</literal>: <placeholder-1/> and <literal>t2</literal>: <placeholder-2/> then we get the following results for the various joins: <screen>\n<prompt>=&gt;</prompt> <userinput>SELECT * FROM t1 CROSS JOIN t2;</userinput>\n num | name | num | value\n-----+------+-----+-------\n   1 | a    |   1 | xxx\n   1 | a    |   3 | yyy\n   1 | a    |   5 | zzz\n   2 | b    |   1 | xxx\n   2 | b    |   3 | yyy\n   2 | b    |   5 | zzz\n   3 | c    |   1 | xxx\n   3 | c    |   3 | yyy\n   3 | c    |   5 | zzz\n(9 rows)\n\n<prompt>=&gt;</prompt> <userinput>SELECT * FROM t1 INNER JOIN t2 ON t1.num = t2.num;</userinput>\n num | name | num | value\n-----+------+-----+-------\n   1 | a    |   1 | xxx\n   3 | c    |   3 | yyy\n(2 rows)\n\n<prompt>=&gt;</prompt> <userinput>SELECT * FROM t1 INNER JOIN t2 USING (num);</userinput>\n num | name | value\n-----+------+-------\n   1 | a    | xxx\n   3 | c    | yyy\n(2 rows)\n\n<prompt>=&gt;</prompt> <userinput>SELECT * FROM t1 NATURAL INNER JOIN t2;</userinput>\n num | name | value\n-----+------+-------\n   1 | a    | xxx\n   3 | c    | yyy\n(2 rows)\n\n<prompt>=&gt;</prompt> <userinput>SELECT * FROM t1 LEFT JOIN t2 ON t1.num = t2.num;</userinput>\n num | name | num | value\n-----+------+-----+-------\n   1 | a    |   1 | xxx\n   2 | b    |     |\n   3 | c    |   3 | yyy\n(3 rows)\n\n<prompt>=&gt;</prompt> <userinput>SELECT * FROM t1 LEFT JOIN t2 USING (num);</userinput>\n num | name | value\n-----+------+-------\n   1 | a    | xxx\n   2 | b    |\n   3 | c    | yyy\n(3 rows)\n\n<prompt>=&gt;</prompt> <userinput>SELECT * FROM t1 RIGHT JOIN t2 ON t1.num = t2.num;</userinput>\n num | name | num | value\n-----+------+-----+-------\n   1 | a    |   1 | xxx\n   3 | c    |   3 | yyy\n     |      |   5 | zzz\n(3 rows)\n\n<prompt>=&gt;</prompt> <userinput>SELECT * FROM t1 FULL JOIN t2 ON t1.num = t2.num;</userinput>\n num | name | num | value\n-----+------+-----+-------\n   1 | a    |   1 | xxx\n   2 | b    |     |\n   3 | c    |   3 | yyy\n     |      |   5 | zzz\n(4 rows)\n</screen>"
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:454(para) 
msgid "The join condition specified with <literal>ON</literal> can also contain conditions that do not relate directly to the join. This can prove useful for some queries but needs to be thought out carefully. For example: <screen>\n<prompt>=&gt;</prompt> <userinput>SELECT * FROM t1 LEFT JOIN t2 ON t1.num = t2.num AND t2.value = 'xxx';</userinput>\n num | name | num | value\n-----+------+-----+-------\n   1 | a    |   1 | xxx\n   2 | b    |     |\n   3 | c    |     |\n(3 rows)\n</screen> Notice that placing the restriction in the <literal>WHERE</literal> clause produces a different result: <screen>\n<prompt>=&gt;</prompt> <userinput>SELECT * FROM t1 LEFT JOIN t2 ON t1.num = t2.num WHERE t2.value = 'xxx';</userinput>\n num | name | num | value\n-----+------+-----+-------\n   1 | a    |   1 | xxx\n(1 row)\n</screen> This is because a restriction placed in the <literal>ON</literal> clause is processed <emphasis>before</emphasis> the join, while a restriction placed in the <literal>WHERE</literal> clause is processed <emphasis>after</emphasis> the join."
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:485(title) 
msgid "Table and Column Aliases"
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:488(primary) /tmp/cicero-lWzA/queries.xml:494(see) /tmp/cicero-lWzA/queries.xml:1102(primary) 
msgid "alias"
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:489(secondary) /tmp/cicero-lWzA/queries.xml:627(secondary) 
msgid "in the FROM clause"
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:493(primary) 
msgid "label"
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:497(para) 
msgid "A temporary name can be given to tables and complex table references to be used for references to the derived table in the rest of the query. This is called a <firstterm>table alias</firstterm>."
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:504(para) 
msgid "To create a table alias, write <synopsis>\nFROM <replaceable>table_reference</replaceable> AS <replaceable>alias</replaceable>\n</synopsis> or <synopsis>\nFROM <replaceable>table_reference</replaceable> <replaceable>alias</replaceable>\n</synopsis> The <literal>AS</literal> key word is optional noise. <replaceable>alias</replaceable> can be any identifier."
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:521(programlisting) 
#, no-wrap
msgid "\nSELECT * FROM some_very_long_table_name s JOIN another_fairly_long_name a ON s.id = a.num;\n"
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:517(para) 
msgid "A typical application of table aliases is to assign short identifiers to long table names to keep the join clauses readable. For example: <placeholder-1/>"
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:531(programlisting) 
#, no-wrap
msgid "\nSELECT * FROM my_table AS m WHERE my_table.a &gt; 5;    -- wrong\n"
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:526(para) 
msgid "The alias becomes the new name of the table reference so far as the current query is concerned â€” it is not allowed to refer to the table by the original name elsewhere in the query. Thus, this is not valid: <placeholder-1/>"
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:539(programlisting) 
#, no-wrap
msgid "\nSELECT * FROM people AS mother JOIN people AS child ON mother.id = child.mother_id;\n"
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:536(para) 
msgid "Table aliases are mainly for notational convenience, but it is necessary to use them when joining a table to itself, e.g.: <placeholder-1/> Additionally, an alias is required if the table reference is a subquery (see <xref linkend=\"queries-subqueries\"/>)."
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:551(programlisting) 
#, no-wrap
msgid "\nSELECT * FROM my_table AS a CROSS JOIN my_table AS b ...\nSELECT * FROM (my_table AS a CROSS JOIN my_table) AS b ...\n"
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:546(para) 
msgid "Parentheses are used to resolve ambiguities. In the following example, the first statement assigns the alias <literal>b</literal> to the second instance of <literal>my_table</literal>, but the second statement assigns the alias to the result of the join: <placeholder-1/>"
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:557(para) 
msgid "Another form of table aliasing gives temporary names to the columns of the table, as well as the table itself: <synopsis>\nFROM <replaceable>table_reference</replaceable> <optional>AS</optional> <replaceable>alias</replaceable> ( <replaceable>column1</replaceable> <optional>, <replaceable>column2</replaceable> <optional>, ...</optional></optional> )\n</synopsis> If fewer column aliases are specified than the actual table has columns, the remaining columns are not renamed. This syntax is especially useful for self-joins or subqueries."
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:572(programlisting) 
#, no-wrap
msgid "\nSELECT a.* FROM my_table AS a JOIN your_table AS b ON ...\n"
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:576(programlisting) 
#, no-wrap
msgid "\nSELECT a.* FROM (my_table AS a JOIN your_table AS b ON ...) AS c\n"
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:568(para) 
msgid "When an alias is applied to the output of a <literal>JOIN</literal> clause, the alias hides the original name(s) within the <literal>JOIN</literal>. For example: <placeholder-1/> is valid SQL, but: <placeholder-2/> is not valid; the table alias <literal>a</literal> is not visible outside the alias <literal>c</literal>."
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:585(title) 
msgid "Subqueries"
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:588(primary) 
msgid "subquery"
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:596(programlisting) 
#, no-wrap
msgid "\nFROM (SELECT * FROM table1) AS alias_name\n"
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:591(para) 
msgid "Subqueries specifying a derived table must be enclosed in parentheses and <emphasis>must</emphasis> be assigned a table alias name. (See <xref linkend=\"queries-table-aliases\"/>.) For example: <placeholder-1/>"
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:601(para) 
msgid "This example is equivalent to <literal>FROM table1 AS alias_name</literal>. More interesting cases, which cannot be reduced to a plain join, arise when the subquery involves grouping or aggregation."
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:610(programlisting) 
#, no-wrap
msgid "\nFROM (VALUES ('anne', 'smith'), ('bob', 'jones'), ('joe', 'blow'))\n     AS names(first, last)\n"
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:608(para) 
msgid "A subquery can also be a <command>VALUES</command> list: <placeholder-1/> Again, a table alias is required. Assigning alias names to the columns of the <command>VALUES</command> list is optional, but is good practice. For more information see <xref linkend=\"queries-values\"/>."
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:621(title) 
msgid "Table Functions"
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:623(primary) 
msgid "table function"
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:626(primary) 
msgid "function"
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:630(para) 
msgid "Table functions are functions that produce a set of rows, made up of either base data types (scalar types) or composite data types (table rows). They are used like a table, view, or subquery in the <literal>FROM</literal> clause of a query. Columns returned by table functions can be included in <literal>SELECT</literal>, <literal>JOIN</literal>, or <literal>WHERE</literal> clauses in the same manner as a table, view, or subquery column."
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:640(para) 
msgid "If a table function returns a base data type, the single result column name matches the function name. If the function returns a composite type, the result columns get the same names as the individual attributes of the type."
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:647(para) 
msgid "A table function can be aliased in the <literal>FROM</literal> clause, but it also can be left unaliased. If a function is used in the <literal>FROM</literal> clause with no alias, the function name is used as the resulting table name."
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:656(programlisting) 
#, no-wrap
msgid "\nCREATE TABLE foo (fooid int, foosubid int, fooname text);\n\nCREATE FUNCTION getfoo(int) RETURNS SETOF foo AS $$\n    SELECT * FROM foo WHERE fooid = $1;\n$$ LANGUAGE SQL;\n\nSELECT * FROM getfoo(1) AS t1;\n\nSELECT * FROM foo\n    WHERE foosubid IN (\n                        SELECT foosubid\n                        FROM getfoo(foo.fooid) z\n                        WHERE z.fooid = foo.fooid\n                      );\n\nCREATE VIEW vw_getfoo AS SELECT * FROM getfoo(1);\n\nSELECT * FROM vw_getfoo;\n"
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:654(para) 
msgid "Some examples: <placeholder-1/>"
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:686(programlisting) 
#, no-wrap
msgid "\nSELECT *\n    FROM dblink('dbname=mydb', 'SELECT proname, prosrc FROM pg_proc')\n      AS t1(proname name, prosrc text)\n    WHERE proname LIKE 'bytea%';\n"
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:678(para) 
msgid "In some cases it is useful to define table functions that can return different column sets depending on how they are invoked. To support this, the table function can be declared as returning the pseudotype <type>record</type>. When such a function is used in a query, the expected row structure must be specified in the query itself, so that the system can know how to parse and plan the query. Consider this example: <placeholder-1/> The <xref linkend=\"contrib-dblink-function\"/> function (part of the <xref linkend=\"dblink\"/> module&gt;) executes a remote query. It is declared to return <type>record</type> since it might be used for any kind of query. The actual column set must be specified in the calling query so that the parser knows, for example, what <literal>*</literal> should expand to."
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:704(title) 
msgid "The <literal>WHERE</literal> Clause"
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:707(primary) 
msgid "WHERE"
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:710(para) 
msgid "The syntax of the <xref linkend=\"sql-where\" endterm=\"sql-where-title\"/> is <synopsis>\nWHERE <replaceable>search_condition</replaceable>\n</synopsis> where <replaceable>search_condition</replaceable> is any value expression (see <xref linkend=\"sql-expressions\"/>) that returns a value of type <type>boolean</type>."
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:721(para) 
msgid "After the processing of the <literal>FROM</literal> clause is done, each row of the derived virtual table is checked against the search condition. If the result of the condition is true, the row is kept in the output table, otherwise (i.e., if the result is false or null) it is discarded. The search condition typically references at least one column of the table generated in the <literal>FROM</literal> clause; this is not required, but otherwise the <literal>WHERE</literal> clause will be fairly useless."
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:737(programlisting) 
#, no-wrap
msgid "\nFROM a, b WHERE a.id = b.id AND b.val &gt; 5\n"
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:741(programlisting) 
#, no-wrap
msgid "\nFROM a INNER JOIN b ON (a.id = b.id) WHERE b.val &gt; 5\n"
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:745(programlisting) 
#, no-wrap
msgid "\nFROM a NATURAL JOIN b WHERE b.val &gt; 5\n"
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:733(para) 
msgid "The join condition of an inner join can be written either in the <literal>WHERE</literal> clause or in the <literal>JOIN</literal> clause. For example, these table expressions are equivalent: <placeholder-1/> and: <placeholder-2/> or perhaps even: <placeholder-3/> Which one of these you use is mainly a matter of style. The <literal>JOIN</literal> syntax in the <literal>FROM</literal> clause is probably not as portable to other SQL database management systems, even though it is in the SQL standard. For outer joins there is no choice: they must be done in the <literal>FROM</literal> clause. The <literal>ON</literal> or <literal>USING</literal> clause of an outer join is <emphasis>not</emphasis> equivalent to a <literal>WHERE</literal> condition, because it results in the addition of rows (for unmatched input rows) as well as the removal of rows in the final result."
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:763(programlisting) 
#, no-wrap
msgid "\nSELECT ... FROM fdt WHERE c1 &gt; 5\n\nSELECT ... FROM fdt WHERE c1 IN (1, 2, 3)\n\nSELECT ... FROM fdt WHERE c1 IN (SELECT c1 FROM t2)\n\nSELECT ... FROM fdt WHERE c1 IN (SELECT c3 FROM t2 WHERE c2 = fdt.c1 + 10)\n\nSELECT ... FROM fdt WHERE c1 BETWEEN (SELECT c3 FROM t2 WHERE c2 = fdt.c1 + 10) AND 100\n\nSELECT ... FROM fdt WHERE EXISTS (SELECT c1 FROM t2 WHERE c2 &gt; fdt.c1)\n"
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:761(para) 
msgid "Here are some examples of <literal>WHERE</literal> clauses: <placeholder-1/><literal>fdt</literal> is the table derived in the <literal>FROM</literal> clause. Rows that do not meet the search condition of the <literal>WHERE</literal> clause are eliminated from <literal>fdt</literal>. Notice the use of scalar subqueries as value expressions. Just like any other query, the subqueries can employ complex table expressions. Notice also how <literal>fdt</literal> is referenced in the subqueries. Qualifying <literal>c1</literal> as <literal>fdt.c1</literal> is only necessary if <literal>c1</literal> is also the name of a column in the derived input table of the subquery. But qualifying the column name adds clarity even when it is not needed. This example shows how the column naming scope of an outer query extends into its inner queries."
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:793(title) 
msgid "The <literal>GROUP BY</literal> and <literal>HAVING</literal> Clauses"
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:796(primary) 
msgid "GROUP BY"
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:800(primary) 
msgid "grouping"
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:803(para) 
msgid "After passing the <literal>WHERE</literal> filter, the derived input table might be subject to grouping, using the <literal>GROUP BY</literal> clause, and elimination of group rows using the <literal>HAVING</literal> clause."
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:811(replaceable) 
msgid "select_list"
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:813(optional) 
msgid "WHERE ..."
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:814(replaceable) /tmp/cicero-lWzA/queries.xml:814(replaceable) 
msgid "grouping_column_reference"
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:814(optional) 
msgid ", <placeholder-1/>"
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:810(synopsis) 
#, no-wrap
msgid "\nSELECT <placeholder-1/>\n    FROM ...\n    <placeholder-2/>\n    GROUP BY <placeholder-3/> <placeholder-4/>...\n"
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:817(para) 
msgid "The <xref linkend=\"sql-groupby\" endterm=\"sql-groupby-title\"/> is used to group together those rows in a table that have the same values in all the columns listed. The order in which the columns are listed does not matter. The effect is to combine each set of rows having common values into one group row that represents all rows in the group. This is done to eliminate redundancy in the output and/or compute aggregates that apply to these groups. For instance: <screen>\n<prompt>=&gt;</prompt> <userinput>SELECT * FROM test1;</userinput>\n x | y\n---+---\n a | 3\n c | 2\n b | 5\n a | 1\n(4 rows)\n\n<prompt>=&gt;</prompt> <userinput>SELECT x FROM test1 GROUP BY x;</userinput>\n x\n---\n a\n b\n c\n(3 rows)\n</screen>"
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:846(para) 
msgid "In the second query, we could not have written <literal>SELECT * FROM test1 GROUP BY x</literal>, because there is no single value for the column <literal>y</literal> that could be associated with each group. The grouped-by columns can be referenced in the select list since they have a single value in each group."
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:854(para) 
msgid "In general, if a table is grouped, columns that are not listed in <literal>GROUP BY</literal> cannot be referenced except in aggregate expressions. An example with aggregate expressions is: <screen>\n<prompt>=&gt;</prompt> <userinput>SELECT x, sum(y) FROM test1 GROUP BY x;</userinput>\n x | sum\n---+-----\n a |   4\n b |   5\n c |   2\n(3 rows)\n</screen> Here <literal>sum</literal> is an aggregate function that computes a single value over the entire group. More information about the available aggregate functions can be found in <xref linkend=\"functions-aggregate\"/>."
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:874(para) 
msgid "Grouping without aggregate expressions effectively calculates the set of distinct values in a column. This can also be achieved using the <literal>DISTINCT</literal> clause (see <xref linkend=\"queries-distinct\"/>)."
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:885(programlisting) 
#, no-wrap
msgid "\nSELECT product_id, p.name, (sum(s.units) * p.price) AS sales\n    FROM products p LEFT JOIN sales s USING (product_id)\n    GROUP BY product_id, p.name, p.price;\n"
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:882(para) 
msgid "Here is another example: it calculates the total sales for each product (rather than the total sales of all products): <placeholder-1/> In this example, the columns <literal>product_id</literal>, <literal>p.name</literal>, and <literal>p.price</literal> must be in the <literal>GROUP BY</literal> clause since they are referenced in the query select list (but see below). The column <literal>s.units</literal> does not have to be in the <literal>GROUP BY</literal> list since it is only used in an aggregate expression (<literal>sum(...)</literal>), which represents the sales of a product. For each product, the query returns a summary row about all sales of the product."
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:901(primary) 
msgid "functional dependency"
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:903(para) 
msgid "If the products table is set up so that, say, <literal>product_id</literal> is the primary key, then it would be enough to group by <literal>product_id</literal> in the above example, since name and price would be <firstterm>functionally dependent</firstterm> on the product ID, and so there would be no ambiguity about which name and price value to return for each product ID group."
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:913(para) 
msgid "In strict SQL, <literal>GROUP BY</literal> can only group by columns of the source table but <productname>PostgreSQL</productname> extends this to also allow <literal>GROUP BY</literal> to group by columns in the select list. Grouping by value expressions instead of simple column names is also allowed."
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:922(primary) 
msgid "HAVING"
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:925(para) 
msgid "If a table has been grouped using <literal>GROUP BY</literal>, but only certain groups are of interest, the <literal>HAVING</literal> clause can be used, much like a <literal>WHERE</literal> clause, to eliminate groups from the result. The syntax is: <synopsis>\nSELECT <replaceable>select_list</replaceable> FROM ... <optional>WHERE ...</optional> GROUP BY ... HAVING <replaceable>boolean_expression</replaceable>\n</synopsis> Expressions in the <literal>HAVING</literal> clause can refer both to grouped expressions and to ungrouped expressions (which necessarily involve an aggregate function)."
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:939(para) 
msgid "Example: <screen>\n<prompt>=&gt;</prompt> <userinput>SELECT x, sum(y) FROM test1 GROUP BY x HAVING sum(y) &gt; 3;</userinput>\n x | sum\n---+-----\n a |   4\n b |   5\n(2 rows)\n\n<prompt>=&gt;</prompt> <userinput>SELECT x, sum(y) FROM test1 GROUP BY x HAVING x &lt; 'c';</userinput>\n x | sum\n---+-----\n a |   4\n b |   5\n(2 rows)\n</screen>"
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:960(programlisting) 
#, no-wrap
msgid "\nSELECT product_id, p.name, (sum(s.units) * (p.price - p.cost)) AS profit\n    FROM products p LEFT JOIN sales s USING (product_id)\n    WHERE s.date &gt; CURRENT_DATE - INTERVAL '4 weeks'\n    GROUP BY product_id, p.name, p.price, p.cost\n    HAVING sum(p.price * s.units) &gt; 5000;\n"
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:958(para) 
msgid "Again, a more realistic example: <placeholder-1/> In the example above, the <literal>WHERE</literal> clause is selecting rows by a column that is not grouped (the expression is only true for sales during the last four weeks), while the <literal>HAVING</literal> clause restricts the output to groups with total gross sales over 5000. Note that the aggregate expressions do not necessarily need to be the same in all parts of the query."
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:975(para) 
msgid "If a query contains aggregate function calls, but no <literal>GROUP BY</literal> clause, grouping still occurs: the result is a single group row (or perhaps no rows at all, if the single row is then eliminated by <literal>HAVING</literal>). The same is true if it contains a <literal>HAVING</literal> clause, even without any aggregate function calls or <literal>GROUP BY</literal> clause."
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:986(title) 
msgid "Window Function Processing"
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:989(primary) 
msgid "window function"
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:990(secondary) 
msgid "order of execution"
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:993(para) 
msgid "If the query contains any window functions (see <xref linkend=\"tutorial-window\"/>, <xref linkend=\"functions-window\"/> and <xref linkend=\"syntax-window-functions\"/>), these functions are evaluated after any grouping, aggregation, and <literal>HAVING</literal> filtering is performed. That is, if the query uses any aggregates, <literal>GROUP BY</literal>, or <literal>HAVING</literal>, then the rows seen by the window functions are the group rows instead of the original table rows from <literal>FROM</literal>/<literal>WHERE</literal>."
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:1005(para) 
msgid "When multiple window functions are used, all the window functions having syntactically equivalent <literal>PARTITION BY</literal> and <literal>ORDER BY</literal> clauses in their window definitions are guaranteed to be evaluated in a single pass over the data. Therefore they will see the same sort ordering, even if the <literal>ORDER BY</literal> does not uniquely determine an ordering. However, no guarantees are made about the evaluation of functions having different <literal>PARTITION BY</literal> or <literal>ORDER BY</literal> specifications. (In such cases a sort step is typically required between the passes of window function evaluations, and the sort is not guaranteed to preserve ordering of rows that its <literal>ORDER BY</literal> sees as equivalent.)"
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:1018(para) 
msgid "Currently, window functions always require presorted data, and so the query output will be ordered according to one or another of the window functions' <literal>PARTITION BY</literal>/<literal>ORDER BY</literal> clauses. It is not recommendable to rely on this, however. Use an explicit top-level <literal>ORDER BY</literal> clause if you want to be sure the results are sorted in a particular way."
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:1031(title) 
msgid "Select Lists"
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:1035(secondary) 
msgid "select list"
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:1038(para) 
msgid "As shown in the previous section, the table expression in the <command>SELECT</command> command constructs an intermediate virtual table by possibly combining tables, views, eliminating rows, grouping, etc. This table is finally passed on to processing by the <firstterm>select list</firstterm>. The select list determines which <emphasis>columns</emphasis> of the intermediate table are actually output."
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:1049(title) 
msgid "Select-List Items"
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:1052(primary) 
msgid "*"
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:1061(programlisting) 
#, no-wrap
msgid "\nSELECT a, b, c FROM ...\n"
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:1055(para) 
msgid "The simplest kind of select list is <literal>*</literal> which emits all columns that the table expression produces. Otherwise, a select list is a comma-separated list of value expressions (as defined in <xref linkend=\"sql-expressions\"/>). For instance, it could be a list of column names: <placeholder-1/> The columns names <literal>a</literal>, <literal>b</literal>, and <literal>c</literal> are either the actual names of the columns of tables referenced in the <literal>FROM</literal> clause, or the aliases given to them as explained in <xref linkend=\"queries-table-aliases\"/>. The name space available in the select list is the same as in the <literal>WHERE</literal> clause, unless grouping is used, in which case it is the same as in the <literal>HAVING</literal> clause."
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:1076(programlisting) 
#, no-wrap
msgid "\nSELECT tbl1.a, tbl2.a, tbl1.b FROM ...\n"
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:1081(programlisting) 
#, no-wrap
msgid "\nSELECT tbl1.*, tbl2.a FROM ...\n"
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:1073(para) 
msgid "If more than one table has a column of the same name, the table name must also be given, as in: <placeholder-1/> When working with multiple tables, it can also be useful to ask for all the columns of a particular table: <placeholder-2/> (See also <xref linkend=\"queries-where\"/>.)"
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:1087(para) 
msgid "If an arbitrary value expression is used in the select list, it conceptually adds a new virtual column to the returned table. The value expression is evaluated once for each result row, with the row's values substituted for any column references. But the expressions in the select list do not have to reference any columns in the table expression of the <literal>FROM</literal> clause; they can be constant arithmetic expressions, for instance."
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:1099(title) 
msgid "Column Labels"
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:1103(secondary) 
msgid "in the select list"
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:1110(programlisting) 
#, no-wrap
msgid "\nSELECT a AS value, b + c AS sum FROM ...\n"
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:1106(para) 
msgid "The entries in the select list can be assigned names for subsequent processing, such as for use in an <literal>ORDER BY</literal> clause or for display by the client application. For example: <placeholder-1/>"
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:1115(para) 
msgid "If no output column name is specified using <literal>AS</literal>, the system assigns a default column name. For simple column references, this is the name of the referenced column. For function calls, this is the name of the function. For complex expressions, the system will generate a generic name."
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:1130(programlisting) 
#, no-wrap
msgid "\nSELECT a value, b + c AS sum FROM ...\n"
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:1134(programlisting) 
#, no-wrap
msgid "\nSELECT a \"value\", b + c AS sum FROM ...\n"
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:1123(para) 
msgid "The <literal>AS</literal> keyword is optional, but only if the new column name does not match any <productname>PostgreSQL</productname> keyword (see <xref linkend=\"sql-keywords-appendix\"/>). To avoid an accidental match to a keyword, you can double-quote the column name. For example, <literal>VALUE</literal> is a keyword, so this does not work: <placeholder-1/> but this does: <placeholder-2/> For protection against possible future keyword additions, it is recommended that you always either write <literal>AS</literal> or double-quote the output column name."
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:1143(para) 
msgid "The naming of output columns here is different from that done in the <literal>FROM</literal> clause (see <xref linkend=\"queries-table-aliases\"/>). It is possible to rename the same column twice, but the name assigned in the select list is the one that will be passed on."
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:1154(literal) /tmp/cicero-lWzA/queries.xml:1157(primary) 
msgid "DISTINCT"
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:1161(primary) 
msgid "duplicates"
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:1164(para) 
msgid "After the select list has been processed, the result table can optionally be subject to the elimination of duplicate rows. The <literal>DISTINCT</literal> key word is written directly after <literal>SELECT</literal> to specify this: <synopsis>\nSELECT DISTINCT <replaceable>select_list</replaceable> ...\n</synopsis> (Instead of <literal>DISTINCT</literal> the key word <literal>ALL</literal> can be used to specify the default behavior of retaining all rows.)"
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:1177(primary) 
msgid "null value"
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:1178(secondary) 
msgid "in DISTINCT"
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:1181(para) 
msgid "Obviously, two rows are considered distinct if they differ in at least one column value. Null values are considered equal in this comparison."
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:1187(para) 
msgid "Alternatively, an arbitrary expression can determine what rows are to be considered distinct: <synopsis>\nSELECT DISTINCT ON (<replaceable>expression</replaceable> <optional>, <replaceable>expression</replaceable> ...</optional>) <replaceable>select_list</replaceable> ...\n</synopsis> Here <replaceable>expression</replaceable> is an arbitrary value expression that is evaluated for all rows. A set of rows for which all the expressions are equal are considered duplicates, and only the first row of the set is kept in the output. Note that the <quote>first row</quote> of a set is unpredictable unless the query is sorted on enough columns to guarantee a unique ordering of the rows arriving at the <literal>DISTINCT</literal> filter. (<literal>DISTINCT ON</literal> processing occurs after <literal>ORDER BY</literal> sorting.)"
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:1204(para) 
msgid "The <literal>DISTINCT ON</literal> clause is not part of the SQL standard and is sometimes considered bad style because of the potentially indeterminate nature of its results. With judicious use of <literal>GROUP BY</literal> and subqueries in <literal>FROM</literal>, this construct can be avoided, but it is often the most convenient alternative."
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:1217(title) 
msgid "Combining Queries"
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:1220(primary) 
msgid "UNION"
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:1223(primary) 
msgid "INTERSECT"
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:1226(primary) 
msgid "EXCEPT"
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:1229(primary) 
msgid "set union"
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:1232(primary) 
msgid "set intersection"
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:1235(primary) 
msgid "set difference"
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:1238(primary) 
msgid "set operation"
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:1241(para) 
msgid "The results of two queries can be combined using the set operations union, intersection, and difference. The syntax is <synopsis>\n<replaceable>query1</replaceable> UNION <optional>ALL</optional> <replaceable>query2</replaceable>\n<replaceable>query1</replaceable> INTERSECT <optional>ALL</optional> <replaceable>query2</replaceable>\n<replaceable>query1</replaceable> EXCEPT <optional>ALL</optional> <replaceable>query2</replaceable>\n</synopsis><replaceable>query1</replaceable> and <replaceable>query2</replaceable> are queries that can use any of the features discussed up to this point. Set operations can also be nested and chained, for example <synopsis>\n<replaceable>query1</replaceable> UNION <replaceable>query2</replaceable> UNION <replaceable>query3</replaceable>\n</synopsis> which is executed as: <synopsis>\n(<replaceable>query1</replaceable> UNION <replaceable>query2</replaceable>) UNION <replaceable>query3</replaceable>\n</synopsis>"
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:1262(para) 
msgid "<literal>UNION</literal> effectively appends the result of <replaceable>query2</replaceable> to the result of <replaceable>query1</replaceable> (although there is no guarantee that this is the order in which the rows are actually returned). Furthermore, it eliminates duplicate rows from its result, in the same way as <literal>DISTINCT</literal>, unless <literal>UNION ALL</literal> is used."
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:1271(para) 
msgid "<literal>INTERSECT</literal> returns all rows that are both in the result of <replaceable>query1</replaceable> and in the result of <replaceable>query2</replaceable>. Duplicate rows are eliminated unless <literal>INTERSECT ALL</literal> is used."
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:1278(para) 
msgid "<literal>EXCEPT</literal> returns all rows that are in the result of <replaceable>query1</replaceable> but not in the result of <replaceable>query2</replaceable>. (This is sometimes called the <firstterm>difference</firstterm> between two queries.) Again, duplicates are eliminated unless <literal>EXCEPT ALL</literal> is used."
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:1286(para) 
msgid "In order to calculate the union, intersection, or difference of two queries, the two queries must be <quote>union compatible</quote>, which means that they return the same number of columns and the corresponding columns have compatible data types, as described in <xref linkend=\"typeconv-union-case\"/>."
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:1297(title) 
msgid "Sorting Rows"
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:1300(primary) 
msgid "sorting"
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:1304(primary) 
msgid "ORDER BY"
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:1307(para) 
msgid "After a query has produced an output table (after the select list has been processed) it can optionally be sorted. If sorting is not chosen, the rows will be returned in an unspecified order. The actual order in that case will depend on the scan and join plan types and the order on disk, but it must not be relied on. A particular output ordering can only be guaranteed if the sort step is explicitly chosen."
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:1327(programlisting) 
#, no-wrap
msgid "\nSELECT a, b FROM table1 ORDER BY a + b, c;\n"
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:1340(para) 
msgid "Actually, <productname>PostgreSQL</productname> uses the <firstterm>default B-tree operator class</firstterm> for the expression's data type to determine the sort ordering for <literal>ASC</literal> and <literal>DESC</literal>. Conventionally, data types will be set up so that the <literal>&lt;</literal> and <literal>&gt;</literal> operators correspond to this sort ordering, but a user-defined data type's designer could choose to do something different."
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:1317(para) 
msgid "The <literal>ORDER BY</literal> clause specifies the sort order: <synopsis>\nSELECT <replaceable>select_list</replaceable>\n    FROM <replaceable>table_expression</replaceable>\n    ORDER BY <replaceable>sort_expression1</replaceable> <optional>ASC | DESC</optional> <optional>NULLS { FIRST | LAST }</optional>\n             <optional>, <replaceable>sort_expression2</replaceable> <optional>ASC | DESC</optional> <optional>NULLS { FIRST | LAST }</optional> ...</optional>\n</synopsis> The sort expression(s) can be any expression that would be valid in the query's select list. An example is: <placeholder-1/> When more than one expression is specified, the later values are used to sort rows that are equal according to the earlier values. Each expression can be followed by an optional <literal>ASC</literal> or <literal>DESC</literal> keyword to set the sort direction to ascending or descending. <literal>ASC</literal> order is the default. Ascending order puts smaller values first, where <quote>smaller</quote> is defined in terms of the <literal>&lt;</literal> operator. Similarly, descending order is determined with the <literal>&gt;</literal> operator. <placeholder-2/>"
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:1352(para) 
msgid "The <literal>NULLS FIRST</literal> and <literal>NULLS LAST</literal> options can be used to determine whether nulls appear before or after non-null values in the sort ordering. By default, null values sort as if larger than any non-null value; that is, <literal>NULLS FIRST</literal> is the default for <literal>DESC</literal> order, and <literal>NULLS LAST</literal> otherwise."
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:1360(para) 
msgid "Note that the ordering options are considered independently for each sort column. For example <literal>ORDER BY x, y DESC</literal> means <literal>ORDER BY x ASC, y DESC</literal>, which is not the same as <literal>ORDER BY x DESC, y DESC</literal>."
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:1370(programlisting) 
#, no-wrap
msgid "\nSELECT a + b AS sum, c FROM table1 ORDER BY sum;\nSELECT a, max(b) FROM table1 GROUP BY a ORDER BY 1;\n"
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:1377(programlisting) 
#, no-wrap
msgid "\nSELECT a + b AS sum, c FROM table1 ORDER BY sum + c;          -- wrong\n"
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:1367(para) 
msgid "A <replaceable>sort_expression</replaceable> can also be the column label or number of an output column, as in: <placeholder-1/> both of which sort by the first output column. Note that an output column name has to stand alone, that is, it cannot be used in an expression â€” for example, this is <emphasis>not</emphasis> correct: <placeholder-2/> This restriction is made to reduce ambiguity. There is still ambiguity if an <literal>ORDER BY</literal> item is a simple name that could match either an output column name or a column from the table expression. The output column is used in such cases. This would only cause confusion if you use <literal>AS</literal> to rename an output column to match some other table column's name."
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:1388(para) 
msgid "<literal>ORDER BY</literal> can be applied to the result of a <literal>UNION</literal>, <literal>INTERSECT</literal>, or <literal>EXCEPT</literal> combination, but in this case it is only permitted to sort by output column names or numbers, not by expressions."
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:1398(title) 
msgid "<literal>LIMIT</literal> and <literal>OFFSET</literal>"
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:1401(primary) 
msgid "LIMIT"
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:1405(primary) 
msgid "OFFSET"
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:1408(para) 
msgid "<literal>LIMIT</literal> and <literal>OFFSET</literal> allow you to retrieve just a portion of the rows that are generated by the rest of the query: <synopsis>\nSELECT <replaceable>select_list</replaceable>\n    FROM <replaceable>table_expression</replaceable>\n    <optional> ORDER BY ... </optional>\n    <optional> LIMIT { <replaceable>number</replaceable> | ALL } </optional> <optional> OFFSET <replaceable>number</replaceable> </optional>\n</synopsis>"
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:1419(para) 
msgid "If a limit count is given, no more than that many rows will be returned (but possibly less, if the query itself yields less rows). <literal>LIMIT ALL</literal> is the same as omitting the <literal>LIMIT</literal> clause."
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:1426(para) 
msgid "<literal>OFFSET</literal> says to skip that many rows before beginning to return rows. <literal>OFFSET 0</literal> is the same as omitting the <literal>OFFSET</literal> clause, and <literal>LIMIT NULL</literal> is the same as omitting the <literal>LIMIT</literal> clause. If both <literal>OFFSET</literal> and <literal>LIMIT</literal> appear, then <literal>OFFSET</literal> rows are skipped before starting to count the <literal>LIMIT</literal> rows that are returned."
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:1436(para) 
msgid "When using <literal>LIMIT</literal>, it is important to use an <literal>ORDER BY</literal> clause that constrains the result rows into a unique order. Otherwise you will get an unpredictable subset of the query's rows. You might be asking for the tenth through twentieth rows, but tenth through twentieth in what ordering? The ordering is unknown, unless you specified <literal>ORDER BY</literal>."
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:1445(para) 
msgid "The query optimizer takes <literal>LIMIT</literal> into account when generating query plans, so you are very likely to get different plans (yielding different row orders) depending on what you give for <literal>LIMIT</literal> and <literal>OFFSET</literal>. Thus, using different <literal>LIMIT</literal>/<literal>OFFSET</literal> values to select different subsets of a query result <emphasis>will give inconsistent results</emphasis> unless you enforce a predictable result ordering with <literal>ORDER BY</literal>. This is not a bug; it is an inherent consequence of the fact that SQL does not promise to deliver the results of a query in any particular order unless <literal>ORDER BY</literal> is used to constrain the order."
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:1459(para) 
msgid "The rows skipped by an <literal>OFFSET</literal> clause still have to be computed inside the server; therefore a large <literal>OFFSET</literal> might be inefficient."
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:1468(title) 
msgid "<literal>VALUES</literal> Lists"
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:1471(primary) 
msgid "VALUES"
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:1474(para) 
msgid "<literal>VALUES</literal> provides a way to generate a <quote>constant table</quote> that can be used in a query without having to actually create and populate a table on-disk. The syntax is <synopsis>\nVALUES ( <replaceable class=\"PARAMETER\">expression</replaceable> [, ...] ) [, ...]\n</synopsis> Each parenthesized list of expressions generates a row in the table. The lists must all have the same number of elements (i.e., the number of columns in the table), and corresponding entries in each list must have compatible data types. The actual data type assigned to each column of the result is determined using the same rules as for <literal>UNION</literal> (see <xref linkend=\"typeconv-union-case\"/>)."
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:1491(programlisting) 
#, no-wrap
msgid "\nVALUES (1, 'one'), (2, 'two'), (3, 'three');\n"
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:1497(programlisting) 
#, no-wrap
msgid "\nSELECT 1 AS column1, 'one' AS column2\nUNION ALL\nSELECT 2, 'two'\nUNION ALL\nSELECT 3, 'three';\n"
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:1489(para) 
msgid "As an example: <placeholder-1/> will return a table of two columns and three rows. It's effectively equivalent to: <placeholder-2/> By default, <productname>PostgreSQL</productname> assigns the names <literal>column1</literal>, <literal>column2</literal>, etc. to the columns of a <literal>VALUES</literal> table. The column names are not specified by the SQL standard and different database systems do it differently, so it's usually better to override the default names with a table alias list."
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:1513(para) 
msgid "Syntactically, <literal>VALUES</literal> followed by expression lists is treated as equivalent to: <synopsis>\nSELECT <replaceable>select_list</replaceable> FROM <replaceable>table_expression</replaceable>\n</synopsis> and can appear anywhere a <literal>SELECT</literal> can. For example, you can use it as part of a <literal>UNION</literal>, or attach a <replaceable>sort_specification</replaceable> (<literal>ORDER BY</literal>, <literal>LIMIT</literal>, and/or <literal>OFFSET</literal>) to it. <literal>VALUES</literal> is most commonly used as the data source in an <command>INSERT</command> command, and next most commonly as a subquery."
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:1527(para) 
msgid "For more information see <xref linkend=\"sql-values\"/>."
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:1535(title) 
msgid "<literal>WITH</literal> Queries (Common Table Expressions)"
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:1538(primary) /tmp/cicero-lWzA/queries.xml:1544(see) 
msgid "WITH"
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:1539(secondary) 
msgid "in SELECT"
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:1543(primary) 
msgid "common table expression"
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:1547(para) 
msgid "<literal>WITH</literal> provides a way to write auxiliary statements for use in a larger query. These statements, which are often referred to as Common Table Expressions or <acronym>CTE</acronym>s, can be thought of as defining temporary tables that exist just for one query. Each auxiliary statement in a <literal>WITH</literal> clause can be a <command>SELECT</command>, <command>INSERT</command>, <command>UPDATE</command>, or <command>DELETE</command>; and the <literal>WITH</literal> clause itself is attached to a primary statement that can also be a <command>SELECT</command>, <command>INSERT</command>, <command>UPDATE</command>, or <command>DELETE</command>."
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:1560(title) 
msgid "<command>SELECT</command> in <literal>WITH</literal>"
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:1566(programlisting) 
#, no-wrap
msgid "\nWITH regional_sales AS (\n        SELECT region, SUM(amount) AS total_sales\n        FROM orders\n        GROUP BY region\n     ), top_regions AS (\n        SELECT region\n        FROM regional_sales\n        WHERE total_sales &gt; (SELECT SUM(total_sales)/10 FROM regional_sales)\n     )\nSELECT region,\n       product,\n       SUM(quantity) AS product_units,\n       SUM(amount) AS product_sales\nFROM orders\nWHERE region IN (SELECT region FROM top_regions)\nGROUP BY region, product;\n"
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:1562(para) 
msgid "The basic value of <command>SELECT</command> in <literal>WITH</literal> is to break down complicated queries into simpler parts. An example is: <placeholder-1/> which displays per-product sales totals in only the top sales regions. The <literal>WITH</literal> clause defines two auxiliary statements named <structname>regional_sales</structname> and <structname>top_regions</structname>, where the output of <structname>regional_sales</structname> is used in <structname>top_regions</structname> and the output of <structname>top_regions</structname> is used in the primary <command>SELECT</command> query. This example could have been written without <literal>WITH</literal>, but we'd have needed two levels of nested sub-<command>SELECT</command>s. It's a bit easier to follow this way."
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:1604(programlisting) 
#, no-wrap
msgid "\nWITH RECURSIVE t(n) AS (\n    VALUES (1)\n  UNION ALL\n    SELECT n+1 FROM t WHERE n &lt; 100\n)\nSELECT sum(n) FROM t;\n"
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:1596(para) 
msgid "The optional <literal>RECURSIVE</literal> modifier changes <literal>WITH</literal> from a mere syntactic convenience into a feature that accomplishes things not otherwise possible in standard SQL. Using <literal>RECURSIVE</literal>, a <literal>WITH</literal> query can refer to its own output. A very simple example is this query to sum the integers from 1 through 100: <placeholder-1/> The general form of a recursive <literal>WITH</literal> query is always a <firstterm>non-recursive term</firstterm>, then <literal>UNION</literal> (or <literal>UNION ALL</literal>), then a <firstterm>recursive term</firstterm>, where only the recursive term can contain a reference to the query's own output. Such a query is executed as follows:"
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:1622(title) 
msgid "Recursive Query Evaluation"
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:1625(para) 
msgid "Evaluate the non-recursive term. For <literal>UNION</literal> (but not <literal>UNION ALL</literal>), discard duplicate rows. Include all remaining rows in the result of the recursive query, and also place them in a temporary <firstterm>working table</firstterm>."
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:1634(para) 
msgid "So long as the working table is not empty, repeat these steps:"
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:1639(para) 
msgid "Evaluate the recursive term, substituting the current contents of the working table for the recursive self-reference. For <literal>UNION</literal> (but not <literal>UNION ALL</literal>), discard duplicate rows and rows that duplicate any previous result row. Include all remaining rows in the result of the recursive query, and also place them in a temporary <firstterm>intermediate table</firstterm>."
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:1650(para) 
msgid "Replace the contents of the working table with the contents of the intermediate table, then empty the intermediate table."
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:1660(para) 
msgid "Strictly speaking, this process is iteration not recursion, but <literal>RECURSIVE</literal> is the terminology chosen by the SQL standards committee."
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:1667(para) 
msgid "In the example above, the working table has just a single row in each step, and it takes on the values from 1 through 100 in successive steps. In the 100th step, there is no output because of the <literal>WHERE</literal> clause, and so the query terminates."
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:1680(programlisting) 
#, no-wrap
msgid "\nWITH RECURSIVE included_parts(sub_part, part, quantity) AS (\n    SELECT sub_part, part, quantity FROM parts WHERE part = 'our_product'\n  UNION ALL\n    SELECT p.sub_part, p.part, p.quantity\n    FROM included_parts pr, parts p\n    WHERE p.part = pr.sub_part\n  )\nSELECT sub_part, SUM(quantity) as total_quantity\nFROM included_parts\nGROUP BY sub_part\n"
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:1674(para) 
msgid "Recursive queries are typically used to deal with hierarchical or tree-structured data. A useful example is this query to find all the direct and indirect sub-parts of a product, given only a table that shows immediate inclusions: <placeholder-1/>"
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:1707(programlisting) 
#, no-wrap
msgid "\nWITH RECURSIVE search_graph(id, link, data, depth) AS (\n        SELECT g.id, g.link, g.data, 1\n        FROM graph g\n      UNION ALL\n        SELECT g.id, g.link, g.data, sg.depth + 1\n        FROM graph g, search_graph sg\n        WHERE g.id = sg.link\n)\nSELECT * FROM search_graph;\n"
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:1726(programlisting) 
#, no-wrap
msgid "\nWITH RECURSIVE search_graph(id, link, data, depth, path, cycle) AS (\n        SELECT g.id, g.link, g.data, 1,\n          ARRAY[g.id],\n          false\n        FROM graph g\n      UNION ALL\n        SELECT g.id, g.link, g.data, sg.depth + 1,\n          path || g.id,\n          g.id = ANY(path)\n        FROM graph g, search_graph sg\n        WHERE g.id = sg.link AND NOT cycle\n)\nSELECT * FROM search_graph;\n"
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:1694(para) 
msgid "When working with recursive queries it is important to be sure that the recursive part of the query will eventually return no tuples, or else the query will loop indefinitely. Sometimes, using <literal>UNION</literal> instead of <literal>UNION ALL</literal> can accomplish this by discarding rows that duplicate previous output rows. However, often a cycle does not involve output rows that are completely duplicate: it may be necessary to check just one or a few fields to see if the same point has been reached before. The standard method for handling such situations is to compute an array of the already-visited values. For example, consider the following query that searches a table <structname>graph</structname> using a <structfield>link</structfield> field: <placeholder-1/> This query will loop if the <structfield>link</structfield> relationships contain cycles. Because we require a <quote>depth</quote> output, just changing <literal>UNION ALL</literal> to <literal>UNION</literal> would not eliminate the looping. Instead we need to recognize whether we have reached the same row again while following a particular path of links. We add two columns <structfield>path</structfield> and <structfield>cycle</structfield> to the loop-prone query: <placeholder-2/> Aside from preventing cycles, the array value is often useful in its own right as representing the <quote>path</quote> taken to reach any particular row."
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:1751(programlisting) 
#, no-wrap
msgid "\nWITH RECURSIVE search_graph(id, link, data, depth, path, cycle) AS (\n        SELECT g.id, g.link, g.data, 1,\n          ARRAY[ROW(g.f1, g.f2)],\n          false\n        FROM graph g\n      UNION ALL\n        SELECT g.id, g.link, g.data, sg.depth + 1,\n          path || ROW(g.f1, g.f2),\n          ROW(g.f1, g.f2) = ANY(path)\n        FROM graph g, search_graph sg\n        WHERE g.id = sg.link AND NOT cycle\n)\nSELECT * FROM search_graph;\n"
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:1746(para) 
msgid "In the general case where more than one field needs to be checked to recognize a cycle, use an array of rows. For example, if we needed to compare fields <structfield>f1</structfield> and <structfield>f2</structfield>: <placeholder-1/>"
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:1769(para) 
msgid "Omit the <literal>ROW()</literal> syntax in the common case where only one field needs to be checked to recognize a cycle. This allows a simple array rather than a composite-type array to be used, gaining efficiency."
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:1777(para) 
msgid "The recursive query evaluation algorithm produces its output in breadth-first search order. You can display the results in depth-first search order by making the outer query <literal>ORDER BY</literal> a <quote>path</quote> column constructed in this way."
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:1791(programlisting) 
#, no-wrap
msgid "\nWITH RECURSIVE t(n) AS (\n    SELECT 1\n  UNION ALL\n    SELECT n+1 FROM t\n)\nSELECT n FROM t LIMIT 100;\n"
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:1785(para) 
msgid "A helpful trick for testing queries when you are not certain if they might loop is to place a <literal>LIMIT</literal> in the parent query. For example, this query would loop forever without the <literal>LIMIT</literal>: <placeholder-1/> This works because <productname>PostgreSQL</productname>'s implementation evaluates only as many rows of a <literal>WITH</literal> query as are actually fetched by the parent query. Using this trick in production is not recommended, because other systems might work differently. Also, it usually won't work if you make the outer query sort the recursive query's results or join them to some other table, because in such cases the outer query will usually try to fetch all of the <literal>WITH</literal> query's output anyway."
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:1810(para) 
msgid "A useful property of <literal>WITH</literal> queries is that they are evaluated only once per execution of the parent query, even if they are referred to more than once by the parent query or sibling <literal>WITH</literal> queries. Thus, expensive calculations that are needed in multiple places can be placed within a <literal>WITH</literal> query to avoid redundant work. Another possible application is to prevent unwanted multiple evaluations of functions with side-effects. However, the other side of this coin is that the optimizer is less able to push restrictions from the parent query down into a <literal>WITH</literal> query than an ordinary sub-query. The <literal>WITH</literal> query will generally be evaluated as written, without suppression of rows that the parent query might discard afterwards. (But, as mentioned above, evaluation might stop early if the reference(s) to the query demand only a limited number of rows.)"
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:1827(para) 
msgid "The examples above only show <literal>WITH</literal> being used with <command>SELECT</command>, but it can be attached in the same way to <command>INSERT</command>, <command>UPDATE</command>, or <command>DELETE</command>. In each case it effectively provides temporary table(s) that can be referred to in the main command."
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:1837(title) 
msgid "Data-Modifying Statements in <literal>WITH</literal>"
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:1845(programlisting) 
#, no-wrap
msgid "\nWITH moved_rows AS (\n    DELETE FROM products\n    WHERE\n        \"date\" &gt;= '2010-10-01' AND\n        \"date\" &lt; '2010-11-01'\n    RETURNING *\n)\nINSERT INTO products_log\nSELECT * FROM moved_rows;\n"
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:1839(para) 
msgid "You can use data-modifying statements (<command>INSERT</command>, <command>UPDATE</command>, or <command>DELETE</command>) in <literal>WITH</literal>. This allows you to perform several different operations in the same query. An example is: <placeholder-1/> This query effectively moves rows from <structname>products</structname> to <structname>products_log</structname>. The <command>DELETE</command> in <literal>WITH</literal> deletes the specified rows from <structname>products</structname>, returning their contents by means of its <literal>RETURNING</literal> clause; and then the primary query reads that output and inserts it into <structname>products_log</structname>."
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:1865(para) 
msgid "A fine point of the above example is that the <literal>WITH</literal> clause is attached to the <command>INSERT</command>, not the sub-<command>SELECT</command> within the <command>INSERT</command>. This is necessary because data-modifying statements are only allowed in <literal>WITH</literal> clauses that are attached to the top-level statement. However, normal <literal>WITH</literal> visibility rules apply, so it is possible to refer to the <literal>WITH</literal> statement's output from the sub-<command>SELECT</command>."
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:1886(programlisting) 
#, no-wrap
msgid "\nWITH t AS (\n    DELETE FROM foo\n)\nDELETE FROM bar;\n"
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:1875(para) 
msgid "Data-modifying statements in <literal>WITH</literal> usually have <literal>RETURNING</literal> clauses, as seen in the example above. It is the output of the <literal>RETURNING</literal> clause, <emphasis>not</emphasis> the target table of the data-modifying statement, that forms the temporary table that can be referred to by the rest of the query. If a data-modifying statement in <literal>WITH</literal> lacks a <literal>RETURNING</literal> clause, then it forms no temporary table and cannot be referred to in the rest of the query. Such a statement will be executed nonetheless. A not-particularly-useful example is: <placeholder-1/> This example would remove all rows from tables <structname>foo</structname> and <structname>bar</structname>. The number of affected rows reported to the client would only include rows removed from <structname>bar</structname>."
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:1903(programlisting) 
#, no-wrap
msgid "\nWITH RECURSIVE included_parts(sub_part, part) AS (\n    SELECT sub_part, part FROM parts WHERE part = 'our_product'\n  UNION ALL\n    SELECT p.sub_part, p.part\n    FROM included_parts pr, parts p\n    WHERE p.part = pr.sub_part\n  )\nDELETE FROM parts\n  WHERE part IN (SELECT part FROM included_parts);\n"
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:1898(para) 
msgid "Recursive self-references in data-modifying statements are not allowed. In some cases it is possible to work around this limitation by referring to the output of a recursive <literal>WITH</literal>, for example: <placeholder-1/> This query would remove all direct and indirect subparts of a product."
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:1918(para) 
msgid "Data-modifying statements in <literal>WITH</literal> are executed exactly once, and always to completion, independently of whether the primary query reads all (or indeed any) of their output. Notice that this is different from the rule for <command>SELECT</command> in <literal>WITH</literal>: as stated in the previous section, execution of a <command>SELECT</command> is carried only as far as the primary query demands its output."
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:1939(programlisting) 
#, no-wrap
msgid "\nWITH t AS (\n    UPDATE products SET price = price * 1.05\n    RETURNING *\n)\nSELECT * FROM products;\n"
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:1950(programlisting) 
#, no-wrap
msgid "\nWITH t AS (\n    UPDATE products SET price = price * 1.05\n    RETURNING *\n)\nSELECT * FROM t;\n"
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:1927(para) 
msgid "The sub-statements in <literal>WITH</literal> are executed concurrently with each other and with the main query. Therefore, when using data-modifying statements in <literal>WITH</literal>, the order in which the specified updates actually happen is unpredictable. All the statements are executed with the same <firstterm>snapshot</firstterm> (see <xref linkend=\"mvcc\"/>), so they cannot <quote>see</quote> each others' effects on the target tables. This alleviates the effects of the unpredictability of the actual order of row updates, and means that <literal>RETURNING</literal> data is the only way to communicate changes between different <literal>WITH</literal> sub-statements and the main query. An example of this is that in <placeholder-1/> the outer <command>SELECT</command> would return the original prices before the action of the <command>UPDATE</command>, while in <placeholder-2/> the outer <command>SELECT</command> would return the updated data."
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:1961(para) 
msgid "Trying to update the same row twice in a single statement is not supported. Only one of the modifications takes place, but it is not easy (and sometimes not possible) to reliably predict which one. This also applies to deleting a row that was already updated in the same statement: only the update is performed. Therefore you should generally avoid trying to modify a single row twice in a single statement. In particular avoid writing <literal>WITH</literal> sub-statements that could affect the same rows changed by the main statement or a sibling sub-statement. The effects of such a statement will not be predictable."
msgstr ""

#: /tmp/cicero-lWzA/queries.xml:1973(para) 
msgid "At present, any table used as the target of a data-modifying statement in <literal>WITH</literal> must not have a conditional rule, nor an <literal>ALSO</literal> rule, nor an <literal>INSTEAD</literal> rule that expands to multiple statements."
msgstr ""

#. Put one translator per line, in the form of NAME <EMAIL>, YEAR1, YEAR2.
#: /tmp/cicero-lWzA/queries.xml:0(None) 
msgid "translator-credits"
msgstr ""

