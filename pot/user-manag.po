msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2011-05-26 12:12+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/user-manag.xml:5(title)
msgid "Database Roles and Privileges"
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/user-manag.xml:7(para)
msgid "<productname>PostgreSQL</productname> manages database access permissions using the concept of <firstterm>roles</firstterm>. A role can be thought of as either a database user, or a group of database users, depending on how the role is set up. Roles can own database objects (for example, tables) and can assign privileges on those objects to other roles to control who has access to which objects. Furthermore, it is possible to grant <firstterm>membership</firstterm> in a role to another role, thus allowing the member role to use privileges assigned to another role."
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/user-manag.xml:18(para)
msgid "The concept of roles subsumes the concepts of <quote>users</quote> and <quote>groups</quote>. In <productname>PostgreSQL</productname> versions before 8.1, users and groups were distinct kinds of entities, but now there are only roles. Any role can act as a user, a group, or both."
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/user-manag.xml:25(para)
msgid "This chapter describes how to create and manage roles and introduces the privilege system. More information about the various types of database objects and the effects of privileges can be found in <xref linkend=\"ddl\"/>."
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/user-manag.xml:33(title)
msgid "Database Roles"
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/user-manag.xml:36(primary) /home/carloratm/progetti/postgresql-source/doc-9.0.4/user-manag.xml:347(primary)
msgid "role"
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/user-manag.xml:40(primary)
msgid "user"
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/user-manag.xml:44(primary)
msgid "CREATE ROLE"
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/user-manag.xml:48(primary)
msgid "DROP ROLE"
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/user-manag.xml:51(para)
msgid "Database roles are conceptually completely separate from operating system users. In practice it might be convenient to maintain a correspondence, but this is not required. Database roles are global across a database cluster installation (and not per individual database). To create a role use the <xref linkend=\"sql-createrole\"/> SQL command: <synopsis>\nCREATE ROLE <replaceable>name</replaceable>;\n</synopsis><replaceable>name</replaceable> follows the rules for SQL identifiers: either unadorned without special characters, or double-quoted. (In practice, you will usually want to add additional options, such as <literal>LOGIN</literal>, to the command. More details appear below.) To remove an existing role, use the analogous <xref linkend=\"sql-droprole\"/> command: <synopsis>\nDROP ROLE <replaceable>name</replaceable>;\n</synopsis>"
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/user-manag.xml:73(primary)
msgid "createuser"
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/user-manag.xml:77(primary)
msgid "dropuser"
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/user-manag.xml:80(para)
msgid "For convenience, the programs <xref linkend=\"app-createuser\"/> and <xref linkend=\"app-dropuser\"/> are provided as wrappers around these SQL commands that can be called from the shell command line: <synopsis>\ncreateuser <replaceable>name</replaceable>\ndropuser <replaceable>name</replaceable>\n</synopsis>"
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/user-manag.xml:91(para)
msgid "To determine the set of existing roles, examine the <structname>pg_roles</structname> system catalog, for example <synopsis>\nSELECT rolname FROM pg_roles;\n</synopsis> The <xref linkend=\"app-psql\"/> program's <literal>\\du</literal> meta-command is also useful for listing the existing roles."
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/user-manag.xml:101(para)
msgid "In order to bootstrap the database system, a freshly initialized system always contains one predefined role. This role is always a <quote>superuser</quote>, and by default (unless altered when running <command>initdb</command>) it will have the same name as the operating system user that initialized the database cluster. Customarily, this role will be named <literal>postgres</literal>. In order to create more roles you first have to connect as this initial role."
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/user-manag.xml:112(para)
msgid "Every connection to the database server is made using the name of some particular role, and this role determines the initial access privileges for commands issued in that connection. The role name to use for a particular database connection is indicated by the client that is initiating the connection request in an application-specific fashion. For example, the <command>psql</command> program uses the <option>-U</option> command line option to indicate the role to connect as. Many applications assume the name of the current operating system user by default (including <command>createuser</command> and <command>psql</command>). Therefore it is often convenient to maintain a naming correspondence between roles and operating system users."
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/user-manag.xml:128(para)
msgid "The set of database roles a given client connection can connect as is determined by the client authentication setup, as explained in <xref linkend=\"client-authentication\"/>. (Thus, a client is not limited to connect as the role matching its operating system user, just as a person's login name need not match her real name.) Since the role identity determines the set of privileges available to a connected client, it is important to carefully configure privileges when setting up a multiuser environment."
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/user-manag.xml:142(title)
msgid "Role Attributes"
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/user-manag.xml:150(term)
msgid "login privilege<indexterm><primary>login privilege</primary></indexterm>"
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/user-manag.xml:158(programlisting)
#, no-wrap
msgid "\nCREATE ROLE <replaceable>name</replaceable> LOGIN;\nCREATE USER <replaceable>name</replaceable>;\n"
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/user-manag.xml:152(para)
msgid "Only roles that have the <literal>LOGIN</literal> attribute can be used as the initial role name for a database connection. A role with the <literal>LOGIN</literal> attribute can be considered the same as a <quote>database user</quote>. To create a role with login privilege, use either: <placeholder-1/> (<command>CREATE USER</command> is equivalent to <command>CREATE ROLE</command> except that <command>CREATE USER</command> assumes <literal>LOGIN</literal> by default, while <command>CREATE ROLE</command> does not.)"
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/user-manag.xml:170(term)
msgid "superuser status<indexterm><primary>superuser</primary></indexterm>"
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/user-manag.xml:172(para)
msgid "A database superuser bypasses all permission checks. This is a dangerous privilege and should not be used carelessly; it is best to do most of your work as a role that is not a superuser. To create a new database superuser, use <literal>CREATE ROLE <replaceable>name</replaceable> SUPERUSER</literal>. You must do this as a role that is already a superuser."
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/user-manag.xml:184(term)
msgid "database creation<indexterm><primary>database</primary><secondary>privilege to create</secondary></indexterm>"
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/user-manag.xml:186(para)
msgid "A role must be explicitly given permission to create databases (except for superusers, since those bypass all permission checks). To create such a role, use <literal>CREATE ROLE <replaceable>name</replaceable> CREATEDB</literal>."
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/user-manag.xml:196(term)
msgid "role creation<indexterm><primary>role</primary><secondary>privilege to create</secondary></indexterm>"
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/user-manag.xml:198(para)
msgid "A role must be explicitly given permission to create more roles (except for superusers, since those bypass all permission checks). To create such a role, use <literal>CREATE ROLE <replaceable>name</replaceable> CREATEROLE</literal>. A role with <literal>CREATEROLE</literal> privilege can alter and drop other roles, too, as well as grant or revoke membership in them. However, to create, alter, drop, or change membership of a superuser role, superuser status is required; <literal>CREATEROLE</literal> is insufficient for that."
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/user-manag.xml:213(term)
msgid "password<indexterm><primary>password</primary></indexterm>"
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/user-manag.xml:215(para)
msgid "A password is only significant if the client authentication method requires the user to supply a password when connecting to the database. The <option>password</option> and <option>md5</option> authentication methods make use of passwords. Database passwords are separate from operating system passwords. Specify a password upon role creation with <literal>CREATE ROLE <replaceable>name</replaceable> PASSWORD '<replaceable>string</replaceable>'</literal>."
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/user-manag.xml:144(para)
msgid "A database role can have a number of attributes that define its privileges and interact with the client authentication system. <placeholder-1/> A role's attributes can be modified after creation with <command>ALTER ROLE</command>.<indexterm><primary>ALTER ROLE</primary></indexterm> See the reference pages for the <xref linkend=\"sql-createrole\"/> and <xref linkend=\"sql-alterrole\"/> commands for details."
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/user-manag.xml:237(para)
msgid "It is good practice to create a role that has the <literal>CREATEDB</literal> and <literal>CREATEROLE</literal> privileges, but is not a superuser, and then use this role for all routine management of databases and roles. This approach avoids the dangers of operating as a superuser for tasks that do not really require it."
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/user-manag.xml:252(programlisting)
#, no-wrap
msgid "\nALTER ROLE myname SET enable_indexscan TO off;\n"
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/user-manag.xml:246(para)
msgid "A role can also have role-specific defaults for many of the run-time configuration settings described in <xref linkend=\"runtime-config\"/>. For example, if for some reason you want to disable index scans (hint: not a good idea) anytime you connect, you can use: <placeholder-1/> This will save the setting (but not set it immediately). In subsequent connections by this role it will appear as though <literal>SET enable_indexscan TO off</literal> had been executed just before the session started. You can still alter this setting during the session; it will only be the default. To remove a role-specific default setting, use <literal>ALTER ROLE <replaceable>rolename</replaceable> RESET <replaceable>varname</replaceable></literal>. Note that role-specific defaults attached to roles without <literal>LOGIN</literal> privilege are fairly useless, since they will never be invoked."
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/user-manag.xml:269(title)
msgid "Privileges"
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/user-manag.xml:272(primary)
msgid "privilege"
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/user-manag.xml:276(primary)
msgid "owner"
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/user-manag.xml:280(primary)
msgid "GRANT"
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/user-manag.xml:284(primary)
msgid "REVOKE"
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/user-manag.xml:287(para)
msgid "When an object is created, it is assigned an owner. The owner is normally the role that executed the creation statement. For most kinds of objects, the initial state is that only the owner (or a superuser) can do anything with the object. To allow other roles to use it, <firstterm>privileges</firstterm> must be granted. There are several different kinds of privilege: <literal>SELECT</literal>, <literal>INSERT</literal>, <literal>UPDATE</literal>, <literal>DELETE</literal>, <literal>TRUNCATE</literal>, <literal>REFERENCES</literal>, <literal>TRIGGER</literal>, <literal>CREATE</literal>, <literal>CONNECT</literal>, <literal>TEMPORARY</literal>, <literal>EXECUTE</literal>, and <literal>USAGE</literal>. For more information on the different types of privileges supported by <productname>PostgreSQL</productname>, see the <xref linkend=\"sql-grant\"/> reference page."
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/user-manag.xml:309(programlisting)
#, no-wrap
msgid "\nGRANT UPDATE ON accounts TO joe;\n"
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/user-manag.xml:304(para)
msgid "To assign privileges, the <command>GRANT</command> command is used. So, if <literal>joe</literal> is an existing role, and <literal>accounts</literal> is an existing table, the privilege to update the table can be granted with: <placeholder-1/> The special name <literal>PUBLIC</literal> can be used to grant a privilege to every role on the system. Writing <literal>ALL</literal> in place of a specific privilege specifies that all privileges that apply to the object will be granted."
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/user-manag.xml:321(programlisting)
#, no-wrap
msgid "\nREVOKE ALL ON accounts FROM PUBLIC;\n"
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/user-manag.xml:318(para)
msgid "To revoke a privilege, use the fittingly named <xref linkend=\"sql-revoke\"/> command: <placeholder-1/>"
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/user-manag.xml:326(para)
msgid "The special privileges of an object's owner (i.e., the right to modify or destroy the object) are always implicit in being the owner, and cannot be granted or revoked. But the owner can choose to revoke his own ordinary privileges, for example to make a table read-only for himself as well as others."
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/user-manag.xml:334(para)
msgid "An object can be assigned to a new owner with an <command>ALTER</command> command of the appropriate kind for the object. Superusers can always do this; ordinary roles can only do it if they are both the current owner of the object (or a member of the owning role) and a member of the new owning role."
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/user-manag.xml:344(title)
msgid "Role Membership"
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/user-manag.xml:347(secondary)
msgid "membership in"
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/user-manag.xml:350(para)
msgid "It is frequently convenient to group users together to ease management of privileges: that way, privileges can be granted to, or revoked from, a group as a whole. In <productname>PostgreSQL</productname> this is done by creating a role that represents the group, and then granting <firstterm>membership</firstterm> in the group role to individual user roles."
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/user-manag.xml:359(para)
msgid "To set up a group role, first create the role: <synopsis>\nCREATE ROLE <replaceable>name</replaceable>;\n</synopsis> Typically a role being used as a group would not have the <literal>LOGIN</literal> attribute, though you can set it if you wish."
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/user-manag.xml:368(para)
msgid "Once the group role exists, you can add and remove members using the <xref linkend=\"sql-grant\"/> and <xref linkend=\"sql-revoke\"/> commands: <synopsis>\nGRANT <replaceable>group_role</replaceable> TO <replaceable>role1</replaceable>, ... ;\nREVOKE <replaceable>group_role</replaceable> FROM <replaceable>role1</replaceable>, ... ;\n</synopsis> You can grant membership to other group roles, too (since there isn't really any distinction between group roles and non-group roles). The database will not let you set up circular membership loops. Also, it is not permitted to grant membership in a role to <literal>PUBLIC</literal>."
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/user-manag.xml:395(programlisting)
#, no-wrap
msgid "\nCREATE ROLE joe LOGIN INHERIT;\nCREATE ROLE admin NOINHERIT;\nCREATE ROLE wheel NOINHERIT;\nGRANT admin TO joe;\nGRANT wheel TO admin;\n"
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/user-manag.xml:410(programlisting)
#, no-wrap
msgid "\nSET ROLE admin;\n"
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/user-manag.xml:415(programlisting)
#, no-wrap
msgid "\nSET ROLE wheel;\n"
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/user-manag.xml:422(programlisting)
#, no-wrap
msgid "\nSET ROLE joe;\nSET ROLE NONE;\nRESET ROLE;\n"
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/user-manag.xml:383(para)
msgid "The members of a group role can use the privileges of the role in two ways. First, every member of a group can explicitly do <xref linkend=\"sql-set-role\"/> to temporarily <quote>become</quote> the group role. In this state, the database session has access to the privileges of the group role rather than the original login role, and any database objects created are considered owned by the group role not the login role. Second, member roles that have the <literal>INHERIT</literal> attribute automatically have use of the privileges of roles of which they are members, including any privileges inherited by those roles. As an example, suppose we have done: <placeholder-1/> Immediately after connecting as role <literal>joe</literal>, a database session will have use of privileges granted directly to <literal>joe</literal> plus any privileges granted to <literal>admin</literal>, because <literal>joe</literal><quote>inherits</quote><literal>admin</literal>'s privileges. However, privileges granted to <literal>wheel</literal> are not available, because even though <literal>joe</literal> is indirectly a member of <literal>wheel</literal>, the membership is via <literal>admin</literal> which has the <literal>NOINHERIT</literal> attribute. After: <placeholder-2/> the session would have use of only those privileges granted to <literal>admin</literal>, and not those granted to <literal>joe</literal>. After: <placeholder-3/> the session would have use of only those privileges granted to <literal>wheel</literal>, and not those granted to either <literal>joe</literal> or <literal>admin</literal>. The original privilege state can be restored with any of: <placeholder-4/>"
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/user-manag.xml:430(para)
msgid "The <command>SET ROLE</command> command always allows selecting any role that the original login role is directly or indirectly a member of. Thus, in the above example, it is not necessary to become <literal>admin</literal> before becoming <literal>wheel</literal>."
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/user-manag.xml:439(para)
msgid "In the SQL standard, there is a clear distinction between users and roles, and users do not automatically inherit privileges while roles do. This behavior can be obtained in <productname>PostgreSQL</productname> by giving roles being used as SQL roles the <literal>INHERIT</literal> attribute, while giving roles being used as SQL users the <literal>NOINHERIT</literal> attribute. However, <productname>PostgreSQL</productname> defaults to giving all roles the <literal>INHERIT</literal> attribute, for backwards compatibility with pre-8.1 releases in which users always had use of permissions granted to groups they were members of."
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/user-manag.xml:452(para)
msgid "The role attributes <literal>LOGIN</literal>, <literal>SUPERUSER</literal>, <literal>CREATEDB</literal>, and <literal>CREATEROLE</literal> can be thought of as special privileges, but they are never inherited as ordinary privileges on database objects are. You must actually <command>SET ROLE</command> to a specific role having one of these attributes in order to make use of the attribute. Continuing the above example, we might choose to grant <literal>CREATEDB</literal> and <literal>CREATEROLE</literal> to the <literal>admin</literal> role. Then a session connecting as role <literal>joe</literal> would not have these privileges immediately, only after doing <command>SET ROLE admin</command>."
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/user-manag.xml:468(para)
msgid "To destroy a group role, use <xref linkend=\"sql-droprole\"/>: <synopsis>\nDROP ROLE <replaceable>name</replaceable>;\n</synopsis> Any memberships in the group role are automatically revoked (but the member roles are not otherwise affected). Note however that any objects owned by the group role must first be dropped or reassigned to other owners; and any permissions granted to the group role must be revoked."
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/user-manag.xml:482(title)
msgid "Function and Trigger Security"
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/user-manag.xml:484(para)
msgid "Functions and triggers allow users to insert code into the backend server that other users might execute unintentionally. Hence, both mechanisms permit users to <quote>Trojan horse</quote> others with relative ease. The only real protection is tight control over who can define functions."
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/user-manag.xml:492(para)
msgid "Functions run inside the backend server process with the operating system permissions of the database server daemon. If the programming language used for the function allows unchecked memory accesses, it is possible to change the server's internal data structures. Hence, among many other things, such functions can circumvent any system access controls. Function languages that allow such access are considered <quote>untrusted</quote>, and <productname>PostgreSQL</productname> allows only superusers to create functions written in those languages."
msgstr ""

#. Put one translator per line, in the form of NAME <EMAIL>, YEAR1, YEAR2
#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/user-manag.xml:0(None)
msgid "translator-credits"
msgstr ""

