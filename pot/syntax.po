msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2011-09-15 06:57+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: /tmp/cicero-fBJf/syntax.xml:5(title) 
msgid "SQL Syntax"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:8(primary) /tmp/cicero-fBJf/syntax.xml:809(secondary) /tmp/cicero-fBJf/syntax.xml:1174(secondary) /tmp/cicero-fBJf/syntax.xml:1342(secondary) 
msgid "syntax"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:9(secondary) 
msgid "SQL"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:12(para) 
msgid "This chapter describes the syntax of SQL. It forms the foundation for understanding the following chapters which will go into detail about how SQL commands are applied to define and modify data."
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:18(para) 
msgid "We also advise users who are already familiar with SQL to read this chapter carefully because it contains several rules and concepts that are implemented inconsistently among SQL databases or that are specific to <productname>PostgreSQL</productname>."
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:26(title) 
msgid "Lexical Structure"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:29(primary) 
msgid "token"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:32(para) 
msgid "SQL input consists of a sequence of <firstterm>commands</firstterm>. A command is composed of a sequence of <firstterm>tokens</firstterm>, terminated by a semicolon (<quote>;</quote>). The end of the input stream also terminates a command. Which tokens are valid depends on the syntax of the particular command."
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:41(para) 
msgid "A token can be a <firstterm>key word</firstterm>, an <firstterm>identifier</firstterm>, a <firstterm>quoted identifier</firstterm>, a <firstterm>literal</firstterm> (or constant), or a special character symbol. Tokens are normally separated by whitespace (space, tab, newline), but need not be if there is no ambiguity (which is generally only the case if a special character is adjacent to some other token type)."
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:53(programlisting) 
#, no-wrap
msgid "\nSELECT * FROM MY_TABLE;\nUPDATE MY_TABLE SET A = 5;\nINSERT INTO MY_TABLE VALUES (3, 'hi there');\n"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:51(para) 
msgid "For example, the following is (syntactically) valid SQL input: <placeholder-1/> This is a sequence of three commands, one per line (although this is not required; more than one command can be on a line, and commands can usefully be split across lines)."
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:63(para) 
msgid "Additionally, <firstterm>comments</firstterm> can occur in SQL input. They are not tokens, they are effectively equivalent to whitespace."
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:69(para) 
msgid "The SQL syntax is not very consistent regarding what tokens identify commands and which are operands or parameters. The first few tokens are generally the command name, so in the above example we would usually speak of a <quote>SELECT</quote>, an <quote>UPDATE</quote>, and an <quote>INSERT</quote> command. But for instance the <command>UPDATE</command> command always requires a <token>SET</token> token to appear in a certain position, and this particular variation of <command>INSERT</command> also requires a <token>VALUES</token> in order to be complete. The precise syntax rules for each command are described in <xref linkend=\"reference\"/>."
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:83(title) 
msgid "Identifiers and Key Words"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:86(primary) 
msgid "identifier"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:87(secondary) /tmp/cicero-fBJf/syntax.xml:92(secondary) /tmp/cicero-fBJf/syntax.xml:97(secondary) 
msgid "syntax of"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:91(primary) 
msgid "name"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:96(primary) 
msgid "key word"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:100(para) 
msgid "Tokens such as <token>SELECT</token>, <token>UPDATE</token>, or <token>VALUES</token> in the example above are examples of <firstterm>key words</firstterm>, that is, words that have a fixed meaning in the SQL language. The tokens <token>MY_TABLE</token> and <token>A</token> are examples of <firstterm>identifiers</firstterm>. They identify names of tables, columns, or other database objects, depending on the command they are used in. Therefore they are sometimes simply called <quote>names</quote>. Key words and identifiers have the same lexical structure, meaning that one cannot know whether a token is an identifier or a key word without knowing the language. A complete list of key words can be found in <xref linkend=\"sql-keywords-appendix\"/>."
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:116(para) 
msgid "SQL identifiers and key words must begin with a letter (<literal>a</literal>-<literal>z</literal>, but also letters with diacritical marks and non-Latin letters) or an underscore (<literal>_</literal>). Subsequent characters in an identifier or key word can be letters, underscores, digits (<literal>0</literal>-<literal>9</literal>), or dollar signs (<literal>$</literal>). Note that dollar signs are not allowed in identifiers according to the letter of the SQL standard, so their use might render applications less portable. The SQL standard will not define a key word that contains digits or starts or ends with an underscore, so identifiers of this form are safe against possible conflict with future extensions of the standard."
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:132(para) 
msgid "<indexterm><primary>identifier</primary><secondary>length</secondary></indexterm> The system uses no more than <symbol>NAMEDATALEN</symbol>-1 bytes of an identifier; longer names can be written in commands, but they will be truncated. By default, <symbol>NAMEDATALEN</symbol> is 64 so the maximum identifier length is 63 bytes. If this limit is problematic, it can be raised by changing the <symbol>NAMEDATALEN</symbol> constant in <filename>src/include/pg_config_manual.h</filename>."
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:149(programlisting) 
#, no-wrap
msgid "\nUPDATE MY_TABLE SET A = 5;\n"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:153(programlisting) 
#, no-wrap
msgid "\nuPDaTE my_TabLE SeT a = 5;\n"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:158(programlisting) 
#, no-wrap
msgid "\nUPDATE my_table SET a = 5;\n"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:143(para) 
msgid "<indexterm><primary>case sensitivity</primary><secondary>of SQL commands</secondary></indexterm> Key words and unquoted identifiers are case insensitive. Therefore: <placeholder-1/> can equivalently be written as: <placeholder-2/> A convention often used is to write key words in upper case and names in lower case, e.g.: <placeholder-3/>"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:180(programlisting) 
#, no-wrap
msgid "\nUPDATE \"my_table\" SET \"a\" = 5;\n"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:163(para) 
msgid "<indexterm><primary>quotation marks</primary><secondary>and identifiers</secondary></indexterm> There is a second kind of identifier: the <firstterm>delimited identifier</firstterm> or <firstterm>quoted identifier</firstterm>. It is formed by enclosing an arbitrary sequence of characters in double-quotes (<literal>\"</literal>). A delimited identifier is always an identifier, never a key word. So <literal>\"select\"</literal> could be used to refer to a column or table named <quote>select</quote>, whereas an unquoted <literal>select</literal> would be taken as a key word and would therefore provoke a parse error when used where a table or column name is expected. The example can be written with quoted identifiers like this: <placeholder-1/>"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:185(para) 
msgid "Quoted identifiers can contain any character, except the character with code zero. (To include a double quote, write two double quotes.) This allows constructing table or column names that would otherwise not be possible, such as ones containing spaces or ampersands. The length limitation still applies."
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:194(primary) /tmp/cicero-fBJf/syntax.xml:485(primary) 
msgid "Unicode escape"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:195(secondary) 
msgid "in identifiers"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:213(programlisting) 
#, no-wrap
msgid "\nU&amp;\"d\\0061t\\+000061\"\n"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:218(programlisting) 
#, no-wrap
msgid "\nU&amp;\"\\0441\\043B\\043E\\043D\"\n"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:198(para) 
msgid "A variant of quoted identifiers allows including escaped Unicode characters identified by their code points. This variant starts with <literal>U&amp;</literal> (upper or lower case U followed by ampersand) immediately before the opening double quote, without any spaces in between, for example <literal>U&amp;\"foo\"</literal>. (Note that this creates an ambiguity with the operator <literal>&amp;</literal>. Use spaces around the operator to avoid this problem.) Inside the quotes, Unicode characters can be specified in escaped form by writing a backslash followed by the four-digit hexadecimal code point number or alternatively a backslash followed by a plus sign followed by a six-digit hexadecimal code point number. For example, the identifier <literal>\"data\"</literal> could be written as <placeholder-1/> The following less trivial example writes the Russian word <quote>slon</quote> (elephant) in Cyrillic letters: <placeholder-2/>"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:228(programlisting) 
#, no-wrap
msgid "\nU&amp;\"d!0061t!+000061\" UESCAPE '!'\n"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:223(para) 
msgid "If a different escape character than backslash is desired, it can be specified using the <literal>UESCAPE</literal><indexterm><primary>UESCAPE</primary></indexterm> clause after the string, for example: <placeholder-1/> The escape character can be any single character other than a hexadecimal digit, the plus sign, a single quote, a double quote, or a whitespace character. Note that the escape character is written in single quotes, not double quotes."
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:237(para) 
msgid "To include the escape character in the identifier literally, write it twice."
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:242(para) 
msgid "The Unicode escape syntax works only when the server encoding is <literal>UTF8</literal>. When other server encodings are used, only code points in the ASCII range (up to <literal>\\007F</literal>) can be specified. Both the 4-digit and the 6-digit form can be used to specify UTF-16 surrogate pairs to compose characters with code points larger than U+FFFF, although the availability of the 6-digit form technically makes this unnecessary. (Surrogate pairs are not stored directly, but combined into a single code point that is then encoded in UTF-8.)"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:254(para) 
msgid "Quoting an identifier also makes it case-sensitive, whereas unquoted names are always folded to lower case. For example, the identifiers <literal>FOO</literal>, <literal>foo</literal>, and <literal>\"foo\"</literal> are considered the same by <productname>PostgreSQL</productname>, but <literal>\"Foo\"</literal> and <literal>\"FOO\"</literal> are different from these three and each other. (The folding of unquoted names to lower case in <productname>PostgreSQL</productname> is incompatible with the SQL standard, which says that unquoted names should be folded to upper case. Thus, <literal>foo</literal> should be equivalent to <literal>\"FOO\"</literal> not <literal>\"foo\"</literal> according to the standard. If you want to write portable applications you are advised to always quote a particular name or never quote it.)"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:274(title) 
msgid "Constants"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:277(primary) /tmp/cicero-fBJf/syntax.xml:295(secondary) /tmp/cicero-fBJf/syntax.xml:642(secondary) /tmp/cicero-fBJf/syntax.xml:673(secondary) /tmp/cicero-fBJf/syntax.xml:745(secondary) 
msgid "constant"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:280(para) 
msgid "There are three kinds of <firstterm>implicitly-typed constants</firstterm> in <productname>PostgreSQL</productname>: strings, bit strings, and numbers. Constants can also be specified with explicit types, which can enable more accurate representation and more efficient handling by the system. These alternatives are discussed in the following subsections."
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:291(title) 
msgid "String Constants"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:294(primary) 
msgid "character string"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:298(para) 
msgid "<indexterm><primary>quotation marks</primary><secondary>escaping</secondary></indexterm> A string constant in SQL is an arbitrary sequence of characters bounded by single quotes (<literal>'</literal>), for example <literal>'This is a string'</literal>. To include a single-quote character within a string constant, write two adjacent single quotes, e.g., <literal>'Dianne''s horse'</literal>. Note that this is <emphasis>not</emphasis> the same as a double-quote character (<literal>\"</literal>)."
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:318(programlisting) 
#, no-wrap
msgid "\nSELECT 'foo'\n'bar';\n"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:323(programlisting) 
#, no-wrap
msgid "\nSELECT 'foobar';\n"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:327(programlisting) 
#, no-wrap
msgid "\nSELECT 'foo'      'bar';\n"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:313(para) 
msgid "Two string constants that are only separated by whitespace <emphasis>with at least one newline</emphasis> are concatenated and effectively treated as if the string had been written as one constant. For example: <placeholder-1/> is equivalent to: <placeholder-2/> but: <placeholder-3/> is not valid syntax. (This slightly bizarre behavior is specified by <acronym>SQL</acronym>; <productname>PostgreSQL</productname> is following the standard.)"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:337(title) 
msgid "String Constants with C-style Escapes"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:340(primary) 
msgid "escape string syntax"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:343(primary) 
msgid "backslash escapes"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:346(para) 
msgid "<productname>PostgreSQL</productname> also accepts <quote>escape</quote> string constants, which are an extension to the SQL standard. An escape string constant is specified by writing the letter <literal>E</literal> (upper or lower case) just before the opening single quote, e.g., <literal>E'foo'</literal>. (When continuing an escape string constant across lines, write <literal>E</literal> only before the first opening quote.) Within an escape string, a backslash character (<literal>\\</literal>) begins a C-like <firstterm>backslash escape</firstterm> sequence, in which the combination of backslash and following character(s) represent a special byte value, as shown in <xref linkend=\"sql-backslash-table\"/>."
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:361(title) 
msgid "Backslash Escape Sequences"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:365(entry) 
msgid "Backslash Escape Sequence"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:366(entry) 
msgid "Interpretation"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:372(literal) 
msgid "\\b"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:373(entry) 
msgid "backspace"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:376(literal) 
msgid "\\f"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:377(entry) 
msgid "form feed"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:380(literal) 
msgid "\\n"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:381(entry) 
msgid "newline"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:384(literal) 
msgid "\\r"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:385(entry) 
msgid "carriage return"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:388(literal) 
msgid "\\t"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:389(entry) 
msgid "tab"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:393(replaceable) /tmp/cicero-fBJf/syntax.xml:396(replaceable) 
msgid "o"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:393(literal) /tmp/cicero-fBJf/syntax.xml:394(literal) /tmp/cicero-fBJf/syntax.xml:395(literal) 
msgid "\\<placeholder-1/>"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:394(replaceable) 
msgid "oo"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:395(replaceable) 
msgid "ooo"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:392(entry) 
msgid "<placeholder-1/>, <placeholder-2/>, <placeholder-3/> (<placeholder-4/> = 0 - 7)"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:398(entry) 
msgid "octal byte value"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:402(replaceable) /tmp/cicero-fBJf/syntax.xml:404(replaceable) 
msgid "h"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:402(literal) /tmp/cicero-fBJf/syntax.xml:403(literal) 
msgid "\\x<placeholder-1/>"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:403(replaceable) 
msgid "hh"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:401(entry) /tmp/cicero-fBJf/syntax.xml:409(entry) 
msgid "<placeholder-1/>, <placeholder-2/> (<placeholder-3/> = 0 - 9, A - F)"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:406(entry) 
msgid "hexadecimal byte value"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:410(replaceable) 
msgid "xxxx"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:410(literal) 
msgid "\\u<placeholder-1/>"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:411(replaceable) 
msgid "xxxxxxxx"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:411(literal) 
msgid "\\U<placeholder-1/>"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:412(replaceable) 
msgid "x"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:414(entry) 
msgid "16 or 32-bit hexadecimal Unicode character value"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:420(para) 
msgid "Any other character following a backslash is taken literally. Thus, to include a backslash character, write two backslashes (<literal>\\\\</literal>). Also, a single quote can be included in an escape string by writing <literal>\\'</literal>, in addition to the normal way of <literal>''</literal>."
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:428(para) 
msgid "It is your responsibility that the byte sequences you create, especially when using the octal or hexadecimal escapes, compose valid characters in the server character set encoding. When the server encoding is UTF-8, then the Unicode escapes or the alternative Unicode escape syntax, explained in <xref linkend=\"sql-syntax-strings-uescape\"/>, should be used instead. (The alternative would be doing the UTF-8 encoding by hand and writing out the bytes, which would be very cumbersome.)"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:439(para) 
msgid "The Unicode escape syntax works fully only when the server encoding is <literal>UTF8</literal>. When other server encodings are used, only code points in the ASCII range (up to <literal>\\u007F</literal>) can be specified. Both the 4-digit and the 8-digit form can be used to specify UTF-16 surrogate pairs to compose characters with code points larger than U+FFFF, although the availability of the 8-digit form technically makes this unnecessary. (When surrogate pairs are used when the server encoding is <literal>UTF8</literal>, they are first combined into a single code point that is then encoded in UTF-8.)"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:453(para) 
msgid "If the configuration parameter <xref linkend=\"guc-standard-conforming-strings\"/> is <literal>off</literal>, then <productname>PostgreSQL</productname> recognizes backslash escapes in both regular and escape string constants. However, as of <productname>PostgreSQL</productname> 9.1, the default is <literal>on</literal>, meaning that backslash escapes are recognized only in escape string constants. This behavior is more standards-compliant, but might break applications which rely on the historical behavior, where backslash escapes were always recognized. As a workaround, you can set this parameter to <literal>off</literal>, but it is better to migrate away from using backslash escapes. If you need to use a backslash escape to represent a special character, write the string constant with an <literal>E</literal>."
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:468(para) 
msgid "In addition to <varname>standard_conforming_strings</varname>, the configuration parameters <xref linkend=\"guc-escape-string-warning\"/> and <xref linkend=\"guc-backslash-quote\"/> govern treatment of backslashes in string constants."
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:476(para) 
msgid "The character with the code zero cannot be in a string constant."
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:482(title) 
msgid "String Constants with Unicode Escapes"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:486(secondary) 
msgid "in string constants"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:504(programlisting) 
#, no-wrap
msgid "\nU&amp;'d\\0061t\\+000061'\n"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:509(programlisting) 
#, no-wrap
msgid "\nU&amp;'\\0441\\043B\\043E\\043D'\n"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:489(para) 
msgid "<productname>PostgreSQL</productname> also supports another type of escape syntax for strings that allows specifying arbitrary Unicode characters by code point. A Unicode escape string constant starts with <literal>U&amp;</literal> (upper or lower case letter U followed by ampersand) immediately before the opening quote, without any spaces in between, for example <literal>U&amp;'foo'</literal>. (Note that this creates an ambiguity with the operator <literal>&amp;</literal>. Use spaces around the operator to avoid this problem.) Inside the quotes, Unicode characters can be specified in escaped form by writing a backslash followed by the four-digit hexadecimal code point number or alternatively a backslash followed by a plus sign followed by a six-digit hexadecimal code point number. For example, the string <literal>'data'</literal> could be written as <placeholder-1/> The following less trivial example writes the Russian word <quote>slon</quote> (elephant) in Cyrillic letters: <placeholder-2/>"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:519(programlisting) 
#, no-wrap
msgid "\nU&amp;'d!0061t!+000061' UESCAPE '!'\n"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:514(para) 
msgid "If a different escape character than backslash is desired, it can be specified using the <literal>UESCAPE</literal><indexterm><primary>UESCAPE</primary></indexterm> clause after the string, for example: <placeholder-1/> The escape character can be any single character other than a hexadecimal digit, the plus sign, a single quote, a double quote, or a whitespace character."
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:527(para) 
msgid "The Unicode escape syntax works only when the server encoding is <literal>UTF8</literal>. When other server encodings are used, only code points in the ASCII range (up to <literal>\\007F</literal>) can be specified. Both the 4-digit and the 6-digit form can be used to specify UTF-16 surrogate pairs to compose characters with code points larger than U+FFFF, although the availability of the 6-digit form technically makes this unnecessary. (When surrogate pairs are used when the server encoding is <literal>UTF8</literal>, they are first combined into a single code point that is then encoded in UTF-8.)"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:540(para) 
msgid "Also, the Unicode escape syntax for string constants only works when the configuration parameter <xref linkend=\"guc-standard-conforming-strings\"/> is turned on. This is because otherwise this syntax could confuse clients that parse the SQL statements to the point that it could lead to SQL injections and similar security issues. If the parameter is set to off, this syntax will be rejected with an error message."
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:551(para) 
msgid "To include the escape character in the string literally, write it twice."
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:558(title) 
msgid "Dollar-quoted String Constants"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:561(primary) 
msgid "dollar quoting"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:579(programlisting) 
#, no-wrap
msgid "\n$$Dianne's horse$$\n$SomeTag$Dianne's horse$SomeTag$\n"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:564(para) 
msgid "While the standard syntax for specifying string constants is usually convenient, it can be difficult to understand when the desired string contains many single quotes or backslashes, since each of those must be doubled. To allow more readable queries in such situations, <productname>PostgreSQL</productname> provides another way, called <quote>dollar quoting</quote>, to write string constants. A dollar-quoted string constant consists of a dollar sign (<literal>$</literal>), an optional <quote>tag</quote> of zero or more characters, another dollar sign, an arbitrary sequence of characters that makes up the string content, a dollar sign, the same tag that began this dollar quote, and a dollar sign. For example, here are two different ways to specify the string <quote>Dianne's horse</quote> using dollar quoting: <placeholder-1/> Notice that inside the dollar-quoted string, single quotes can be used without needing to be escaped. Indeed, no characters inside a dollar-quoted string are ever escaped: the string content is always written literally. Backslashes are not special, and neither are dollar signs, unless they are part of a sequence matching the opening tag."
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:595(programlisting) 
#, no-wrap
msgid "\n$function$\nBEGIN\n    RETURN ($1 ~ $q$[\\t\\r\\n\\v\\\\]$q$);\nEND;\n$function$\n"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:591(para) 
msgid "It is possible to nest dollar-quoted string constants by choosing different tags at each nesting level. This is most commonly used in writing function definitions. For example: <placeholder-1/> Here, the sequence <literal>$q$[\\t\\r\\n\\v\\\\]$q$</literal> represents a dollar-quoted literal string <literal>[\\t\\r\\n\\v\\\\]</literal>, which will be recognized when the function body is executed by <productname>PostgreSQL</productname>. But since the sequence does not match the outer dollar quoting delimiter <literal>$function$</literal>, it is just some more characters within the constant so far as the outer string is concerned."
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:611(para) 
msgid "The tag, if any, of a dollar-quoted string follows the same rules as an unquoted identifier, except that it cannot contain a dollar sign. Tags are case sensitive, so <literal>$tag$String content$tag$</literal> is correct, but <literal>$TAG$String content$tag$</literal> is not."
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:618(para) 
msgid "A dollar-quoted string that follows a keyword or identifier must be separated from it by whitespace; otherwise the dollar quoting delimiter would be taken as part of the preceding identifier."
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:624(para) 
msgid "Dollar quoting is not part of the SQL standard, but it is often a more convenient way to write complicated string literals than the standard-compliant single quote syntax. It is particularly useful when representing string constants inside other constants, as is often needed in procedural function definitions. With single-quote syntax, each backslash in the above example would have to be written as four backslashes, which would be reduced to two backslashes in parsing the original string constant, and then to one when the inner string constant is re-parsed during function execution."
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:638(title) 
msgid "Bit-string Constants"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:641(primary) 
msgid "bit string"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:645(para) 
msgid "Bit-string constants look like regular string constants with a <literal>B</literal> (upper or lower case) immediately before the opening quote (no intervening whitespace), e.g., <literal>B'1001'</literal>. The only characters allowed within bit-string constants are <literal>0</literal> and <literal>1</literal>."
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:654(para) 
msgid "Alternatively, bit-string constants can be specified in hexadecimal notation, using a leading <literal>X</literal> (upper or lower case), e.g., <literal>X'1FF'</literal>. This notation is equivalent to a bit-string constant with four binary digits for each hexadecimal digit."
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:661(para) 
msgid "Both forms of bit-string constant can be continued across lines in the same way as regular string constants. Dollar quoting cannot be used in a bit-string constant."
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:669(title) 
msgid "Numeric Constants"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:672(primary) 
msgid "number"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:676(para) 
msgid "Numeric constants are accepted in these general forms: <synopsis>\n<replaceable>digits</replaceable>\n<replaceable>digits</replaceable>.<optional><replaceable>digits</replaceable></optional><optional>e<optional>+-</optional><replaceable>digits</replaceable></optional>\n<optional><replaceable>digits</replaceable></optional>.<replaceable>digits</replaceable><optional>e<optional>+-</optional><replaceable>digits</replaceable></optional>\n<replaceable>digits</replaceable>e<optional>+-</optional><replaceable>digits</replaceable>\n</synopsis> where <replaceable>digits</replaceable> is one or more decimal digits (0 through 9). At least one digit must be before or after the decimal point, if one is used. At least one digit must follow the exponent marker (<literal>e</literal>), if one is present. There cannot be any spaces or other characters embedded in the constant. Note that any leading plus or minus sign is not actually considered part of the constant; it is an operator applied to the constant."
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:694(para) 
msgid "These are some examples of valid numeric constants: <literallayout>\n42\n3.5\n4.\n.001\n5e2\n1.925e-3\n</literallayout>"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:706(para) 
msgid "<indexterm><primary>integer</primary></indexterm><indexterm><primary>bigint</primary></indexterm><indexterm><primary>numeric</primary></indexterm> A numeric constant that contains neither a decimal point nor an exponent is initially presumed to be type <type>integer</type> if its value fits in type <type>integer</type> (32 bits); otherwise it is presumed to be type <type>bigint</type> if its value fits in type <type>bigint</type> (64 bits); otherwise it is taken to be type <type>numeric</type>. Constants that contain decimal points and/or exponents are always initially presumed to be type <type>numeric</type>."
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:730(programlisting) 
#, no-wrap
msgid "\nREAL '1.23'  -- string style\n1.23::REAL   -- PostgreSQL (historical) style\n"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:720(para) 
msgid "The initially assigned data type of a numeric constant is just a starting point for the type resolution algorithms. In most cases the constant will be automatically coerced to the most appropriate type depending on context. When necessary, you can force a numeric value to be interpreted as a specific data type by casting it.<indexterm><primary>type cast</primary></indexterm> For example, you can force a numeric value to be treated as type <type>real</type> (<type>float4</type>) by writing: <placeholder-1/> These are actually just special cases of the general casting notations discussed next."
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:741(title) 
msgid "Constants of Other Types"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:744(primary) /tmp/cicero-fBJf/syntax.xml:1833(primary) 
msgid "data type"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:748(para) 
msgid "A constant of an <emphasis>arbitrary</emphasis> type can be entered using any one of the following notations: <synopsis>\n<replaceable>type</replaceable> '<replaceable>string</replaceable>'\n'<replaceable>string</replaceable>'::<replaceable>type</replaceable>\nCAST ( '<replaceable>string</replaceable>' AS <replaceable>type</replaceable> )\n</synopsis> The string constant's text is passed to the input conversion routine for the type called <replaceable>type</replaceable>. The result is a constant of the indicated type. The explicit type cast can be omitted if there is no ambiguity as to the type the constant must be (for example, when it is assigned directly to a table column), in which case it is automatically coerced."
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:764(para) 
msgid "The string constant can be written using either regular SQL notation or dollar-quoting."
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:769(para) 
msgid "It is also possible to specify a type coercion using a function-like syntax: <synopsis>\n<replaceable>typename</replaceable> ( '<replaceable>string</replaceable>' )\n</synopsis> but not all type names can be used in this way; see <xref linkend=\"sql-syntax-type-casts\"/> for details."
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:779(para) 
msgid "The <literal>::</literal>, <literal>CAST()</literal>, and function-call syntaxes can also be used to specify run-time type conversions of arbitrary expressions, as discussed in <xref linkend=\"sql-syntax-type-casts\"/>. To avoid syntactic ambiguity, the <literal><replaceable>type</replaceable> '<replaceable>string</replaceable>'</literal> syntax can only be used to specify the type of a simple literal constant. Another restriction on the <literal><replaceable>type</replaceable> '<replaceable>string</replaceable>'</literal> syntax is that it does not work for array types; use <literal>::</literal> or <literal>CAST()</literal> to specify the type of an array constant."
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:792(para) 
msgid "The <literal>CAST()</literal> syntax conforms to SQL. The <literal><replaceable>type</replaceable> '<replaceable>string</replaceable>'</literal> syntax is a generalization of the standard: SQL specifies this syntax only for a few data types, but <productname>PostgreSQL</productname> allows it for all types. The syntax with <literal>::</literal> is historical <productname>PostgreSQL</productname> usage, as is the function-call syntax."
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:805(title) 
msgid "Operators"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:808(primary) /tmp/cicero-fBJf/syntax.xml:979(primary) /tmp/cicero-fBJf/syntax.xml:1476(primary) /tmp/cicero-fBJf/syntax.xml:1483(replaceable) /tmp/cicero-fBJf/syntax.xml:1484(replaceable) /tmp/cicero-fBJf/syntax.xml:1485(replaceable) 
msgid "operator"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:822(para) 
msgid "<literal>--</literal> and <literal>/*</literal> cannot appear anywhere in an operator name, since they will be taken as the start of a comment."
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:830(para) 
msgid "A multiple-character operator name cannot end in <literal>+</literal> or <literal>-</literal>, unless the name also contains at least one of these characters: <literallayout>\n~ ! @ # % ^ &amp; | ` ?\n</literallayout> For example, <literal>@-</literal> is an allowed operator name, but <literal>*-</literal> is not. This restriction allows <productname>PostgreSQL</productname> to parse SQL-compliant queries without requiring spaces between tokens."
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:812(para) 
msgid "An operator name is a sequence of up to <symbol>NAMEDATALEN</symbol>-1 (63 by default) characters from the following list: <literallayout>\n+ - * / &lt; &gt; = ~ ! @ # % ^ &amp; | ` ?\n</literallayout> There are a few restrictions on operator names, however: <placeholder-1/>"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:845(para) 
msgid "When working with non-SQL-standard operator names, you will usually need to separate adjacent operators with spaces to avoid ambiguity. For example, if you have defined a left unary operator named <literal>@</literal>, you cannot write <literal>X*@Y</literal>; you must write <literal>X* @Y</literal> to ensure that <productname>PostgreSQL</productname> reads it as two operator names not one."
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:857(title) 
msgid "Special Characters"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:868(para) 
msgid "A dollar sign (<literal>$</literal>) followed by digits is used to represent a positional parameter in the body of a function definition or a prepared statement. In other contexts the dollar sign can be part of an identifier or a dollar-quoted string constant."
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:878(para) 
msgid "Parentheses (<literal>()</literal>) have their usual meaning to group expressions and enforce precedence. In some cases parentheses are required as part of the fixed syntax of a particular SQL command."
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:887(para) 
msgid "Brackets (<literal>[]</literal>) are used to select the elements of an array. See <xref linkend=\"arrays\"/> for more information on arrays."
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:895(para) 
msgid "Commas (<literal>,</literal>) are used in some syntactical constructs to separate the elements of a list."
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:902(para) 
msgid "The semicolon (<literal>;</literal>) terminates an SQL command. It cannot appear anywhere within a command, except within a string constant or quoted identifier."
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:910(para) 
msgid "The colon (<literal>:</literal>) is used to select <quote>slices</quote> from arrays. (See <xref linkend=\"arrays\"/>.) In certain SQL dialects (such as Embedded SQL), the colon is used to prefix variable names."
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:919(para) 
msgid "The asterisk (<literal>*</literal>) is used in some contexts to denote all the fields of a table row or composite value. It also has a special meaning when used as the argument of an aggregate function, namely that the aggregate does not require any explicit parameter."
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:929(para) 
msgid "The period (<literal>.</literal>) is used in numeric constants, and to separate schema, table, and column names."
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:859(para) 
msgid "Some characters that are not alphanumeric have a special meaning that is different from being an operator. Details on the usage can be found at the location where the respective syntax element is described. This section only exists to advise the existence and summarize the purposes of these characters. <placeholder-1/>"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:940(title) 
msgid "Comments"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:943(primary) 
msgid "comment"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:944(secondary) 
msgid "in SQL"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:950(programlisting) 
#, no-wrap
msgid "\n-- This is a standard SQL comment\n"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:947(para) 
msgid "A comment is a sequence of characters beginning with double dashes and extending to the end of the line, e.g.: <placeholder-1/>"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:957(programlisting) 
#, no-wrap
msgid "\n/* multiline comment\n * with nesting: /* nested block comment */\n */\n"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:955(para) 
msgid "Alternatively, C-style block comments can be used: <placeholder-1/> where the comment begins with <literal>/*</literal> and extends to the matching occurrence of <literal>*/</literal>. These block comments nest, as specified in the SQL standard but unlike C, so that one can comment out larger blocks of code that might contain existing block comments."
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:969(para) 
msgid "A comment is removed from the input stream before further syntax analysis and is effectively replaced by whitespace."
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:976(title) 
msgid "Operator Precedence"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:980(secondary) 
msgid "precedence"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:994(programlisting) 
#, no-wrap
msgid "\nSELECT 5 ! - 6;\n"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:998(programlisting) 
#, no-wrap
msgid "\nSELECT 5 ! (- 6);\n"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1005(programlisting) 
#, no-wrap
msgid "\nSELECT (5 !) - 6;\n"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:983(para) 
msgid "<xref linkend=\"sql-precedence-table\"/> shows the precedence and associativity of the operators in <productname>PostgreSQL</productname>. Most operators have the same precedence and are left-associative. The precedence and associativity of the operators is hard-wired into the parser. This can lead to non-intuitive behavior; for example the Boolean operators <literal>&lt;</literal> and <literal>&gt;</literal> have a different precedence than the Boolean operators <literal>&lt;=</literal> and <literal>&gt;=</literal>. Also, you will sometimes need to add parentheses when using combinations of binary and unary operators. For instance: <placeholder-1/> will be parsed as: <placeholder-2/> because the parser has no idea — until it is too late — that <token>!</token> is defined as a postfix operator, not an infix one. To get the desired behavior in this case, you must write: <placeholder-3/> This is the price one pays for extensibility."
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1012(title) 
msgid "Operator Precedence (decreasing)"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1017(entry) 
msgid "Operator/Element"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1018(entry) 
msgid "Associativity"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1019(entry) 
msgid "Description"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1025(token) 
msgid "."
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1026(entry) /tmp/cicero-fBJf/syntax.xml:1032(entry) /tmp/cicero-fBJf/syntax.xml:1038(entry) /tmp/cicero-fBJf/syntax.xml:1050(entry) /tmp/cicero-fBJf/syntax.xml:1056(entry) /tmp/cicero-fBJf/syntax.xml:1062(entry) /tmp/cicero-fBJf/syntax.xml:1086(entry) /tmp/cicero-fBJf/syntax.xml:1134(entry) /tmp/cicero-fBJf/syntax.xml:1140(entry) 
msgid "left"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1027(entry) 
msgid "table/column name separator"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1031(token) /tmp/cicero-fBJf/syntax.xml:1842(primary) 
msgid "::"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1033(productname) 
msgid "PostgreSQL"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1033(entry) 
msgid "<placeholder-1/>-style typecast"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1037(token) 
msgid "["
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1037(token) 
msgid "]"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1039(entry) 
msgid "array element selection"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1043(token) /tmp/cicero-fBJf/syntax.xml:1061(token) 
msgid "+"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1043(token) /tmp/cicero-fBJf/syntax.xml:1061(token) 
msgid "-"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1044(entry) /tmp/cicero-fBJf/syntax.xml:1122(entry) /tmp/cicero-fBJf/syntax.xml:1128(entry) 
msgid "right"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1045(entry) 
msgid "unary plus, unary minus"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1049(token) 
msgid "^"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1051(entry) 
msgid "exponentiation"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1055(token) 
msgid "*"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1055(token) 
msgid "/"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1055(token) 
msgid "%"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1057(entry) 
msgid "multiplication, division, modulo"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1063(entry) 
msgid "addition, subtraction"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1067(token) 
msgid "IS"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1069(literal) 
msgid "IS TRUE"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1069(literal) 
msgid "IS FALSE"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1069(literal) 
msgid "IS NULL"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1069(entry) 
msgid "<placeholder-1/>, <placeholder-2/>, <placeholder-3/>, etc"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1073(token) 
msgid "ISNULL"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1075(entry) 
msgid "test for null"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1079(token) 
msgid "NOTNULL"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1081(entry) 
msgid "test for not null"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1085(entry) 
msgid "(any other)"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1087(entry) 
msgid "all other native and user-defined operators"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1091(token) 
msgid "IN"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1093(entry) 
msgid "set membership"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1097(token) 
msgid "BETWEEN"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1099(entry) 
msgid "range containment"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1103(token) 
msgid "OVERLAPS"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1105(entry) 
msgid "time interval overlap"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1109(token) 
msgid "LIKE"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1109(token) 
msgid "ILIKE"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1109(token) 
msgid "SIMILAR"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1111(entry) 
msgid "string pattern matching"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1115(token) 
msgid "&lt;"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1115(token) 
msgid "&gt;"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1117(entry) 
msgid "less than, greater than"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1121(token) 
msgid "="
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1123(entry) 
msgid "equality, assignment"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1127(token) 
msgid "NOT"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1129(entry) 
msgid "logical negation"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1133(token) 
msgid "AND"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1135(entry) 
msgid "logical conjunction"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1139(token) 
msgid "OR"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1141(entry) 
msgid "logical disjunction"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1147(para) 
msgid "Note that the operator precedence rules also apply to user-defined operators that have the same names as the built-in operators mentioned above. For example, if you define a <quote>+</quote> operator for some custom data type it will have the same precedence as the built-in <quote>+</quote> operator, no matter what yours does."
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1159(programlisting) 
#, no-wrap
msgid "\nSELECT 3 OPERATOR(pg_catalog.+) 4;\n"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1156(para) 
msgid "When a schema-qualified operator name is used in the <literal>OPERATOR</literal> syntax, as for example in: <placeholder-1/> the <literal>OPERATOR</literal> construct is taken to have the default precedence shown in <xref linkend=\"sql-precedence-table\"/> for <quote>any other</quote> operator. This is true no matter which specific operator appears inside <literal>OPERATOR()</literal>."
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1170(title) 
msgid "Value Expressions"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1173(primary) /tmp/cicero-fBJf/syntax.xml:1183(see) /tmp/cicero-fBJf/syntax.xml:1483(replaceable) /tmp/cicero-fBJf/syntax.xml:1483(replaceable) /tmp/cicero-fBJf/syntax.xml:1484(replaceable) /tmp/cicero-fBJf/syntax.xml:1485(replaceable) /tmp/cicero-fBJf/syntax.xml:2250(primary) 
msgid "expression"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1178(primary) 
msgid "value expression"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1182(primary) 
msgid "scalar"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1186(para) 
msgid "Value expressions are used in a variety of contexts, such as in the target list of the <command>SELECT</command> command, as new column values in <command>INSERT</command> or <command>UPDATE</command>, or in search conditions in a number of commands. The result of a value expression is sometimes called a <firstterm>scalar</firstterm>, to distinguish it from the result of a table expression (which is a table). Value expressions are therefore also called <firstterm>scalar expressions</firstterm> (or even simply <firstterm>expressions</firstterm>). The expression syntax allows the calculation of values from primitive parts using arithmetic, logical, set, and other operations."
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1205(para) 
msgid "A constant or literal value"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1211(para) 
msgid "A column reference"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1217(para) 
msgid "A positional parameter reference, in the body of a function definition or prepared statement"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1224(para) 
msgid "A subscripted expression"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1230(para) 
msgid "A field selection expression"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1236(para) 
msgid "An operator invocation"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1242(para) 
msgid "A function call"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1248(para) 
msgid "An aggregate expression"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1254(para) 
msgid "A window function call"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1260(para) 
msgid "A type cast"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1266(para) 
msgid "A collation expression"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1272(para) 
msgid "A scalar subquery"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1278(para) 
msgid "An array constructor"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1284(para) 
msgid "A row constructor"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1290(para) 
msgid "Another value expression in parentheses (used to group subexpressions and override precedence<indexterm><primary>parenthesis</primary></indexterm>)"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1200(para) 
msgid "A value expression is one of the following: <placeholder-1/>"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1299(para) 
msgid "In addition to this list, there are a number of constructs that can be classified as an expression but do not follow any general syntax rules. These generally have the semantics of a function or operator and are explained in the appropriate location in <xref linkend=\"functions\"/>. An example is the <literal>IS NULL</literal> clause."
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1308(para) 
msgid "We have already discussed constants in <xref linkend=\"sql-syntax-constants\"/>. The following sections discuss the remaining options."
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1315(title) 
msgid "Column References"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1318(primary) 
msgid "column reference"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1321(para) 
msgid "A column can be referenced in the form: <synopsis>\n<replaceable>correlation</replaceable>.<replaceable>columnname</replaceable>\n</synopsis>"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1328(para) 
msgid "<replaceable>correlation</replaceable> is the name of a table (possibly qualified with a schema name), or an alias for a table defined by means of a <literal>FROM</literal> clause. The correlation name and separating dot can be omitted if the column name is unique across all the tables being used in the current query. (See also <xref linkend=\"queries\"/>.)"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1338(title) 
msgid "Positional Parameters"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1341(primary) 
msgid "parameter"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1346(primary) 
msgid "$"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1349(para) 
msgid "A positional parameter reference is used to indicate a value that is supplied externally to an SQL statement. Parameters are used in SQL function definitions and in prepared queries. Some client libraries also support specifying data values separately from the SQL command string, in which case parameters are used to refer to the out-of-line data values. The form of a parameter reference is: <synopsis>\n$<replaceable>number</replaceable>\n</synopsis>"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1366(programlisting) 
#, no-wrap
msgid "\nCREATE FUNCTION dept(text) RETURNS dept\n    AS $$ SELECT * FROM dept WHERE name = $1 $$\n    LANGUAGE SQL;\n"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1362(para) 
msgid "For example, consider the definition of a function, <function>dept</function>, as: <placeholder-1/> Here the <literal>$1</literal> references the value of the first function argument whenever the function is invoked."
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1378(title) 
msgid "Subscripts"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1381(primary) 
msgid "subscript"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1384(para) 
msgid "If an expression yields a value of an array type, then a specific element of the array value can be extracted by writing <synopsis>\n<replaceable>expression</replaceable>[<replaceable>subscript</replaceable>]\n</synopsis> or multiple adjacent elements (an <quote>array slice</quote>) can be extracted by writing <synopsis>\n<replaceable>expression</replaceable>[<replaceable>lower_subscript</replaceable>:<replaceable>upper_subscript</replaceable>]\n</synopsis> (Here, the brackets <literal>[ ]</literal> are meant to appear literally.) Each <replaceable>subscript</replaceable> is itself an expression, which must yield an integer value."
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1408(programlisting) 
#, no-wrap
msgid "\nmytable.arraycolumn[4]\nmytable.two_d_column[17][34]\n$1[10:42]\n(arrayfunction(a,b))[42]\n"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1400(para) 
msgid "In general the array <replaceable>expression</replaceable> must be parenthesized, but the parentheses can be omitted when the expression to be subscripted is just a column reference or positional parameter. Also, multiple subscripts can be concatenated when the original array is multidimensional. For example: <placeholder-1/> The parentheses in the last example are required. See <xref linkend=\"arrays\"/> for more about arrays."
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1421(title) 
msgid "Field Selection"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1424(primary) 
msgid "field selection"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1427(para) 
msgid "If an expression yields a value of a composite type (row type), then a specific field of the row can be extracted by writing <synopsis>\n<replaceable>expression</replaceable>.<replaceable>fieldname</replaceable>\n</synopsis>"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1441(programlisting) 
#, no-wrap
msgid "\nmytable.mycolumn\n$1.somecolumn\n(rowfunction(a,b)).col3\n"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1451(programlisting) 
#, no-wrap
msgid "\n(compositecol).somefield\n(mytable.compositecol).somefield\n"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1435(para) 
msgid "In general the row <replaceable>expression</replaceable> must be parenthesized, but the parentheses can be omitted when the expression to be selected from is just a table reference or positional parameter. For example: <placeholder-1/> (Thus, a qualified column reference is actually just a special case of the field selection syntax.) An important special case is extracting a field from a table column that is of a composite type: <placeholder-2/> The parentheses are required here to show that <structfield>compositecol</structfield> is a column name not a table name, or that <structname>mytable</structname> is a table name not a schema name in the second case."
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1466(programlisting) 
#, no-wrap
msgid "\n(compositecol).*\n"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1462(para) 
msgid "In a select list (see <xref linkend=\"queries-select-lists\"/>), you can ask for all fields of a composite value by writing <literal>.*</literal>: <placeholder-1/>"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1473(title) 
msgid "Operator Invocations"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1477(secondary) /tmp/cicero-fBJf/syntax.xml:1506(secondary) /tmp/cicero-fBJf/syntax.xml:1555(secondary) /tmp/cicero-fBJf/syntax.xml:1694(secondary) 
msgid "invocation"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1483(member) 
msgid "<placeholder-1/><placeholder-2/><placeholder-3/> (binary infix operator)"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1484(member) 
msgid "<placeholder-1/><placeholder-2/> (unary prefix operator)"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1485(member) 
msgid "<placeholder-1/><placeholder-2/> (unary postfix operator)"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1480(para) 
msgid "There are three possible syntaxes for an operator invocation: <placeholder-1/> where the <replaceable>operator</replaceable> token follows the syntax rules of <xref linkend=\"sql-syntax-operators\"/>, or is one of the key words <token>AND</token>, <token>OR</token>, and <token>NOT</token>, or is a qualified operator name in the form: <synopsis>\n<literal>OPERATOR(</literal><replaceable>schema</replaceable><literal>.</literal><replaceable>operatorname</replaceable><literal>)</literal>\n</synopsis> Which particular operators exist and whether they are unary or binary depends on what operators have been defined by the system or the user. <xref linkend=\"functions\"/> describes the built-in operators."
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1502(title) 
msgid "Function Calls"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1505(primary) /tmp/cicero-fBJf/syntax.xml:2373(primary) /tmp/cicero-fBJf/syntax.xml:2408(primary) /tmp/cicero-fBJf/syntax.xml:2447(primary) 
msgid "function"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1509(para) 
msgid "The syntax for a function call is the name of a function (possibly qualified with a schema name), followed by its argument list enclosed in parentheses: <synopsis>\n<replaceable>function_name</replaceable> (<optional><replaceable>expression</replaceable> <optional>, <replaceable>expression</replaceable> ... </optional></optional> )\n</synopsis>"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1521(programlisting) 
#, no-wrap
msgid "\nsqrt(2)\n"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1519(para) 
msgid "For example, the following computes the square root of 2: <placeholder-1/>"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1526(para) 
msgid "The list of built-in functions is in <xref linkend=\"functions\"/>. Other functions can be added by the user."
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1531(para) 
msgid "The arguments can optionally have names attached. See <xref linkend=\"sql-syntax-calling-funcs\"/> for details."
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1537(para) 
msgid "A function that takes a single argument of composite type can optionally be called using field-selection syntax, and conversely field selection can be written in functional style. That is, the notations <literal>col(table)</literal> and <literal>table.col</literal> are interchangeable. This behavior is not SQL-standard but is provided in <productname>PostgreSQL</productname> because it allows use of functions to emulate <quote>computed fields</quote>. For more information see <xref linkend=\"xfunc-sql-composite-functions\"/>."
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1551(title) 
msgid "Aggregate Expressions"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1554(primary) 
msgid "aggregate function"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1558(para) 
msgid "An <firstterm>aggregate expression</firstterm> represents the application of an aggregate function across the rows selected by a query. An aggregate function reduces multiple inputs to a single output value, such as the sum or average of the inputs. The syntax of an aggregate expression is one of the following: <synopsis>\n<replaceable>aggregate_name</replaceable> (<replaceable>expression</replaceable> [ , ... ] [ <replaceable>order_by_clause</replaceable> ] )\n<replaceable>aggregate_name</replaceable> (ALL <replaceable>expression</replaceable> [ , ... ] [ <replaceable>order_by_clause</replaceable> ] )\n<replaceable>aggregate_name</replaceable> (DISTINCT <replaceable>expression</replaceable> [ , ... ] [ <replaceable>order_by_clause</replaceable> ] )\n<replaceable>aggregate_name</replaceable> ( * )\n</synopsis> where <replaceable>aggregate_name</replaceable> is a previously defined aggregate (possibly qualified with a schema name), <replaceable>expression</replaceable> is any value expression that does not itself contain an aggregate expression or a window function call, and <replaceable>order_by_clause</replaceable> is a optional <literal>ORDER BY</literal> clause as described below."
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1581(para) 
msgid "The first form of aggregate expression invokes the aggregate once for each input row. The second form is the same as the first, since <literal>ALL</literal> is the default. The third form invokes the aggregate once for each distinct value of the expression (or distinct set of values, for multiple expressions) found in the input rows. The last form invokes the aggregate once for each input row; since no particular input value is specified, it is generally only useful for the <function>count(*)</function> aggregate function."
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1594(para) 
msgid "Most aggregate functions ignore null inputs, so that rows in which one or more of the expression(s) yield null are discarded. This can be assumed to be true, unless otherwise specified, for all built-in aggregates."
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1601(para) 
msgid "For example, <literal>count(*)</literal> yields the total number of input rows; <literal>count(f1)</literal> yields the number of input rows in which <literal>f1</literal> is non-null, since <function>count</function> ignores nulls; and <literal>count(distinct f1)</literal> yields the number of distinct non-null values of <literal>f1</literal>."
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1623(programlisting) 
#, no-wrap
msgid "\nSELECT array_agg(a ORDER BY b DESC) FROM table;\n"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1610(para) 
msgid "Ordinarily, the input rows are fed to the aggregate function in an unspecified order. In many cases this does not matter; for example, <function>min</function> produces the same result no matter what order it receives the inputs in. However, some aggregate functions (such as <function>array_agg</function> and <function>string_agg</function>) produce results that depend on the ordering of the input rows. When using such an aggregate, the optional <replaceable>order_by_clause</replaceable> can be used to specify the desired ordering. The <replaceable>order_by_clause</replaceable> has the same syntax as for a query-level <literal>ORDER BY</literal> clause, as described in <xref linkend=\"queries-order\"/>, except that its expressions are always just expressions and cannot be output-column names or numbers. For example: <placeholder-1/>"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1632(programlisting) 
#, no-wrap
msgid "\nSELECT string_agg(a, ',' ORDER BY a) FROM table;\n"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1636(programlisting) 
#, no-wrap
msgid "\nSELECT string_agg(a ORDER BY a, ',') FROM table;  -- incorrect\n"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1628(para) 
msgid "When dealing with multiple-argument aggregate functions, note that the <literal>ORDER BY</literal> clause goes after all the aggregate arguments. For example, write this: <placeholder-1/> not this: <placeholder-2/> The latter is syntactically valid, but it represents a call of a single-argument aggregate function with two <literal>ORDER BY</literal> keys (the second one being rather useless since it's a constant)."
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1644(para) 
msgid "If <literal>DISTINCT</literal> is specified in addition to an <replaceable>order_by_clause</replaceable>, then all the <literal>ORDER BY</literal> expressions must match regular arguments of the aggregate; that is, you cannot sort on an expression that is not included in the <literal>DISTINCT</literal> list."
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1653(para) 
msgid "The ability to specify both <literal>DISTINCT</literal> and <literal>ORDER BY</literal> in an aggregate function is a <productname>PostgreSQL</productname> extension."
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1659(para) 
msgid "The predefined aggregate functions are described in <xref linkend=\"functions-aggregate\"/>. Other aggregate functions can be added by the user."
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1665(para) 
msgid "An aggregate expression can only appear in the result list or <literal>HAVING</literal> clause of a <command>SELECT</command> command. It is forbidden in other clauses, such as <literal>WHERE</literal>, because those clauses are logically evaluated before the results of aggregates are formed."
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1673(para) 
msgid "When an aggregate expression appears in a subquery (see <xref linkend=\"sql-syntax-scalar-subqueries\"/> and <xref linkend=\"functions-subquery\"/>), the aggregate is normally evaluated over the rows of the subquery. But an exception occurs if the aggregate's arguments contain only outer-level variables: the aggregate then belongs to the nearest such outer level, and is evaluated over the rows of that query. The aggregate expression as a whole is then an outer reference for the subquery it appears in, and acts as a constant over any one evaluation of that subquery. The restriction about appearing only in the result list or <literal>HAVING</literal> clause applies with respect to the query level that the aggregate belongs to."
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1690(title) 
msgid "Window Function Calls"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1693(primary) 
msgid "window function"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1698(primary) 
msgid "OVER clause"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1701(para) 
msgid "A <firstterm>window function call</firstterm> represents the application of an aggregate-like function over some portion of the rows selected by a query. Unlike regular aggregate function calls, this is not tied to grouping of the selected rows into a single output row — each row remains separate in the query output. However the window function is able to scan all the rows that would be part of the current row's group according to the grouping specification (<literal>PARTITION BY</literal> list) of the window function call. The syntax of a window function call is one of the following: <synopsis>\n<replaceable>function_name</replaceable> (<optional><replaceable>expression</replaceable> <optional>, <replaceable>expression</replaceable> ... </optional></optional>) OVER ( <replaceable class=\"parameter\">window_definition</replaceable> )\n<replaceable>function_name</replaceable> (<optional><replaceable>expression</replaceable> <optional>, <replaceable>expression</replaceable> ... </optional></optional>) OVER <replaceable>window_name</replaceable>\n<replaceable>function_name</replaceable> ( * ) OVER ( <replaceable class=\"parameter\">window_definition</replaceable> )\n<replaceable>function_name</replaceable> ( * ) OVER <replaceable>window_name</replaceable>\n</synopsis> where <replaceable class=\"parameter\">window_definition</replaceable> has the syntax <synopsis>\n[ <replaceable class=\"parameter\">existing_window_name</replaceable> ]\n[ PARTITION BY <replaceable class=\"parameter\">expression</replaceable> [, ...] ]\n[ ORDER BY <replaceable class=\"parameter\">expression</replaceable> [ ASC | DESC | USING <replaceable class=\"parameter\">operator</replaceable> ] [ NULLS { FIRST | LAST } ] [, ...] ]\n[ <replaceable class=\"parameter\">frame_clause</replaceable> ]\n</synopsis> and the optional <replaceable class=\"parameter\">frame_clause</replaceable> can be one of <synopsis>\n[ RANGE | ROWS ] <replaceable>frame_start</replaceable>\n[ RANGE | ROWS ] BETWEEN <replaceable>frame_start</replaceable> AND <replaceable>frame_end</replaceable>\n</synopsis> where <replaceable>frame_start</replaceable> and <replaceable>frame_end</replaceable> can be one of <synopsis>\nUNBOUNDED PRECEDING\n<replaceable>value</replaceable> PRECEDING\nCURRENT ROW\n<replaceable>value</replaceable> FOLLOWING\nUNBOUNDED FOLLOWING\n</synopsis>"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1743(para) 
msgid "Here, <replaceable>expression</replaceable> represents any value expression that does not itself contain window function calls. The <literal>PARTITION BY</literal> and <literal>ORDER BY</literal> lists have essentially the same syntax and semantics as <literal>GROUP BY</literal> and <literal>ORDER BY</literal> clauses of the whole query, except that their expressions are always just expressions and cannot be output-column names or numbers. <replaceable>window_name</replaceable> is a reference to a named window specification defined in the query's <literal>WINDOW</literal> clause. Named window specifications are usually referenced with just <literal>OVER</literal><replaceable>window_name</replaceable>, but it is also possible to write a window name inside the parentheses and then optionally supply an ordering clause and/or frame clause (the referenced window must lack these clauses, if they are supplied here). This latter syntax follows the same rules as modifying an existing window name within the <literal>WINDOW</literal> clause; see the <xref linkend=\"sql-select\"/> reference page for details."
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1764(para) 
msgid "The <replaceable class=\"parameter\">frame_clause</replaceable> specifies the set of rows constituting the <firstterm>window frame</firstterm>, for those window functions that act on the frame instead of the whole partition. If <replaceable>frame_end</replaceable> is omitted it defaults to <literal>CURRENT ROW</literal>. Restrictions are that <replaceable>frame_start</replaceable> cannot be <literal>UNBOUNDED FOLLOWING</literal>, <replaceable>frame_end</replaceable> cannot be <literal>UNBOUNDED PRECEDING</literal>, and the <replaceable>frame_end</replaceable> choice cannot appear earlier in the above list than the <replaceable>frame_start</replaceable> choice — for example <literal>RANGE BETWEEN CURRENT ROW AND <replaceable>value</replaceable> PRECEDING</literal> is not allowed. The default framing option is <literal>RANGE UNBOUNDED PRECEDING</literal>, which is the same as <literal>RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW</literal>; it sets the frame to be all rows from the partition start up through the current row's last peer in the <literal>ORDER BY</literal> ordering (which means all rows if there is no <literal>ORDER BY</literal>). In general, <literal>UNBOUNDED PRECEDING</literal> means that the frame starts with the first row of the partition, and similarly <literal>UNBOUNDED FOLLOWING</literal> means that the frame ends with the last row of the partition (regardless of <literal>RANGE</literal> or <literal>ROWS</literal> mode). In <literal>ROWS</literal> mode, <literal>CURRENT ROW</literal> means that the frame starts or ends with the current row; but in <literal>RANGE</literal> mode it means that the frame starts or ends with the current row's first or last peer in the <literal>ORDER BY</literal> ordering. The <replaceable>value</replaceable><literal>PRECEDING</literal> and <replaceable>value</replaceable><literal>FOLLOWING</literal> cases are currently only allowed in <literal>ROWS</literal> mode. They indicate that the frame starts or ends with the row that many rows before or after the current row. <replaceable>value</replaceable> must be an integer expression not containing any variables, aggregate functions, or window functions. The value must not be null or negative; but it can be zero, which selects the current row itself."
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1799(para) 
msgid "The built-in window functions are described in <xref linkend=\"functions-window-table\"/>. Other window functions can be added by the user. Also, any built-in or user-defined aggregate function can be used as a window function."
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1806(para) 
msgid "The syntaxes using <literal>*</literal> are used for calling parameter-less aggregate functions as window functions, for example <literal>count(*) OVER (PARTITION BY x ORDER BY y)</literal>. <literal>*</literal> is customarily not used for non-aggregate window functions. Aggregate window functions, unlike normal aggregate functions, do not allow <literal>DISTINCT</literal> or <literal>ORDER BY</literal> to be used within the function argument list."
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1816(para) 
msgid "Window function calls are permitted only in the <literal>SELECT</literal> list and the <literal>ORDER BY</literal> clause of the query."
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1821(para) 
msgid "More information about window functions can be found in <xref linkend=\"tutorial-window\"/>, <xref linkend=\"functions-window\"/>, <xref linkend=\"queries-window\"/>."
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1830(title) 
msgid "Type Casts"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1834(secondary) /tmp/cicero-fBJf/syntax.xml:1838(primary) 
msgid "type cast"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1845(para) 
msgid "A type cast specifies a conversion from one data type to another. <productname>PostgreSQL</productname> accepts two equivalent syntaxes for type casts: <synopsis>\nCAST ( <replaceable>expression</replaceable> AS <replaceable>type</replaceable> )\n<replaceable>expression</replaceable>::<replaceable>type</replaceable>\n</synopsis> The <literal>CAST</literal> syntax conforms to SQL; the syntax with <literal>::</literal> is historical <productname>PostgreSQL</productname> usage."
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1858(para) 
msgid "When a cast is applied to a value expression of a known type, it represents a run-time type conversion. The cast will succeed only if a suitable type conversion operation has been defined. Notice that this is subtly different from the use of casts with constants, as shown in <xref linkend=\"sql-syntax-constants-generic\"/>. A cast applied to an unadorned string literal represents the initial assignment of a type to a literal constant value, and so it will succeed for any type (if the contents of the string literal are acceptable input syntax for the data type)."
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1870(para) 
msgid "An explicit type cast can usually be omitted if there is no ambiguity as to the type that a value expression must produce (for example, when it is assigned to a table column); the system will automatically apply a type cast in such cases. However, automatic casting is only done for casts that are marked <quote>OK to apply implicitly</quote> in the system catalogs. Other casts must be invoked with explicit casting syntax. This restriction is intended to prevent surprising conversions from being applied silently."
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1881(para) 
msgid "It is also possible to specify a type cast using a function-like syntax: <synopsis>\n<replaceable>typename</replaceable> ( <replaceable>expression</replaceable> )\n</synopsis> However, this only works for types whose names are also valid as function names. For example, <literal>double precision</literal> cannot be used this way, but the equivalent <literal>float8</literal> can. Also, the names <literal>interval</literal>, <literal>time</literal>, and <literal>timestamp</literal> can only be used in this fashion if they are double-quoted, because of syntactic conflicts. Therefore, the use of the function-like cast syntax leads to inconsistencies and should probably be avoided."
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1898(para) 
msgid "The function-like syntax is in fact just a function call. When one of the two standard cast syntaxes is used to do a run-time conversion, it will internally invoke a registered function to perform the conversion. By convention, these conversion functions have the same name as their output type, and thus the <quote>function-like syntax</quote> is nothing more than a direct invocation of the underlying conversion function. Obviously, this is not something that a portable application should rely on. For further details see <xref linkend=\"sql-createcast\"/>."
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1913(title) 
msgid "Collation Expressions"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1916(primary) 
msgid "COLLATE"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1919(para) 
msgid "The <literal>COLLATE</literal> clause overrides the collation of an expression. It is appended to the expression it applies to: <synopsis>\n<replaceable>expr</replaceable> COLLATE <replaceable>collation</replaceable>\n</synopsis> where <replaceable>collation</replaceable> is a possibly schema-qualified identifier. The <literal>COLLATE</literal> clause binds tighter than operators; parentheses can be used when necessary."
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1931(para) 
msgid "If no collation is explicitly specified, the database system either derives a collation from the columns involved in the expression, or it defaults to the default collation of the database if no column is involved in the expression."
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1942(programlisting) 
#, no-wrap
msgid "\nSELECT a, b, c FROM tbl WHERE ... ORDER BY a COLLATE \"C\";\n"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1947(programlisting) 
#, no-wrap
msgid "\nSELECT * FROM tbl WHERE a &gt; 'foo' COLLATE \"C\";\n"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1960(programlisting) 
#, no-wrap
msgid "\nSELECT * FROM tbl WHERE a COLLATE \"C\" &gt; 'foo';\n"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1964(programlisting) 
#, no-wrap
msgid "\nSELECT * FROM tbl WHERE (a &gt; 'foo') COLLATE \"C\";\n"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1938(para) 
msgid "The two common uses of the <literal>COLLATE</literal> clause are overriding the sort order in an <literal>ORDER BY</literal> clause, for example: <placeholder-1/> and overriding the collation of a function or operator call that has locale-sensitive results, for example: <placeholder-2/> Note that in the latter case the <literal>COLLATE</literal> clause is attached to an input argument of the operator we wish to affect. It doesn't matter which argument of the operator or function call the <literal>COLLATE</literal> clause is attached to, because the collation that is applied by the operator or function is derived by considering all arguments, and an explicit <literal>COLLATE</literal> clause will override the collations of all other arguments. (Attaching non-matching <literal>COLLATE</literal> clauses to more than one argument, however, is an error. For more details see <xref linkend=\"collation\"/>.) Thus, this gives the same result as the previous example: <placeholder-3/> But this is an error: <placeholder-4/> because it attempts to apply a collation to the result of the <literal>&gt;</literal> operator, which is of the non-collatable data type <type>boolean</type>."
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1974(title) 
msgid "Scalar Subqueries"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1977(primary) 
msgid "subquery"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1980(para) 
msgid "A scalar subquery is an ordinary <command>SELECT</command> query in parentheses that returns exactly one row with one column. (See <xref linkend=\"queries\"/> for information about writing queries.) The <command>SELECT</command> query is executed and the single returned value is used in the surrounding value expression. It is an error to use a query that returns more than one row or more than one column as a scalar subquery. (But if, during a particular execution, the subquery returns no rows, there is no error; the scalar result is taken to be null.) The subquery can refer to variables from the surrounding query, which will act as constants during any one evaluation of the subquery. See also <xref linkend=\"functions-subquery\"/> for other expressions involving subqueries."
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1998(programlisting) 
#, no-wrap
msgid "\nSELECT name, (SELECT max(pop) FROM cities WHERE cities.state = states.name)\n    FROM states;\n"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:1995(para) 
msgid "For example, the following finds the largest city population in each state: <placeholder-1/>"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:2006(title) 
msgid "Array Constructors"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:2009(primary) 
msgid "array"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:2010(secondary) /tmp/cicero-fBJf/syntax.xml:2137(secondary) /tmp/cicero-fBJf/syntax.xml:2142(secondary) 
msgid "constructor"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:2014(primary) 
msgid "ARRAY"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:2025(programlisting) 
#, no-wrap
msgid "\nSELECT ARRAY[1,2,3+4];\n  array\n---------\n {1,2,7}\n(1 row)\n"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:2038(programlisting) 
#, no-wrap
msgid "\nSELECT ARRAY[1,2,22.7]::integer[];\n  array\n----------\n {1,2,23}\n(1 row)\n"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:2017(para) 
msgid "An array constructor is an expression that builds an array value using values for its member elements. A simple array constructor consists of the key word <literal>ARRAY</literal>, a left square bracket <literal>[</literal>, a list of expressions (separated by commas) for the array element values, and finally a right square bracket <literal>]</literal>. For example: <placeholder-1/> By default, the array element type is the common type of the member expressions, determined using the same rules as for <literal>UNION</literal> or <literal>CASE</literal> constructs (see <xref linkend=\"typeconv-union-case\"/>). You can override this by explicitly casting the array constructor to the desired type, for example: <placeholder-2/> This has the same effect as casting each expression to the array element type individually. For more on casting, see <xref linkend=\"sql-syntax-type-casts\"/>."
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:2056(programlisting) 
#, no-wrap
msgid "\nSELECT ARRAY[ARRAY[1,2], ARRAY[3,4]];\n     array\n---------------\n {{1,2},{3,4}}\n(1 row)\n\nSELECT ARRAY[[1,2],[3,4]];\n     array\n---------------\n {{1,2},{3,4}}\n(1 row)\n"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:2050(para) 
msgid "Multidimensional array values can be built by nesting array constructors. In the inner constructors, the key word <literal>ARRAY</literal> can be omitted. For example, these produce the same result: <placeholder-1/> Since multidimensional arrays must be rectangular, inner constructors at the same level must produce sub-arrays of identical dimensions. Any cast applied to the outer <literal>ARRAY</literal> constructor propagates automatically to all the inner constructors."
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:2080(programlisting) 
#, no-wrap
msgid "\nCREATE TABLE arr(f1 int[], f2 int[]);\n\nINSERT INTO arr VALUES (ARRAY[[1,2],[3,4]], ARRAY[[5,6],[7,8]]);\n\nSELECT ARRAY[f1, f2, '{{9,10},{11,12}}'::int[]] FROM arr;\n                     array\n------------------------------------------------\n {{{1,2},{3,4}},{{5,6},{7,8}},{{9,10},{11,12}}}\n(1 row)\n"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:2076(para) 
msgid "Multidimensional array constructor elements can be anything yielding an array of the proper kind, not only a sub-<literal>ARRAY</literal> construct. For example: <placeholder-1/>"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:2097(programlisting) 
#, no-wrap
msgid "\nSELECT ARRAY[]::integer[];\n array\n-------\n {}\n(1 row)\n"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:2093(para) 
msgid "You can construct an empty array, but since it's impossible to have an array with no type, you must explicitly cast your empty array to the desired type. For example: <placeholder-1/>"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:2111(programlisting) 
#, no-wrap
msgid "\nSELECT ARRAY(SELECT oid FROM pg_proc WHERE proname LIKE 'bytea%');\n                          ?column?\n-------------------------------------------------------------\n {2011,1954,1948,1952,1951,1244,1950,2005,1949,1953,2006,31}\n(1 row)\n"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:2106(para) 
msgid "It is also possible to construct an array from the results of a subquery. In this form, the array constructor is written with the key word <literal>ARRAY</literal> followed by a parenthesized (not bracketed) subquery. For example: <placeholder-1/> The subquery must return a single column. The resulting one-dimensional array will have an element for each row in the subquery result, with an element type matching that of the subquery's output column."
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:2124(para) 
msgid "The subscripts of an array value built with <literal>ARRAY</literal> always begin with one. For more information about arrays, see <xref linkend=\"arrays\"/>."
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:2133(title) 
msgid "Row Constructors"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:2136(primary) 
msgid "composite type"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:2141(primary) 
msgid "row type"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:2146(primary) 
msgid "ROW"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:2156(programlisting) 
#, no-wrap
msgid "\nSELECT ROW(1,2.5,'this is a test');\n"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:2149(para) 
msgid "A row constructor is an expression that builds a row value (also called a composite value) using values for its member fields. A row constructor consists of the key word <literal>ROW</literal>, a left parenthesis, zero or more expressions (separated by commas) for the row field values, and finally a right parenthesis. For example: <placeholder-1/> The key word <literal>ROW</literal> is optional when there is more than one expression in the list."
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:2170(programlisting) 
#, no-wrap
msgid "\nSELECT ROW(t.*, 42) FROM t;\nSELECT ROW(t.f1, t.f2, 42) FROM t;\n"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:2163(para) 
msgid "A row constructor can include the syntax <replaceable>rowvalue</replaceable><literal>.*</literal>, which will be expanded to a list of the elements of the row value, just as occurs when the <literal>.*</literal> syntax is used at the top level of a <command>SELECT</command> list. For example, if table <literal>t</literal> has columns <literal>f1</literal> and <literal>f2</literal>, these are the same: <placeholder-1/>"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:2177(para) 
msgid "Before <productname>PostgreSQL</productname> 8.2, the <literal>.*</literal> syntax was not expanded, so that writing <literal>ROW(t.*, 42)</literal> created a two-field row whose first field was another row value. The new behavior is usually more useful. If you need the old behavior of nested row values, write the inner row value without <literal>.*</literal>, for instance <literal>ROW(t, 42)</literal>."
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:2194(programlisting) 
#, no-wrap
msgid "\nCREATE TABLE mytable(f1 int, f2 float, f3 text);\n\nCREATE FUNCTION getf1(mytable) RETURNS int AS 'SELECT $1.f1' LANGUAGE SQL;\n\n-- No cast needed since only one getf1() exists\nSELECT getf1(ROW(1,2.5,'this is a test'));\n getf1\n-------\n     1\n(1 row)\n\nCREATE TYPE myrowtype AS (f1 int, f2 text, f3 numeric);\n\nCREATE FUNCTION getf1(myrowtype) RETURNS int AS 'SELECT $1.f1' LANGUAGE SQL;\n\n-- Now we need a cast to indicate which function to call:\nSELECT getf1(ROW(1,2.5,'this is a test'));\nERROR:  function getf1(record) is not unique\n\nSELECT getf1(ROW(1,2.5,'this is a test')::mytable);\n getf1\n-------\n     1\n(1 row)\n\nSELECT getf1(CAST(ROW(11,'this is a test',2.5) AS myrowtype));\n getf1\n-------\n    11\n(1 row)\n"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:2188(para) 
msgid "By default, the value created by a <literal>ROW</literal> expression is of an anonymous record type. If necessary, it can be cast to a named composite type — either the row type of a table, or a composite type created with <command>CREATE TYPE AS</command>. An explicit cast might be needed to avoid ambiguity. For example: <placeholder-1/>"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:2234(programlisting) 
#, no-wrap
msgid "\nSELECT ROW(1,2.5,'this is a test') = ROW(1, 3, 'not the same');\n\nSELECT ROW(table.*) IS NULL FROM table;  -- detect all-null rows\n"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:2228(para) 
msgid "Row constructors can be used to build composite values to be stored in a composite-type table column, or to be passed to a function that accepts a composite parameter. Also, it is possible to compare two row values or test a row with <literal>IS NULL</literal> or <literal>IS NOT NULL</literal>, for example: <placeholder-1/> For more detail see <xref linkend=\"functions-comparisons\"/>. Row constructors can also be used in connection with subqueries, as discussed in <xref linkend=\"functions-subquery\"/>."
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:2247(title) 
msgid "Expression Evaluation Rules"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:2251(secondary) 
msgid "order of evaluation"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:2254(para) 
msgid "The order of evaluation of subexpressions is not defined. In particular, the inputs of an operator or function are not necessarily evaluated left-to-right or in any other fixed order."
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:2264(programlisting) 
#, no-wrap
msgid "\nSELECT true OR somefunc();\n"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:2269(programlisting) 
#, no-wrap
msgid "\nSELECT somefunc() OR true;\n"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:2260(para) 
msgid "Furthermore, if the result of an expression can be determined by evaluating only some parts of it, then other subexpressions might not be evaluated at all. For instance, if one wrote: <placeholder-1/> then <literal>somefunc()</literal> would (probably) not be called at all. The same would be the case if one wrote: <placeholder-2/> Note that this is not the same as the left-to-right <quote>short-circuiting</quote> of Boolean operators that is found in some programming languages."
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:2277(para) 
msgid "As a consequence, it is unwise to use functions with side effects as part of complex expressions. It is particularly dangerous to rely on side effects or evaluation order in <literal>WHERE</literal> and <literal>HAVING</literal> clauses, since those clauses are extensively reprocessed as part of developing an execution plan. Boolean expressions (<literal>AND</literal>/<literal>OR</literal>/<literal>NOT</literal> combinations) in those clauses can be reorganized in any manner allowed by the laws of Boolean algebra."
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:2292(programlisting) 
#, no-wrap
msgid "\nSELECT ... WHERE x &gt; 0 AND y/x &gt; 1.5;\n"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:2296(programlisting) 
#, no-wrap
msgid "\nSELECT ... WHERE CASE WHEN x &gt; 0 THEN y/x &gt; 1.5 ELSE false END;\n"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:2287(para) 
msgid "When it is essential to force evaluation order, a <literal>CASE</literal> construct (see <xref linkend=\"functions-conditional\"/>) can be used. For example, this is an untrustworthy way of trying to avoid division by zero in a <literal>WHERE</literal> clause: <placeholder-1/> But this is safe: <placeholder-2/> A <literal>CASE</literal> construct used in this fashion will defeat optimization attempts, so it should only be done when necessary. (In this particular example, it would be better to sidestep the problem by writing <literal>y &gt; 1.5*x</literal> instead.)"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:2308(title) 
msgid "Calling Functions"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:2311(primary) 
msgid "notation"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:2312(secondary) 
msgid "functions"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:2315(para) 
msgid "<productname>PostgreSQL</productname> allows functions that have named parameters to be called using either <firstterm>positional</firstterm> or <firstterm>named</firstterm> notation. Named notation is especially useful for functions that have a large number of parameters, since it makes the associations between parameters and actual arguments more explicit and reliable. In positional notation, a function call is written with its argument values in the same order as they are defined in the function declaration. In named notation, the arguments are matched to the function parameters by name and can be written in any order."
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:2328(para) 
msgid "In either notation, parameters that have default values given in the function declaration need not be written in the call at all. But this is particularly useful in named notation, since any combination of parameters can be omitted; while in positional notation parameters can only be omitted from right to left."
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:2336(para) 
msgid "<productname>PostgreSQL</productname> also supports <firstterm>mixed</firstterm> notation, which combines positional and named notation. In this case, positional parameters are written first and named parameters appear after them."
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:2346(programlisting) 
#, no-wrap
msgid "\nCREATE FUNCTION concat_lower_or_upper(a text, b text, uppercase boolean DEFAULT false)\nRETURNS text\nAS\n$$\n SELECT CASE\n        WHEN $3 THEN UPPER($1 || ' ' || $2)\n        ELSE LOWER($1 || ' ' || $2)\n        END;\n$$\nLANGUAGE SQL IMMUTABLE STRICT;\n"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:2343(para) 
msgid "The following examples will illustrate the usage of all three notations, using the following function definition: <placeholder-1/> Function <function>concat_lower_or_upper</function> has two mandatory parameters, <literal>a</literal> and <literal>b</literal>. Additionally there is one optional parameter <literal>uppercase</literal> which defaults to <literal>false</literal>. The <literal>a</literal> and <literal>b</literal> inputs will be concatenated, and forced to either upper or lower case depending on the <literal>uppercase</literal> parameter. The remaining details of this function definition are not important here (see <xref linkend=\"extend\"/> for more information)."
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:2370(title) 
msgid "Using Positional Notation"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:2374(secondary) 
msgid "positional notation"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:2377(para) 
msgid "Positional notation is the traditional mechanism for passing arguments to functions in <productname>PostgreSQL</productname>. An example is: <screen>\nSELECT concat_lower_or_upper('Hello', 'World', true);\n concat_lower_or_upper \n-----------------------\n HELLO WORLD\n(1 row)\n</screen> All arguments are specified in order. The result is upper case since <literal>uppercase</literal> is specified as <literal>true</literal>. Another example is: <screen>\nSELECT concat_lower_or_upper('Hello', 'World');\n concat_lower_or_upper \n-----------------------\n hello world\n(1 row)\n</screen> Here, the <literal>uppercase</literal> parameter is omitted, so it receives its default value of <literal>false</literal>, resulting in lower case output. In positional notation, arguments can be omitted from right to left so long as they have defaults."
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:2405(title) 
msgid "Using Named Notation"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:2409(secondary) 
msgid "named notation"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:2412(para) 
msgid "In named notation, each argument's name is specified using <literal>:=</literal> to separate it from the argument expression. For example: <screen>\nSELECT concat_lower_or_upper(a := 'Hello', b := 'World');\n concat_lower_or_upper \n-----------------------\n hello world\n(1 row)\n</screen> Again, the argument <literal>uppercase</literal> was omitted so it is set to <literal>false</literal> implicitly. One advantage of using named notation is that the arguments may be specified in any order, for example: <screen>\nSELECT concat_lower_or_upper(a := 'Hello', b := 'World', uppercase := true);\n concat_lower_or_upper \n-----------------------\n HELLO WORLD\n(1 row)\n\nSELECT concat_lower_or_upper(a := 'Hello', uppercase := true, b := 'World');\n concat_lower_or_upper \n-----------------------\n HELLO WORLD\n(1 row)\n</screen>"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:2444(title) 
msgid "Using Mixed Notation"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:2448(secondary) 
msgid "mixed notation"
msgstr ""

#: /tmp/cicero-fBJf/syntax.xml:2451(para) 
msgid "The mixed notation combines positional and named notation. However, as already mentioned, named arguments cannot precede positional arguments. For example: <screen>\nSELECT concat_lower_or_upper('Hello', 'World', uppercase := true);\n concat_lower_or_upper \n-----------------------\n HELLO WORLD\n(1 row)\n</screen> In the above query, the arguments <literal>a</literal> and <literal>b</literal> are specified positionally, while <literal>uppercase</literal> is specified by name. In this example, that adds little except documentation. With a more complex function having numerous parameters that have default values, named or mixed notation can save a great deal of writing and reduce chances for error."
msgstr ""

#. Put one translator per line, in the form of NAME <EMAIL>, YEAR1, YEAR2.
#: /tmp/cicero-fBJf/syntax.xml:0(None) 
msgid "translator-credits"
msgstr ""

