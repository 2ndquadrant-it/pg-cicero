msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2011-08-22 17:53+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: /tmp/cicero-lkRf/plperl.xml:6(title) 
msgid "PL/Perl - Perl Procedural Language"
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:9(primary) /tmp/cicero-lkRf/plperl.xml:933(secondary) 
msgid "PL/Perl"
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:13(primary) 
msgid "Perl"
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:16(para) 
msgid "PL/Perl is a loadable procedural language that enables you to write <productname>PostgreSQL</productname> functions in the <ulink url=\"http://www.perl.org\">Perl programming language</ulink>."
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:22(para) 
msgid "The main advantage to using PL/Perl is that this allows use, within stored functions, of the manyfold <quote>string munging</quote> operators and functions available for Perl. Parsing complex strings might be easier using Perl than it is with the string functions and control structures provided in PL/pgSQL."
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:30(para) 
msgid "To install PL/Perl in a particular database, use <literal>CREATE EXTENSION plperl</literal>, or from the shell command line use <literal>createlang plperl <replaceable>dbname</replaceable></literal>."
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:37(para) 
msgid "If a language is installed into <literal>template1</literal>, all subsequently created databases will have the language installed automatically."
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:44(para) 
msgid "Users of source packages must specially enable the build of PL/Perl during the installation process. (Refer to <xref linkend=\"installation\"/> for more information.) Users of binary packages might find PL/Perl in a separate subpackage."
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:53(title) 
msgid "PL/Perl Functions and Arguments"
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:60(programlisting) 
#, no-wrap
msgid "\nCREATE FUNCTION <replaceable>funcname</replaceable> (<replaceable>argument-types</replaceable>) RETURNS <replaceable>return-type</replaceable> AS $$\n    # PL/Perl function body\n$$ LANGUAGE plperl;\n"
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:55(para) 
msgid "To create a function in the PL/Perl language, use the standard <xref linkend=\"sql-createfunction\"/> syntax: <placeholder-1/> The body of the function is ordinary Perl code. In fact, the PL/Perl glue code wraps it inside a Perl subroutine. A PL/Perl function is called in a scalar context, so it can't return a list. You can return non-scalar values (arrays, records, and sets) by returning a reference, as discussed below."
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:77(programlisting) 
#, no-wrap
msgid "\nDO $$\n    # PL/Perl code\n$$ LANGUAGE plperl;\n"
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:73(para) 
msgid "PL/Perl also supports anonymous code blocks called with the <xref linkend=\"sql-do\"/> statement: <placeholder-1/> An anonymous code block receives no arguments, and whatever value it might return is discarded. Otherwise it behaves just like a function."
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:88(para) 
msgid "The use of named nested subroutines is dangerous in Perl, especially if they refer to lexical variables in the enclosing scope. Because a PL/Perl function is wrapped in a subroutine, any named subroutine you place inside one will be nested. In general, it is far safer to create anonymous subroutines which you call via a coderef. For more information, see the entries for <literal>Variable \"%s\" will not stay shared</literal> and <literal>Variable \"%s\" is not available</literal> in the <citerefentry><refentrytitle>perldiag</refentrytitle></citerefentry> man page, or search the Internet for <quote>perl nested named subroutine</quote>."
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:101(para) 
msgid "The syntax of the <command>CREATE FUNCTION</command> command requires the function body to be written as a string constant. It is usually most convenient to use dollar quoting (see <xref linkend=\"sql-syntax-dollar-quoting\"/>) for the string constant. If you choose to use escape string syntax <literal>E''</literal>, you must double any single quote marks (<literal>'</literal>) and backslashes (<literal>\\</literal>) used in the body of the function (see <xref linkend=\"sql-syntax-strings\"/>)."
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:112(para) 
msgid "Arguments and results are handled as in any other Perl subroutine: arguments are passed in <varname>@_</varname>, and a result value is returned with <literal>return</literal> or as the last expression evaluated in the function."
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:123(programlisting) 
#, no-wrap
msgid "\nCREATE FUNCTION perl_max (integer, integer) RETURNS integer AS $$\n    if ($_[0] &gt; $_[1]) { return $_[0]; }\n    return $_[1];\n$$ LANGUAGE plperl;\n"
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:119(para) 
msgid "For example, a function returning the greater of two integer values could be defined as: <placeholder-1/>"
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:132(para) 
msgid "Arguments will be converted from the database's encoding to UTF-8 for use inside PL/Perl, and then converted from UTF-8 back to the database encoding upon return."
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:154(programlisting) 
#, no-wrap
msgid "\nCREATE FUNCTION perl_max (integer, integer) RETURNS integer AS $$\n    my ($x, $y) = @_;\n    if (not defined $x) {\n        return undef if not defined $y;\n        return $y;\n    }\n    return $x if not defined $y;\n    return $x if $x &gt; $y;\n    return $y;\n$$ LANGUAGE plperl;\n"
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:139(para) 
msgid "If an SQL null value<indexterm><primary>null value</primary><secondary sortas=\"PL/Perl\">in PL/Perl</secondary></indexterm> is passed to a function, the argument value will appear as <quote>undefined</quote> in Perl. The above function definition will not behave very nicely with null inputs (in fact, it will act as though they are zeroes). We could add <literal>STRICT</literal> to the function definition to make <productname>PostgreSQL</productname> do something more reasonable: if a null value is passed, the function will not be called at all, but will just return a null result automatically. Alternatively, we could check for undefined inputs in the function body. For example, suppose that we wanted <function>perl_max</function> with one null and one nonnull argument to return the nonnull argument, rather than a null value: <placeholder-1/> As shown above, to return an SQL null value from a PL/Perl function, return an undefined value. This can be done whether the function is strict or not."
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:171(para) 
msgid "Anything in a function argument that is not a reference is a string, which is in the standard <productname>PostgreSQL</productname> external text representation for the relevant data type. In the case of ordinary numeric or text types, Perl will just do the right thing and the programmer will normally not have to worry about it. However, in other cases the argument will need to be converted into a form that is more usable in Perl. For example, the <function>decode_bytea</function> function can be used to convert an argument of type <type>bytea</type> into unescaped binary."
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:183(para) 
msgid "Similarly, values passed back to <productname>PostgreSQL</productname> must be in the external text representation format. For example, the <function>encode_bytea</function> function can be used to escape binary data for a return value of type <type>bytea</type>."
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:194(programlisting) 
#, no-wrap
msgid "\nCREATE OR REPLACE function returns_array()\nRETURNS text[][] AS $$\n    return [['a\"b','c,d'],['e\\\\f','g']];\n$$ LANGUAGE plperl;\n\nselect returns_array();\n"
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:190(para) 
msgid "Perl can return <productname>PostgreSQL</productname> arrays as references to Perl arrays. Here is an example: <placeholder-1/>"
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:211(programlisting) 
#, no-wrap
msgid "\nCREATE OR REPLACE FUNCTION concat_array_elements(text[]) RETURNS TEXT AS $$\n    my $arg = shift;\n    my $result = \"\";\n    return undef if (!defined $arg);\n\n    # as an array reference\n    for (@$arg) {\n        $result .= $_;\n    }\n\n    # also works as a string\n    $result .= $arg;\n\n    return $result;\n$$ LANGUAGE plperl;\n\nSELECT concat_array_elements(ARRAY['PL','/','Perl']);\n"
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:232(para) 
msgid "Multi-dimensional arrays are represented as references to lower-dimensional arrays of references in a way common to every Perl programmer."
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:204(para) 
msgid "Perl passes <productname>PostgreSQL</productname> arrays as a blessed PostgreSQL::InServer::ARRAY object. This object may be treated as an array reference or a string, allowing for backward compatibility with Perl code written for <productname>PostgreSQL</productname> versions below 9.1 to run. For example: <placeholder-1/><placeholder-2/>"
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:245(programlisting) 
#, no-wrap
msgid "\nCREATE TABLE employee (\n    name text,\n    basesalary integer,\n    bonus integer\n);\n\nCREATE FUNCTION empcomp(employee) RETURNS integer AS $$\n    my ($emp) = @_;\n    return $emp-&gt;{basesalary} + $emp-&gt;{bonus};\n$$ LANGUAGE plperl;\n\nSELECT name, empcomp(employee.*) FROM employee;\n"
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:240(para) 
msgid "Composite-type arguments are passed to the function as references to hashes. The keys of the hash are the attribute names of the composite type. Here is an example: <placeholder-1/>"
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:266(programlisting) 
#, no-wrap
msgid "\nCREATE TYPE testrowperl AS (f1 integer, f2 text, f3 text);\n\nCREATE OR REPLACE FUNCTION perl_row() RETURNS testrowperl AS $$\n    return {f2 =&gt; 'hello', f1 =&gt; 1, f3 =&gt; 'world'};\n$$ LANGUAGE plperl;\n\nSELECT * FROM perl_row();\n"
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:261(para) 
msgid "A PL/Perl function can return a composite-type result using the same approach: return a reference to a hash that has the required attributes. For example: <placeholder-1/> Any columns in the declared result data type that are not present in the hash will be returned as null values."
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:290(programlisting) 
#, no-wrap
msgid "\nCREATE OR REPLACE FUNCTION perl_set_int(int)\nRETURNS SETOF INTEGER AS $$\n    foreach (0..$_[0]) {\n        return_next($_);\n    }\n    return undef;\n$$ LANGUAGE plperl;\n\nSELECT * FROM perl_set_int(5);\n\nCREATE OR REPLACE FUNCTION perl_set()\nRETURNS SETOF testrowperl AS $$\n    return_next({ f1 =&gt; 1, f2 =&gt; 'Hello', f3 =&gt; 'World' });\n    return_next({ f1 =&gt; 2, f2 =&gt; 'Hello', f3 =&gt; 'PostgreSQL' });\n    return_next({ f1 =&gt; 3, f2 =&gt; 'Hello', f3 =&gt; 'PL/Perl' });\n    return undef;\n$$ LANGUAGE plperl;\n"
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:316(programlisting) 
#, no-wrap
msgid "\nCREATE OR REPLACE FUNCTION perl_set_int(int) RETURNS SETOF INTEGER AS $$\n    return [0..$_[0]];\n$$ LANGUAGE plperl;\n\nSELECT * FROM perl_set_int(5);\n\nCREATE OR REPLACE FUNCTION perl_set() RETURNS SETOF testrowperl AS $$\n    return [\n        { f1 =&gt; 1, f2 =&gt; 'Hello', f3 =&gt; 'World' },\n        { f1 =&gt; 2, f2 =&gt; 'Hello', f3 =&gt; 'PostgreSQL' },\n        { f1 =&gt; 3, f2 =&gt; 'Hello', f3 =&gt; 'PL/Perl' }\n    ];\n$$ LANGUAGE plperl;\n\nSELECT * FROM perl_set();\n"
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:280(para) 
msgid "PL/Perl functions can also return sets of either scalar or composite types. Usually you'll want to return rows one at a time, both to speed up startup time and to keep from queueing up the entire result set in memory. You can do this with <function>return_next</function> as illustrated below. Note that after the last <function>return_next</function>, you must put either <literal>return</literal> or (better) <literal>return undef</literal>. <placeholder-1/> For small result sets, you can return a reference to an array that contains either scalars, references to arrays, or references to hashes for simple types, array types, and composite types, respectively. Here are some simple examples of returning the entire result set as an array reference: <placeholder-2/>"
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:335(para) 
msgid "If you wish to use the <literal>strict</literal> pragma with your code you have a few options. For temporary global use you can <command>SET</command><literal>plperl.use_strict</literal> to true. This will affect subsequent compilations of <application>PL/Perl</application> functions, but not functions already compiled in the current session. For permanent global use you can set <literal>plperl.use_strict</literal> to true in the <filename>postgresql.conf</filename> file."
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:347(programlisting) 
#, no-wrap
msgid "\nuse strict;\n"
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:345(para) 
msgid "For permanent use in specific functions you can simply put: <placeholder-1/> at the top of the function body."
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:353(para) 
msgid "The <literal>feature</literal> pragma is also available to <function>use</function> if your Perl is version 5.10.0 or higher."
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:360(title) 
msgid "Data Values in PL/Perl"
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:362(para) 
msgid "The argument values supplied to a PL/Perl function's code are simply the input arguments converted to text form (just as if they had been displayed by a <command>SELECT</command> statement). Conversely, the <function>return</function> and <function>return_next</function> commands will accept any string that is acceptable input format for the function's declared return type."
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:373(title) 
msgid "Built-in Functions"
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:376(title) 
msgid "Database Access from PL/Perl"
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:378(para) 
msgid "Access to the database itself from your Perl function can be done via the following functions:"
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:386(primary) /tmp/cicero-lkRf/plperl.xml:418(function) 
msgid "spi_exec_query"
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:387(secondary) /tmp/cicero-lkRf/plperl.xml:391(secondary) /tmp/cicero-lkRf/plperl.xml:395(secondary) /tmp/cicero-lkRf/plperl.xml:399(secondary) /tmp/cicero-lkRf/plperl.xml:403(secondary) /tmp/cicero-lkRf/plperl.xml:407(secondary) /tmp/cicero-lkRf/plperl.xml:411(secondary) /tmp/cicero-lkRf/plperl.xml:415(secondary) /tmp/cicero-lkRf/plperl.xml:658(secondary) /tmp/cicero-lkRf/plperl.xml:687(secondary) /tmp/cicero-lkRf/plperl.xml:704(secondary) /tmp/cicero-lkRf/plperl.xml:720(secondary) /tmp/cicero-lkRf/plperl.xml:737(secondary) /tmp/cicero-lkRf/plperl.xml:752(secondary) /tmp/cicero-lkRf/plperl.xml:766(secondary) /tmp/cicero-lkRf/plperl.xml:785(secondary) /tmp/cicero-lkRf/plperl.xml:801(secondary) /tmp/cicero-lkRf/plperl.xml:819(secondary) /tmp/cicero-lkRf/plperl.xml:836(secondary) 
msgid "in PL/Perl"
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:390(primary) 
msgid "spi_query"
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:394(primary) 
msgid "spi_fetchrow"
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:398(primary) 
msgid "spi_prepare"
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:402(primary) 
msgid "spi_exec_prepared"
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:406(primary) 
msgid "spi_query_prepared"
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:410(primary) 
msgid "spi_cursor_close"
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:414(primary) 
msgid "spi_freeplan"
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:418(replaceable) 
msgid "query"
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:418(replaceable) 
msgid "max-rows"
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:418(literal) 
msgid "<placeholder-1/>(<placeholder-2/> [, <placeholder-3/>])"
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:428(programlisting) 
#, no-wrap
msgid "\n$rv = spi_exec_query('SELECT * FROM my_table', 5);\n"
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:435(programlisting) 
#, no-wrap
msgid "\n$foo = $rv-&gt;{rows}[$i]-&gt;{my_column};\n"
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:440(programlisting) 
#, no-wrap
msgid "\n$nrows = $rv-&gt;{processed}\n"
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:420(para) 
msgid "<literal>spi_exec_query</literal> executes an SQL command and returns the entire row set as a reference to an array of hash references. <emphasis>You should only use this command when you know that the result set will be relatively small.</emphasis> Here is an example of a query (<command>SELECT</command> command) with the optional maximum number of rows: <placeholder-1/> This returns up to 5 rows from the table <literal>my_table</literal>. If <literal>my_table</literal> has a column <literal>my_column</literal>, you can get that value from row <literal>$i</literal> of the result like this: <placeholder-2/> The total number of rows returned from a <command>SELECT</command> query can be accessed like this: <placeholder-3/>"
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:447(programlisting) 
#, no-wrap
msgid "\n$query = \"INSERT INTO my_table VALUES (1, 'test')\";\n$rv = spi_exec_query($query);\n"
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:453(programlisting) 
#, no-wrap
msgid "\n$res = $rv-&gt;{status};\n"
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:457(programlisting) 
#, no-wrap
msgid "\n$nrows = $rv-&gt;{processed};\n"
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:445(para) 
msgid "Here is an example using a different command type: <placeholder-1/> You can then access the command status (e.g., <literal>SPI_OK_INSERT</literal>) like this: <placeholder-2/> To get the number of rows affected, do: <placeholder-3/>"
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:464(programlisting) 
#, no-wrap
msgid "\nCREATE TABLE test (\n    i int,\n    v varchar\n);\n\nINSERT INTO test (i, v) VALUES (1, 'first line');\nINSERT INTO test (i, v) VALUES (2, 'second line');\nINSERT INTO test (i, v) VALUES (3, 'third line');\nINSERT INTO test (i, v) VALUES (4, 'immortal');\n\nCREATE OR REPLACE FUNCTION test_munge() RETURNS SETOF test AS $$\n    my $rv = spi_exec_query('select i, v from test;');\n    my $status = $rv-&gt;{status};\n    my $nrows = $rv-&gt;{processed};\n    foreach my $rn (0 .. $nrows - 1) {\n        my $row = $rv-&gt;{rows}[$rn];\n        $row-&gt;{i} += 200 if defined($row-&gt;{i});\n        $row-&gt;{v} =~ tr/A-Za-z/a-zA-Z/ if (defined($row-&gt;{v}));\n        return_next($row);\n    }\n    return undef;\n$$ LANGUAGE plperl;\n\nSELECT * FROM test_munge();\n"
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:462(para) 
msgid "Here is a complete example: <placeholder-1/>"
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:495(replaceable) /tmp/cicero-lkRf/plperl.xml:553(replaceable) 
msgid "command"
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:495(function) 
msgid "spi_query(<placeholder-1/>)"
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:496(replaceable) /tmp/cicero-lkRf/plperl.xml:497(replaceable) 
msgid "cursor"
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:496(function) 
msgid "spi_fetchrow(<placeholder-1/>)"
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:497(function) 
msgid "spi_cursor_close(<placeholder-1/>)"
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:508(programlisting) 
#, no-wrap
msgid "\nCREATE TYPE foo_type AS (the_num INTEGER, the_text TEXT);\n\nCREATE OR REPLACE FUNCTION lotsa_md5 (INTEGER) RETURNS SETOF foo_type AS $$\n    use Digest::MD5 qw(md5_hex);\n    my $file = '/usr/share/dict/words';\n    my $t = localtime;\n    elog(NOTICE, \"opening file $file at $t\" );\n    open my $fh, '&lt;', $file # ooh, it's a file access!\n        or elog(ERROR, \"cannot open $file for reading: $!\");\n    my @words = &lt;$fh&gt;;\n    close $fh;\n    $t = localtime;\n    elog(NOTICE, \"closed file $file at $t\");\n    chomp(@words);\n    my $row;\n    my $sth = spi_query(\"SELECT * FROM generate_series(1,$_[0]) AS b(a)\");\n    while (defined ($row = spi_fetchrow($sth))) {\n        return_next({\n            the_num =&gt; $row-&gt;{a},\n            the_text =&gt; md5_hex($words[rand @words])\n        });\n    }\n    return;\n$$ LANGUAGE plperlu;\n\nSELECT * from lotsa_md5(500);\n"
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:500(para) 
msgid "<literal>spi_query</literal> and <literal>spi_fetchrow</literal> work together as a pair for row sets which might be large, or for cases where you wish to return rows as they arrive. <literal>spi_fetchrow</literal> works <emphasis>only</emphasis> with <literal>spi_query</literal>. The following example illustrates how you use them together: <placeholder-1/>"
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:538(para) 
msgid "Normally, <function>spi_fetchrow</function> should be repeated until it returns <literal>undef</literal>, indicating that there are no more rows to read. The cursor returned by <literal>spi_query</literal> is automatically freed when <function>spi_fetchrow</function> returns <literal>undef</literal>. If you do not wish to read all the rows, instead call <function>spi_cursor_close</function> to free the cursor. Failure to do so will result in memory leaks."
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:553(replaceable) 
msgid "argument types"
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:553(function) 
msgid "spi_prepare(<placeholder-1/>, <placeholder-2/>)"
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:554(replaceable) /tmp/cicero-lkRf/plperl.xml:555(replaceable) /tmp/cicero-lkRf/plperl.xml:556(replaceable) 
msgid "plan"
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:554(replaceable) /tmp/cicero-lkRf/plperl.xml:555(replaceable) 
msgid "arguments"
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:554(function) 
msgid "spi_query_prepared(<placeholder-1/>, <placeholder-2/>)"
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:555(replaceable) 
msgid "attributes"
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:555(function) 
msgid "spi_exec_prepared(<placeholder-1/> [, <placeholder-2/>], <placeholder-3/>)"
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:556(function) 
msgid "spi_freeplan(<placeholder-1/>)"
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:564(programlisting) 
#, no-wrap
msgid "\n$plan = spi_prepare('SELECT * FROM test WHERE id &gt; $1 AND name = $2',\n                                                     'INTEGER', 'TEXT');\n"
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:559(para) 
msgid "<literal>spi_prepare</literal>, <literal>spi_query_prepared</literal>, <literal>spi_exec_prepared</literal>, and <literal>spi_freeplan</literal> implement the same functionality but for prepared queries. <literal>spi_prepare</literal> accepts a query string with numbered argument placeholders ($1, $2, etc) and a string list of argument types: <placeholder-1/> Once a query plan is prepared by a call to <literal>spi_prepare</literal>, the plan can be used instead of the string query, either in <literal>spi_exec_prepared</literal>, where the result is the same as returned by <literal>spi_exec_query</literal>, or in <literal>spi_query_prepared</literal> which returns a cursor exactly as <literal>spi_query</literal> does, which can be later passed to <literal>spi_fetchrow</literal>. The optional second parameter to <literal>spi_exec_prepared</literal> is a hash reference of attributes; the only attribute currently supported is <literal>limit</literal>, which sets the maximum number of rows returned by a query."
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:580(programlisting) 
#, no-wrap
msgid "\nCREATE OR REPLACE FUNCTION init() RETURNS VOID AS $$\n        $_SHARED{my_plan} = spi_prepare('SELECT (now() + $1)::date AS now',\n                                        'INTERVAL');\n$$ LANGUAGE plperl;\n\nCREATE OR REPLACE FUNCTION add_time( INTERVAL ) RETURNS TEXT AS $$\n        return spi_exec_prepared(\n                $_SHARED{my_plan},\n                $_[0]\n        )-&gt;{rows}-&gt;[0]-&gt;{now};\n$$ LANGUAGE plperl;\n\nCREATE OR REPLACE FUNCTION done() RETURNS VOID AS $$\n        spi_freeplan( $_SHARED{my_plan});\n        undef $_SHARED{my_plan};\n$$ LANGUAGE plperl;\n\nSELECT init();\nSELECT add_time('1 day'), add_time('2 days'), add_time('3 days');\nSELECT done();\n\n  add_time  |  add_time  |  add_time\n------------+------------+------------\n 2005-12-10 | 2005-12-11 | 2005-12-12\n"
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:576(para) 
msgid "The advantage of prepared queries is that is it possible to use one prepared plan for more than one query execution. After the plan is not needed anymore, it can be freed with <literal>spi_freeplan</literal>: <placeholder-1/> Note that the parameter subscript in <literal>spi_prepare</literal> is defined via $1, $2, $3, etc, so avoid declaring query strings in double quotes that might easily lead to hard-to-catch bugs."
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:613(programlisting) 
#, no-wrap
msgid "\nCREATE TABLE hosts AS SELECT id, ('192.168.1.'||id)::inet AS address\n                      FROM generate_series(1,3) AS id;\n\nCREATE OR REPLACE FUNCTION init_hosts_query() RETURNS VOID AS $$\n        $_SHARED{plan} = spi_prepare('SELECT * FROM hosts\n                                      WHERE address &lt;&lt; $1', 'inet');\n$$ LANGUAGE plperl;\n\nCREATE OR REPLACE FUNCTION query_hosts(inet) RETURNS SETOF hosts AS $$\n        return spi_exec_prepared(\n                $_SHARED{plan},\n                {limit =&gt; 2},\n                $_[0]\n        )-&gt;{rows};\n$$ LANGUAGE plperl;\n\nCREATE OR REPLACE FUNCTION release_hosts_query() RETURNS VOID AS $$\n        spi_freeplan($_SHARED{plan});\n        undef $_SHARED{plan};\n$$ LANGUAGE plperl;\n\nSELECT init_hosts_query();\nSELECT query_hosts('192.168.1.0/30');\nSELECT release_hosts_query();\n\n    query_hosts    \n-----------------\n (1,192.168.1.1)\n (2,192.168.1.2)\n(2 rows)\n"
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:611(para) 
msgid "Another example illustrates usage of an optional parameter in <literal>spi_exec_prepared</literal>: <placeholder-1/>"
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:652(title) 
msgid "Utility Functions in PL/Perl"
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:657(primary) 
msgid "elog"
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:661(replaceable) 
msgid "level"
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:661(replaceable) 
msgid "msg"
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:661(function) 
msgid "elog(<placeholder-1/>, <placeholder-2/>)"
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:663(para) 
msgid "Emit a log or error message. Possible levels are <literal>DEBUG</literal>, <literal>LOG</literal>, <literal>INFO</literal>, <literal>NOTICE</literal>, <literal>WARNING</literal>, and <literal>ERROR</literal>. <literal>ERROR</literal> raises an error condition; if this is not trapped by the surrounding Perl code, the error propagates out to the calling query, causing the current transaction or subtransaction to be aborted. This is effectively the same as the Perl <literal>die</literal> command. The other levels only generate messages of different priority levels. Whether messages of a particular priority are reported to the client, written to the server log, or both is controlled by the <xref linkend=\"guc-log-min-messages\"/> and <xref linkend=\"guc-client-min-messages\"/> configuration variables. See <xref linkend=\"runtime-config\"/> for more information."
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:686(primary) 
msgid "quote_literal"
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:690(replaceable) /tmp/cicero-lkRf/plperl.xml:707(replaceable) /tmp/cicero-lkRf/plperl.xml:723(replaceable) /tmp/cicero-lkRf/plperl.xml:740(replaceable) /tmp/cicero-lkRf/plperl.xml:755(replaceable) /tmp/cicero-lkRf/plperl.xml:822(replaceable) 
msgid "string"
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:690(function) 
msgid "quote_literal(<placeholder-1/>)"
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:692(para) 
msgid "Return the given string suitably quoted to be used as a string literal in an SQL statement string. Embedded single-quotes and backslashes are properly doubled. Note that <function>quote_literal</function> returns undef on undef input; if the argument might be undef, <function>quote_nullable</function> is often more suitable."
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:703(primary) 
msgid "quote_nullable"
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:707(function) 
msgid "quote_nullable(<placeholder-1/>)"
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:709(para) 
msgid "Return the given string suitably quoted to be used as a string literal in an SQL statement string; or, if the argument is undef, return the unquoted string \"NULL\". Embedded single-quotes and backslashes are properly doubled."
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:719(primary) 
msgid "quote_ident"
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:723(function) 
msgid "quote_ident(<placeholder-1/>)"
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:725(para) 
msgid "Return the given string suitably quoted to be used as an identifier in an SQL statement string. Quotes are added only if necessary (i.e., if the string contains non-identifier characters or would be case-folded). Embedded quotes are properly doubled."
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:736(primary) 
msgid "decode_bytea"
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:740(function) 
msgid "decode_bytea(<placeholder-1/>)"
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:742(para) 
msgid "Return the unescaped binary data represented by the contents of the given string, which should be <type>bytea</type> encoded."
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:751(primary) 
msgid "encode_bytea"
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:755(function) 
msgid "encode_bytea(<placeholder-1/>)"
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:757(para) 
msgid "Return the <type>bytea</type> encoded form of the binary data contents of the given string."
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:765(primary) 
msgid "encode_array_literal"
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:769(replaceable) /tmp/cicero-lkRf/plperl.xml:770(replaceable) /tmp/cicero-lkRf/plperl.xml:804(replaceable) 
msgid "array"
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:769(function) 
msgid "encode_array_literal(<placeholder-1/>)"
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:770(replaceable) 
msgid "delimiter"
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:770(function) 
msgid "encode_array_literal(<placeholder-1/>, <placeholder-2/>)"
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:772(para) 
msgid "Returns the contents of the referenced array as a string in array literal format (see <xref linkend=\"arrays-input\"/>). Returns the argument value unaltered if it's not a reference to an array. The delimiter used between elements of the array literal defaults to \"<literal>, </literal>\" if a delimiter is not specified or is undef."
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:784(primary) 
msgid "encode_typed_literal"
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:788(replaceable) 
msgid "value"
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:788(replaceable) 
msgid "typename"
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:788(function) 
msgid "encode_typed_literal(<placeholder-1/>, <placeholder-2/>)"
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:790(para) 
msgid "Converts a Perl variable to the value of the data type passed as a second argument and returns a string representation of this value. Correctly handles nested arrays and values of composite types."
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:800(primary) 
msgid "encode_array_constructor"
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:804(function) 
msgid "encode_array_constructor(<placeholder-1/>)"
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:806(para) 
msgid "Returns the contents of the referenced array as a string in array constructor format (see <xref linkend=\"sql-syntax-array-constructors\"/>). Individual values are quoted using <function>quote_nullable</function>. Returns the argument value, quoted using <function>quote_nullable</function>, if it's not a reference to an array."
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:818(primary) 
msgid "looks_like_number"
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:822(function) 
msgid "looks_like_number(<placeholder-1/>)"
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:824(para) 
msgid "Returns a true value if the content of the given string looks like a number, according to Perl, returns false otherwise. Returns undef if the argument is undef. Leading and trailing space is ignored. <literal>Inf</literal> and <literal>Infinity</literal> are regarded as numbers."
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:835(primary) 
msgid "is_array_ref"
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:839(replaceable) 
msgid "argument"
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:839(function) 
msgid "is_array_ref(<placeholder-1/>)"
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:841(para) 
msgid "Returns a true value if the given argument may be treated as an array reference, that is, if ref of the argument is <literal>ARRAY</literal> or <literal>PostgreSQL::InServer::ARRAY</literal>. Returns false otherwise."
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:854(title) 
msgid "Global Values in PL/Perl"
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:856(para) 
msgid "You can use the global hash <varname>%_SHARED</varname> to store data, including code references, between function calls for the lifetime of the current session."
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:864(programlisting) 
#, no-wrap
msgid "\nCREATE OR REPLACE FUNCTION set_var(name text, val text) RETURNS text AS $$\n    if ($_SHARED{$_[0]} = $_[1]) {\n        return 'ok';\n    } else {\n        return \"cannot set shared variable $_[0] to $_[1]\";\n    }\n$$ LANGUAGE plperl;\n\nCREATE OR REPLACE FUNCTION get_var(name text) RETURNS text AS $$\n    return $_SHARED{$_[0]};\n$$ LANGUAGE plperl;\n\nSELECT set_var('sample', 'Hello, PL/Perl!  How''s tricks?');\nSELECT get_var('sample');\n"
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:862(para) 
msgid "Here is a simple example for shared data: <placeholder-1/>"
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:885(programlisting) 
#, no-wrap
msgid "\nCREATE OR REPLACE FUNCTION myfuncs() RETURNS void AS $$\n    $_SHARED{myquote} = sub {\n        my $arg = shift;\n        $arg =~ s/(['\\\\])/\\\\$1/g;\n        return \"'$arg'\";\n    };\n$$ LANGUAGE plperl;\n\nSELECT myfuncs(); /* initializes the function */\n\n/* Set up a function that uses the quote function */\n\nCREATE OR REPLACE FUNCTION use_quote(TEXT) RETURNS text AS $$\n    my $text_to_quote = shift;\n    my $qfunc = $_SHARED{myquote};\n    return &amp;$qfunc($text_to_quote);\n$$ LANGUAGE plperl;\n"
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:882(para) 
msgid "Here is a slightly more complicated example using a code reference: <placeholder-1/> (You could have replaced the above with the one-liner <literal>return $_SHARED{myquote}-&gt;($_[0]);</literal> at the expense of readability.)"
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:910(para) 
msgid "For security reasons, PL/Perl executes functions called by any one SQL role in a separate Perl interpreter for that role. This prevents accidental or malicious interference by one user with the behavior of another user's PL/Perl functions. Each such interpreter has its own value of the <varname>%_SHARED</varname> variable and other global state. Thus, two PL/Perl functions will share the same value of <varname>%_SHARED</varname> if and only if they are executed by the same SQL role. In an application wherein a single session executes code under multiple SQL roles (via <literal>SECURITY DEFINER</literal> functions, use of <command>SET ROLE</command>, etc) you may need to take explicit steps to ensure that PL/Perl functions can share data via <varname>%_SHARED</varname>. To do that, make sure that functions that should communicate are owned by the same user, and mark them <literal>SECURITY DEFINER</literal>. You must of course take care that such functions can't be used to do anything unintended."
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:929(title) 
msgid "Trusted and Untrusted PL/Perl"
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:932(primary) 
msgid "trusted"
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:936(para) 
msgid "Normally, PL/Perl is installed as a <quote>trusted</quote> programming language named <literal>plperl</literal>. In this setup, certain Perl operations are disabled to preserve security. In general, the operations that are restricted are those that interact with the environment. This includes file handle operations, <literal>require</literal>, and <literal>use</literal> (for external modules). There is no way to access internals of the database server process or to gain OS-level access with the permissions of the server process, as a C function can do. Thus, any unprivileged database user can be permitted to use this language."
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:953(programlisting) 
#, no-wrap
msgid "\nCREATE FUNCTION badfunc() RETURNS integer AS $$\n    my $tmpfile = \"/tmp/badfile\";\n    open my $fh, '&gt;', $tmpfile\n        or elog(ERROR, qq{could not open the file \"$tmpfile\": $!});\n    print $fh \"Testing writing to a file\\n\";\n    close $fh or elog(ERROR, qq{could not close the file \"$tmpfile\": $!});\n    return 1;\n$$ LANGUAGE plperl;\n"
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:950(para) 
msgid "Here is an example of a function that will not work because file system operations are not allowed for security reasons: <placeholder-1/> The creation of this function will fail as its use of a forbidden operation will be caught by the validator."
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:967(para) 
msgid "Sometimes it is desirable to write Perl functions that are not restricted. For example, one might want a Perl function that sends mail. To handle these cases, PL/Perl can also be installed as an <quote>untrusted</quote> language (usually called <application>PL/PerlU</application><indexterm><primary>PL/PerlU</primary></indexterm>). In this case the full Perl language is available. When installing the language, the language name <literal>plperlu</literal> will select the untrusted PL/Perl variant."
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:978(para) 
msgid "The writer of a <application>PL/PerlU</application> function must take care that the function cannot be used to do anything unwanted, since it will be able to do anything that could be done by a user logged in as the database administrator. Note that the database system allows only database superusers to create functions in untrusted languages."
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:986(para) 
msgid "If the above function was created by a superuser using the language <literal>plperlu</literal>, execution would succeed."
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:991(para) 
msgid "In the same way, anonymous code blocks written in Perl can use restricted operations if the language is specified as <literal>plperlu</literal> rather than <literal>plperl</literal>, but the caller must be a superuser."
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:999(para) 
msgid "While <application>PL/Perl</application> functions run in a separate Perl interpreter for each SQL role, all <application>PL/PerlU</application> functions executed in a given session run in a single Perl interpreter (which is not any of the ones used for <application>PL/Perl</application> functions). This allows <application>PL/PerlU</application> functions to share data freely, but no communication can occur between <application>PL/Perl</application> and <application>PL/PerlU</application> functions."
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:1011(para) 
msgid "Perl cannot support multiple interpreters within one process unless it was built with the appropriate flags, namely either <literal>usemultiplicity</literal> or <literal>useithreads</literal>. (<literal>usemultiplicity</literal> is preferred unless you actually need to use threads. For more details, see the <citerefentry><refentrytitle>perlembed</refentrytitle></citerefentry> man page.) If <application>PL/Perl</application> is used with a copy of Perl that was not built this way, then it is only possible to have one Perl interpreter per session, and so any one session can only execute either <application>PL/PerlU</application> functions, or <application>PL/Perl</application> functions that are all called by the same SQL role."
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:1029(title) 
msgid "PL/Perl Triggers"
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:1040(literal) 
msgid "$_TD-&gt;{new}{foo}"
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:1042(para) 
msgid "<literal>NEW</literal> value of column <literal>foo</literal>"
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:1049(literal) 
msgid "$_TD-&gt;{old}{foo}"
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:1051(para) 
msgid "<literal>OLD</literal> value of column <literal>foo</literal>"
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:1058(literal) 
msgid "$_TD-&gt;{name}"
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:1060(para) 
msgid "Name of the trigger being called"
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:1067(literal) 
msgid "$_TD-&gt;{event}"
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:1069(para) 
msgid "Trigger event: <literal>INSERT</literal>, <literal>UPDATE</literal>, <literal>DELETE</literal>, <literal>TRUNCATE</literal>, or <literal>UNKNOWN</literal>"
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:1077(literal) 
msgid "$_TD-&gt;{when}"
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:1079(para) 
msgid "When the trigger was called: <literal>BEFORE</literal>, <literal>AFTER</literal>, <literal>INSTEAD OF</literal>, or <literal>UNKNOWN</literal>"
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:1088(literal) 
msgid "$_TD-&gt;{level}"
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:1090(para) 
msgid "The trigger level: <literal>ROW</literal>, <literal>STATEMENT</literal>, or <literal>UNKNOWN</literal>"
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:1097(literal) 
msgid "$_TD-&gt;{relid}"
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:1099(para) 
msgid "OID of the table on which the trigger fired"
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:1106(literal) 
msgid "$_TD-&gt;{table_name}"
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:1108(para) 
msgid "Name of the table on which the trigger fired"
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:1115(literal) 
msgid "$_TD-&gt;{relname}"
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:1117(para) 
msgid "Name of the table on which the trigger fired. This has been deprecated, and could be removed in a future release. Please use $_TD-&gt;{table_name} instead."
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:1126(literal) 
msgid "$_TD-&gt;{table_schema}"
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:1128(para) 
msgid "Name of the schema in which the table on which the trigger fired, is"
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:1135(literal) 
msgid "$_TD-&gt;{argc}"
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:1137(para) 
msgid "Number of arguments of the trigger function"
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:1144(literal) 
msgid "@{$_TD-&gt;{args}}"
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:1146(para) 
msgid "Arguments of the trigger function. Does not exist if <literal>$_TD-&gt;{argc}</literal> is 0."
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:1031(para) 
msgid "PL/Perl can be used to write trigger functions. In a trigger function, the hash reference <varname>$_TD</varname> contains information about the current trigger event. <varname>$_TD</varname> is a global variable, which gets a separate local value for each invocation of the trigger. The fields of the <varname>$_TD</varname> hash reference are: <placeholder-1/>"
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:1160(literal) 
msgid "return;"
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:1162(para) 
msgid "Execute the operation"
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:1169(literal) 
msgid "\"SKIP\""
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:1171(para) 
msgid "Don't execute the operation"
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:1178(literal) 
msgid "\"MODIFY\""
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:1180(para) 
msgid "Indicates that the <literal>NEW</literal> row was modified by the trigger function"
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:1155(para) 
msgid "Row-level triggers can return one of the following: <placeholder-1/>"
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:1192(programlisting) 
#, no-wrap
msgid "\nCREATE TABLE test (\n    i int,\n    v varchar\n);\n\nCREATE OR REPLACE FUNCTION valid_id() RETURNS trigger AS $$\n    if (($_TD-&gt;{new}{i} &gt;= 100) || ($_TD-&gt;{new}{i} &lt;= 0)) {\n        return \"SKIP\";    # skip INSERT/UPDATE command\n    } elsif ($_TD-&gt;{new}{v} ne \"immortal\") {\n        $_TD-&gt;{new}{v} .= \"(modified by trigger)\";\n        return \"MODIFY\";  # modify row and execute INSERT/UPDATE command\n    } else {\n        return;           # execute INSERT/UPDATE command\n    }\n$$ LANGUAGE plperl;\n\nCREATE TRIGGER test_valid_id_trig\n    BEFORE INSERT OR UPDATE ON test\n    FOR EACH ROW EXECUTE PROCEDURE valid_id();\n"
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:1189(para) 
msgid "Here is an example of a trigger function, illustrating some of the above: <placeholder-1/>"
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:1217(title) 
msgid "PL/Perl Under the Hood"
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:1220(title) 
msgid "Configuration"
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:1222(para) 
msgid "This section lists configuration parameters that affect <application>PL/Perl</application>. To set any of these parameters before <application>PL/Perl</application> has been loaded, it is necessary to have added <quote><literal>plperl</literal></quote> to the <xref linkend=\"guc-custom-variable-classes\"/> list in <filename>postgresql.conf</filename>."
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:1233(term) 
msgid "<varname>plperl.on_init</varname> (<type>string</type>)"
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:1235(varname) 
msgid "plperl.on_init"
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:1235(primary) /tmp/cicero-lkRf/plperl.xml:1291(primary) /tmp/cicero-lkRf/plperl.xml:1294(primary) /tmp/cicero-lkRf/plperl.xml:1329(primary) 
msgid "<placeholder-1/> configuration parameter"
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:1238(para) 
msgid "Specifies Perl code to be executed when a Perl interpreter is first initialized, before it is specialized for use by <literal>plperl</literal> or <literal>plperlu</literal>. The SPI functions are not available when this code is executed. If the code fails with an error it will abort the initialization of the interpreter and propagate out to the calling query, causing the current transaction or subtransaction to be aborted."
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:1251(programlisting) 
#, no-wrap
msgid "\nplperl.on_init = 'require \"plperlinit.pl\"'\nplperl.on_init = 'use lib \"/my/app\"; use MyApp::PgInit;'\n"
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:1247(para) 
msgid "The Perl code is limited to a single string. Longer code can be placed into a module and loaded by the <literal>on_init</literal> string. Examples: <placeholder-1/>"
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:1260(programlisting) 
#, no-wrap
msgid "\nDO 'elog(WARNING, join \", \", sort keys %INC)' language plperl;\n"
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:1256(para) 
msgid "Any modules loaded by <literal>plperl.on_init</literal>, either directly or indirectly, will be available for use by <literal>plperl</literal>. This may create a security risk. To see what modules have been loaded you can use: <placeholder-1/>"
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:1264(para) 
msgid "Initialization will happen in the postmaster if the plperl library is included in <xref linkend=\"guc-shared-preload-libraries\"/>, in which case extra consideration should be given to the risk of destabilizing the postmaster. The principal reason for making use of this feature is that Perl modules loaded by <literal>plperl.on_init</literal> need be loaded only at postmaster start, and will be instantly available without loading overhead in individual database sessions. However, keep in mind that the overhead is avoided only for the first Perl interpreter used by a database session — either PL/PerlU, or PL/Perl for the first SQL role that calls a PL/Perl function. Any additional Perl interpreters created in a database session will have to execute <literal>plperl.on_init</literal> afresh. Also, on Windows there will be no savings whatsoever from preloading, since the Perl interpreter created in the postmaster process does not propagate to child processes."
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:1281(para) 
msgid "This parameter can only be set in the <filename>postgresql.conf</filename> file or on the server command line."
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:1288(term) 
msgid "<varname>plperl.on_plperl_init</varname> (<type>string</type>)"
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:1289(term) 
msgid "<varname>plperl.on_plperlu_init</varname> (<type>string</type>)"
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:1291(varname) 
msgid "plperl.on_plperl_init"
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:1294(varname) 
msgid "plperl.on_plperlu_init"
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:1297(para) 
msgid "These parameters specify Perl code to be executed when a Perl interpreter is specialized for <literal>plperl</literal> or <literal>plperlu</literal> respectively. This will happen when a PL/Perl or PL/PerlU function is first executed in a database session, or when an additional interpreter has to be created because the other language is called or a PL/Perl function is called by a new SQL role. This follows any initialization done by <literal>plperl.on_init</literal>. The SPI functions are not available when this code is executed. The Perl code in <literal>plperl.on_plperl_init</literal> is executed after <quote>locking down</quote> the interpreter, and thus it can only perform trusted operations."
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:1310(para) 
msgid "If the code fails with an error it will abort the initialization and propagate out to the calling query, causing the current transaction or subtransaction to be aborted. Any actions already done within Perl won't be undone; however, that interpreter won't be used again. If the language is used again the initialization will be attempted again within a fresh Perl interpreter."
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:1318(para) 
msgid "Only superusers can change these settings. Although these settings can be changed within a session, such changes will not affect Perl interpreters that have already been used to execute functions."
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:1327(term) 
msgid "<varname>plperl.use_strict</varname> (<type>boolean</type>)"
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:1329(varname) 
msgid "plperl.use_strict"
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:1332(para) 
msgid "When set true subsequent compilations of PL/Perl functions will have the <literal>strict</literal> pragma enabled. This parameter does not affect functions already compiled in the current session."
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:1344(title) 
msgid "Limitations and Missing Features"
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:1352(para) 
msgid "PL/Perl functions cannot call each other directly."
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:1358(para) 
msgid "SPI is not yet fully implemented."
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:1364(para) 
msgid "If you are fetching very large data sets using <literal>spi_exec_query</literal>, you should be aware that these will all go into memory. You can avoid this by using <literal>spi_query</literal>/<literal>spi_fetchrow</literal> as illustrated earlier."
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:1371(para) 
msgid "A similar problem occurs if a set-returning function passes a large set of rows back to PostgreSQL via <literal>return</literal>. You can avoid this problem too by instead using <literal>return_next</literal> for each row returned, as shown previously."
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:1381(para) 
msgid "When a session ends normally, not due to a fatal error, any <literal>END</literal> blocks that have been defined are executed. Currently no other actions are performed. Specifically, file handles are not automatically flushed and objects are not automatically destroyed."
msgstr ""

#: /tmp/cicero-lkRf/plperl.xml:1346(para) 
msgid "The following features are currently missing from PL/Perl, but they would make welcome contributions. <placeholder-1/>"
msgstr ""

#. Put one translator per line, in the form of NAME <EMAIL>, YEAR1, YEAR2.
#: /tmp/cicero-lkRf/plperl.xml:0(None) 
msgid "translator-credits"
msgstr ""

