msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2011-05-26 12:15+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/extend.xml:5(title)
msgid "Extending <acronym>SQL</acronym>"
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/extend.xml:8(primary)
msgid "extending SQL"
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/extend.xml:18(para)
msgid "functions (starting in <xref linkend=\"xfunc\"/>)"
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/extend.xml:23(para)
msgid "aggregates (starting in <xref linkend=\"xaggr\"/>)"
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/extend.xml:28(para)
msgid "data types (starting in <xref linkend=\"xtypes\"/>)"
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/extend.xml:33(para)
msgid "operators (starting in <xref linkend=\"xoper\"/>)"
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/extend.xml:38(para)
msgid "operator classes for indexes (starting in <xref linkend=\"xindex\"/>)"
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/extend.xml:11(para)
msgid "In the sections that follow, we will discuss how you can extend the <productname>PostgreSQL</productname><acronym>SQL</acronym> query language by adding: <placeholder-1/>"
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/extend.xml:46(title)
msgid "How Extensibility Works"
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/extend.xml:48(para)
msgid "<productname>PostgreSQL</productname> is extensible because its operation is catalog-driven. If you are familiar with standard relational database systems, you know that they store information about databases, tables, columns, etc., in what are commonly known as system catalogs. (Some systems call this the data dictionary.) The catalogs appear to the user as tables like any other, but the <acronym>DBMS</acronym> stores its internal bookkeeping in them. One key difference between <productname>PostgreSQL</productname> and standard relational database systems is that <productname>PostgreSQL</productname> stores much more information in its catalogs: not only information about tables and columns, but also information about data types, functions, access methods, and so on. These tables can be modified by the user, and since <productname>PostgreSQL</productname> bases its operation on these tables, this means that <productname>PostgreSQL</productname> can be extended by users. By comparison, conventional database systems can only be extended by changing hardcoded procedures in the source code or by loading modules specially written by the <acronym>DBMS</acronym> vendor."
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/extend.xml:70(para)
msgid "The <productname>PostgreSQL</productname> server can moreover incorporate user-written code into itself through dynamic loading. That is, the user can specify an object code file (e.g., a shared library) that implements a new type or function, and <productname>PostgreSQL</productname> will load it as required. Code written in <acronym>SQL</acronym> is even more trivial to add to the server. This ability to modify its operation <quote>on the fly</quote> makes <productname>PostgreSQL</productname> uniquely suited for rapid prototyping of new applications and storage structures."
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/extend.xml:85(title)
msgid "The <productname>PostgreSQL</productname> Type System"
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/extend.xml:88(primary)
msgid "base type"
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/extend.xml:92(primary) /home/carloratm/progetti/postgresql-source/doc-9.0.4/extend.xml:101(primary)
msgid "data type"
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/extend.xml:93(secondary)
msgid "base"
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/extend.xml:97(primary)
msgid "composite type"
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/extend.xml:102(secondary)
msgid "composite"
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/extend.xml:105(para)
msgid "<productname>PostgreSQL</productname> data types are divided into base types, composite types, domains, and pseudo-types."
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/extend.xml:111(title)
msgid "Base Types"
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/extend.xml:113(para)
msgid "Base types are those, like <type>int4</type>, that are implemented below the level of the <acronym>SQL</acronym> language (typically in a low-level language such as C). They generally correspond to what are often known as abstract data types. <productname>PostgreSQL</productname> can only operate on such types through functions provided by the user and only understands the behavior of such types to the extent that the user describes them. Base types are further subdivided into scalar and array types. For each scalar type, a corresponding array type is automatically created that can hold variable-size arrays of that scalar type."
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/extend.xml:129(title)
msgid "Composite Types"
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/extend.xml:131(para)
msgid "Composite types, or row types, are created whenever the user creates a table. It is also possible to use <xref linkend=\"sql-createtype\"/> to define a <quote>stand-alone</quote> composite type with no associated table. A composite type is simply a list of types with associated field names. A value of a composite type is a row or record of field values. The user can access the component fields from <acronym>SQL</acronym> queries. Refer to <xref linkend=\"rowtypes\"/> for more information on composite types."
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/extend.xml:145(title)
msgid "Domains"
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/extend.xml:147(para)
msgid "A domain is based on a particular base type and for many purposes is interchangeable with its base type. However, a domain can have constraints that restrict its valid values to a subset of what the underlying base type would allow."
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/extend.xml:154(para)
msgid "Domains can be created using the <acronym>SQL</acronym> command <xref linkend=\"sql-createdomain\"/>. Their creation and use is not discussed in this chapter."
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/extend.xml:162(title)
msgid "Pseudo-Types"
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/extend.xml:164(para)
msgid "There are a few <quote>pseudo-types</quote> for special purposes. Pseudo-types cannot appear as columns of tables or attributes of composite types, but they can be used to declare the argument and result types of functions. This provides a mechanism within the type system to identify special classes of functions. <xref linkend=\"datatype-pseudotypes-table\"/> lists the existing pseudo-types."
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/extend.xml:176(title)
msgid "Polymorphic Types"
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/extend.xml:179(primary)
msgid "polymorphic type"
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/extend.xml:183(primary)
msgid "polymorphic function"
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/extend.xml:187(primary)
msgid "type"
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/extend.xml:188(secondary) /home/carloratm/progetti/postgresql-source/doc-9.0.4/extend.xml:193(secondary)
msgid "polymorphic"
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/extend.xml:192(primary)
msgid "function"
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/extend.xml:196(para)
msgid "Four pseudo-types of special interest are <type>anyelement</type>, <type>anyarray</type>, <type>anynonarray</type>, and <type>anyenum</type>, which are collectively called <firstterm>polymorphic types</firstterm>. Any function declared using these types is said to be a <firstterm>polymorphic function</firstterm>. A polymorphic function can operate on many different data types, with the specific data type(s) being determined by the data types actually passed to it in a particular call."
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/extend.xml:207(para)
msgid "Polymorphic arguments and results are tied to each other and are resolved to a specific data type when a query calling a polymorphic function is parsed. Each position (either argument or return value) declared as <type>anyelement</type> is allowed to have any specific actual data type, but in any given call they must all be the <emphasis>same</emphasis> actual type. Each position declared as <type>anyarray</type> can have any array data type, but similarly they must all be the same type. If there are positions declared <type>anyarray</type> and others declared <type>anyelement</type>, the actual array type in the <type>anyarray</type> positions must be an array whose elements are the same type appearing in the <type>anyelement</type> positions. <type>anynonarray</type> is treated exactly the same as <type>anyelement</type>, but adds the additional constraint that the actual type must not be an array type. <type>anyenum</type> is treated exactly the same as <type>anyelement</type>, but adds the additional constraint that the actual type must be an enum type."
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/extend.xml:228(para)
msgid "Thus, when more than one argument position is declared with a polymorphic type, the net effect is that only certain combinations of actual argument types are allowed. For example, a function declared as <literal>equal(anyelement, anyelement)</literal> will take any two input values, so long as they are of the same data type."
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/extend.xml:236(para)
msgid "When the return value of a function is declared as a polymorphic type, there must be at least one argument position that is also polymorphic, and the actual data type supplied as the argument determines the actual result type for that call. For example, if there were not already an array subscripting mechanism, one could define a function that implements subscripting as <literal>subscript(anyarray, integer) returns anyelement</literal>. This declaration constrains the actual first argument to be an array type, and allows the parser to infer the correct result type from the actual first argument's type. Another example is that a function declared as <literal>f(anyarray) returns anyenum</literal> will only accept arrays of enum types."
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/extend.xml:250(para)
msgid "Note that <type>anynonarray</type> and <type>anyenum</type> do not represent separate type variables; they are the same type as <type>anyelement</type>, just with an additional constraint. For example, declaring a function as <literal>f(anyelement, anyenum)</literal> is equivalent to declaring it as <literal>f(anyenum, anyenum)</literal>: both actual arguments have to be the same enum type."
msgstr ""

#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/extend.xml:259(para)
msgid "A variadic function (one taking a variable number of arguments, as in <xref linkend=\"xfunc-sql-variadic-functions\"/>) can be polymorphic: this is accomplished by declaring its last parameter as <literal>VARIADIC</literal><type>anyarray</type>. For purposes of argument matching and determining the actual result type, such a function behaves the same as if you had written the appropriate number of <type>anynonarray</type> parameters."
msgstr ""

#. $PostgreSQL: pgsql/doc/src/sgml/extend.sgml,v 1.44 2010/06/03 14:41:25 momjian Exp $
#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/extend.xml:4(chapter)
msgid "<placeholder-1/><indexterm zone=\"extend\"><placeholder-2/></indexterm><placeholder-3/><placeholder-4/><sect1 id=\"extend-type-system\"><placeholder-5/><indexterm zone=\"extend-type-system\"><placeholder-6/></indexterm><indexterm zone=\"extend-type-system\"><placeholder-7/><placeholder-8/></indexterm><indexterm zone=\"extend-type-system\"><placeholder-9/></indexterm><indexterm zone=\"extend-type-system\"><placeholder-10/><placeholder-11/></indexterm><placeholder-12/><placeholder-13/><placeholder-14/><placeholder-15/><placeholder-16/><sect2 id=\"extend-types-polymorphic\"><placeholder-17/><indexterm zone=\"extend-types-polymorphic\"><placeholder-18/></indexterm><indexterm zone=\"extend-types-polymorphic\"><placeholder-19/></indexterm><indexterm zone=\"extend-types-polymorphic\"><placeholder-20/><placeholder-21/></indexterm><indexterm zone=\"extend-types-polymorphic\"><placeholder-22/><placeholder-23/></indexterm><placeholder-24/><placeholder-25/><placeholder-26/><placeholder-27/><placeholder-28/><placeholder-29/></sect2></sect1> Using C++ for Extensibility C++ It is possible to use a compiler in C++ mode to build PostgreSQL extensions by following these guidelines: All functions accessed by the backend must present a C interface to the backend; these C functions can then call C++ functions. For example, extern C linkage is required for backend-accessed functions. This is also necessary for any functions that are passed as pointers between the backend and C++ code. Free memory using the appropriate deallocation method. For example, most backend memory is allocated using palloc(), so use pfree() to free it, i.e. using C++ delete() in such cases will fail. Prevent exceptions from propagating into the C code (use a catch-all block at the top level of all extern C functions). This is necessary even if the C++ code does not throw any exceptions because events like out-of-memory still throw exceptions. Any exceptions must be caught and appropriate errors passed back to the C interface. If possible, compile C++ with -fno-exceptions to eliminate exceptions entirely; in such cases, you must check for failures in your C++ code, e.g. check for NULL returned by new(). If calling backend functions from C++ code, be sure that the C++ call stack contains only plain old data structures (POD). This is necessary because backend errors generate a distant longjmp() that does not properly unroll a C++ call stack with non-POD objects. In summary, it is best to place C++ code behind a wall of extern C functions that interface to the backend, and avoid exception, memory, and call stack leakage."
msgstr ""

#. Put one translator per line, in the form of NAME <EMAIL>, YEAR1, YEAR2
#: /home/carloratm/progetti/postgresql-source/doc-9.0.4/extend.xml:0(None)
msgid "translator-credits"
msgstr ""

