msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2011-08-23 09:45+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: /tmp/cicero-UbWe/query.xml:6(title) 
msgid "The <acronym>SQL</acronym> Language"
msgstr ""

#: /tmp/cicero-UbWe/query.xml:9(title) 
msgid "Introduction"
msgstr ""

#: /tmp/cicero-UbWe/query.xml:11(para) 
msgid "This chapter provides an overview of how to use <acronym>SQL</acronym> to perform simple operations. This tutorial is only intended to give you an introduction and is in no way a complete tutorial on <acronym>SQL</acronym>. Numerous books have been written on <acronym>SQL</acronym>, including <xref linkend=\"melt93\"/> and <xref linkend=\"date97\"/>. You should be aware that some <productname>PostgreSQL</productname> language features are extensions to the standard."
msgstr ""

#: /tmp/cicero-UbWe/query.xml:22(para) 
msgid "In the examples that follow, we assume that you have created a database named <literal>mydb</literal>, as described in the previous chapter, and have been able to start <application>psql</application>."
msgstr ""

#: /tmp/cicero-UbWe/query.xml:28(para) 
msgid "Examples in this manual can also be found in the <productname>PostgreSQL</productname> source distribution in the directory <filename>src/tutorial/</filename>. (Binary distributions of <productname>PostgreSQL</productname> might not compile these files.) To use those files, first change to that directory and run <application>make</application>: <screen>\n<prompt>$</prompt> <userinput>cd <replaceable>....</replaceable>/src/tutorial</userinput>\n<prompt>$</prompt> <userinput>make</userinput>\n</screen> This creates the scripts and compiles the C files containing user-defined functions and types. Then, to start the tutorial, do the following: <screen>\n<prompt>$</prompt> <userinput>cd <replaceable>....</replaceable>/tutorial</userinput>\n<prompt>$</prompt> <userinput>psql -s mydb</userinput>\n<computeroutput>\n...\n</computeroutput>\n\n<prompt>mydb=&gt;</prompt> <userinput>\\i basics.sql</userinput>\n</screen> The <literal>\\i</literal> command reads in commands from the specified file. <command>psql</command>'s <literal>-s</literal> option puts you in single step mode which pauses before sending each statement to the server. The commands used in this section are in the file <filename>basics.sql</filename>."
msgstr ""

#: /tmp/cicero-UbWe/query.xml:64(title) 
msgid "Concepts"
msgstr ""

#: /tmp/cicero-UbWe/query.xml:66(para) 
msgid "<indexterm><primary>relational database</primary></indexterm><indexterm><primary>hierarchical database</primary></indexterm><indexterm><primary>object-oriented database</primary></indexterm><indexterm><primary>relation</primary></indexterm><indexterm><primary>table</primary></indexterm><productname>PostgreSQL</productname> is a <firstterm>relational database management system</firstterm> (<acronym>RDBMS</acronym>). That means it is a system for managing data stored in <firstterm>relations</firstterm>. Relation is essentially a mathematical term for <firstterm>table</firstterm>. The notion of storing data in tables is so commonplace today that it might seem inherently obvious, but there are a number of other ways of organizing databases. Files and directories on Unix-like operating systems form an example of a hierarchical database. A more modern development is the object-oriented database."
msgstr ""

#: /tmp/cicero-UbWe/query.xml:85(para) 
msgid "<indexterm><primary>row</primary></indexterm><indexterm><primary>column</primary></indexterm> Each table is a named collection of <firstterm>rows</firstterm>. Each row of a given table has the same set of named <firstterm>columns</firstterm>, and each column is of a specific data type. Whereas columns have a fixed order in each row, it is important to remember that SQL does not guarantee the order of the rows within the table in any way (although they can be explicitly sorted for display)."
msgstr ""

#: /tmp/cicero-UbWe/query.xml:98(para) 
msgid "<indexterm><primary>database cluster</primary></indexterm><indexterm><primary>cluster</primary><secondary>of databases</secondary><see>database cluster</see></indexterm> Tables are grouped into databases, and a collection of databases managed by a single <productname>PostgreSQL</productname> server instance constitutes a database <firstterm>cluster</firstterm>."
msgstr ""

#: /tmp/cicero-UbWe/query.xml:110(title) 
msgid "Creating a New Table"
msgstr ""

#: /tmp/cicero-UbWe/query.xml:113(primary) 
msgid "CREATE TABLE"
msgstr ""

#: /tmp/cicero-UbWe/query.xml:120(programlisting) 
#, no-wrap
msgid "\nCREATE TABLE weather (\n    city            varchar(80),\n    temp_lo         int,           -- low temperature\n    temp_hi         int,           -- high temperature\n    prcp            real,          -- precipitation\n    date            date\n);\n"
msgstr ""

#: /tmp/cicero-UbWe/query.xml:116(para) 
msgid "You can create a new table by specifying the table name, along with all column names and their types: <placeholder-1/> You can enter this into <command>psql</command> with the line breaks. <command>psql</command> will recognize that the command is not terminated until the semicolon."
msgstr ""

#: /tmp/cicero-UbWe/query.xml:135(para) 
msgid "White space (i.e., spaces, tabs, and newlines) can be used freely in SQL commands. That means you can type the command aligned differently than above, or even all on one line. Two dashes (<quote><literal>--</literal></quote>) introduce comments. Whatever follows them is ignored up to the end of the line. SQL is case insensitive about key words and identifiers, except when identifiers are double-quoted to preserve the case (not done above)."
msgstr ""

#: /tmp/cicero-UbWe/query.xml:146(para) 
msgid "<type>varchar(80)</type> specifies a data type that can store arbitrary character strings up to 80 characters in length. <type>int</type> is the normal integer type. <type>real</type> is a type for storing single precision floating-point numbers. <type>date</type> should be self-explanatory. (Yes, the column of type <type>date</type> is also named <structfield>date</structfield>. This might be convenient or confusing â€” you choose.)"
msgstr ""

#: /tmp/cicero-UbWe/query.xml:156(para) 
msgid "<productname>PostgreSQL</productname> supports the standard <acronym>SQL</acronym> types <type>int</type>, <type>smallint</type>, <type>real</type>, <type>double precision</type>, <type>char(<replaceable>N</replaceable>)</type>, <type>varchar(<replaceable>N</replaceable>)</type>, <type>date</type>, <type>time</type>, <type>timestamp</type>, and <type>interval</type>, as well as other types of general utility and a rich set of geometric types. <productname>PostgreSQL</productname> can be customized with an arbitrary number of user-defined data types. Consequently, type names are not key words in the syntax, except where required to support special cases in the <acronym>SQL</acronym> standard."
msgstr ""

#: /tmp/cicero-UbWe/query.xml:174(programlisting) 
#, no-wrap
msgid "\nCREATE TABLE cities (\n    name            varchar(80),\n    location        point\n);\n"
msgstr ""

#: /tmp/cicero-UbWe/query.xml:171(para) 
msgid "The second example will store cities and their associated geographical location: <placeholder-1/> The <type>point</type> type is an example of a <productname>PostgreSQL</productname>-specific data type."
msgstr ""

#: /tmp/cicero-UbWe/query.xml:184(para) 
msgid "<indexterm><primary>DROP TABLE</primary></indexterm> Finally, it should be mentioned that if you don't need a table any longer or want to recreate it differently you can remove it using the following command: <synopsis>\nDROP TABLE <replaceable>tablename</replaceable>;\n</synopsis>"
msgstr ""

#: /tmp/cicero-UbWe/query.xml:200(title) 
msgid "Populating a Table With Rows"
msgstr ""

#: /tmp/cicero-UbWe/query.xml:203(primary) 
msgid "INSERT"
msgstr ""

#: /tmp/cicero-UbWe/query.xml:210(programlisting) 
#, no-wrap
msgid "\nINSERT INTO weather VALUES ('San Francisco', 46, 50, 0.25, '1994-11-27');\n"
msgstr ""

#: /tmp/cicero-UbWe/query.xml:206(para) 
msgid "The <command>INSERT</command> statement is used to populate a table with rows: <placeholder-1/> Note that all data types use rather obvious input formats. Constants that are not simple numeric values usually must be surrounded by single quotes (<literal>'</literal>), as in the example. The <type>date</type> type is actually quite flexible in what it accepts, but for this tutorial we will stick to the unambiguous format shown here."
msgstr ""

#: /tmp/cicero-UbWe/query.xml:226(programlisting) 
#, no-wrap
msgid "\nINSERT INTO cities VALUES ('San Francisco', '(-194.0, 53.0)');\n"
msgstr ""

#: /tmp/cicero-UbWe/query.xml:223(para) 
msgid "The <type>point</type> type requires a coordinate pair as input, as shown here: <placeholder-1/>"
msgstr ""

#: /tmp/cicero-UbWe/query.xml:235(programlisting) 
#, no-wrap
msgid "\nINSERT INTO weather (city, temp_lo, temp_hi, prcp, date)\n    VALUES ('San Francisco', 43, 57, 0.0, '1994-11-29');\n"
msgstr ""

#: /tmp/cicero-UbWe/query.xml:241(programlisting) 
#, no-wrap
msgid "\nINSERT INTO weather (date, city, temp_hi, temp_lo)\n    VALUES ('1994-11-29', 'Hayward', 54, 37);\n"
msgstr ""

#: /tmp/cicero-UbWe/query.xml:231(para) 
msgid "The syntax used so far requires you to remember the order of the columns. An alternative syntax allows you to list the columns explicitly: <placeholder-1/> You can list the columns in a different order if you wish or even omit some columns, e.g., if the precipitation is unknown: <placeholder-2/> Many developers consider explicitly listing the columns better style than relying on the order implicitly."
msgstr ""

#: /tmp/cicero-UbWe/query.xml:249(para) 
msgid "Please enter all the commands shown above so you have some data to work with in the following sections."
msgstr ""

#: /tmp/cicero-UbWe/query.xml:265(programlisting) 
#, no-wrap
msgid "\nCOPY weather FROM '/home/user/weather.txt';\n"
msgstr ""

#: /tmp/cicero-UbWe/query.xml:254(para) 
msgid "<indexterm><primary>COPY</primary></indexterm> You could also have used <command>COPY</command> to load large amounts of data from flat-text files. This is usually faster because the <command>COPY</command> command is optimized for this application while allowing less flexibility than <command>INSERT</command>. An example would be: <placeholder-1/> where the file name for the source file must be available on the machine running the backend process, not the client, since the backend process reads the file directly. You can read more about the <command>COPY</command> command in <xref linkend=\"sql-copy\"/>."
msgstr ""

#: /tmp/cicero-UbWe/query.xml:278(title) 
msgid "Querying a Table"
msgstr ""

#: /tmp/cicero-UbWe/query.xml:293(programlisting) /tmp/cicero-UbWe/query.xml:856(programlisting) 
#, no-wrap
msgid "\nSELECT * FROM weather;\n"
msgstr ""

#: /tmp/cicero-UbWe/query.xml:298(para) 
msgid "While <literal>SELECT *</literal> is useful for off-the-cuff queries, it is widely considered bad style in production code, since adding a column to the table would change the results."
msgstr ""

#: /tmp/cicero-UbWe/query.xml:305(programlisting) 
#, no-wrap
msgid "\nSELECT city, temp_lo, temp_hi, prcp, date FROM weather;\n"
msgstr ""

#: /tmp/cicero-UbWe/query.xml:280(para) 
msgid "<indexterm><primary>query</primary></indexterm><indexterm><primary>SELECT</primary></indexterm> To retrieve data from a table, the table is <firstterm>queried</firstterm>. An <acronym>SQL</acronym><command>SELECT</command> statement is used to do this. The statement is divided into a select list (the part that lists the columns to be returned), a table list (the part that lists the tables from which to retrieve the data), and an optional qualification (the part that specifies any restrictions). For example, to retrieve all the rows of table <structname>weather</structname>, type: <placeholder-1/> Here <literal>*</literal> is a shorthand for <quote>all columns</quote>. <placeholder-2/> So the same result would be had with: <placeholder-3/> The output should be: <screen>\n     city      | temp_lo | temp_hi | prcp |    date\n---------------+---------+---------+------+------------\n San Francisco |      46 |      50 | 0.25 | 1994-11-27\n San Francisco |      43 |      57 |    0 | 1994-11-29\n Hayward       |      37 |      54 |      | 1994-11-29\n(3 rows)\n</screen>"
msgstr ""

#: /tmp/cicero-UbWe/query.xml:324(programlisting) 
#, no-wrap
msgid "\nSELECT city, (temp_hi+temp_lo)/2 AS temp_avg, date FROM weather;\n"
msgstr ""

#: /tmp/cicero-UbWe/query.xml:321(para) 
msgid "You can write expressions, not just simple column references, in the select list. For example, you can do: <placeholder-1/> This should give: <screen>\n     city      | temp_avg |    date\n---------------+----------+------------\n San Francisco |       48 | 1994-11-27\n San Francisco |       50 | 1994-11-29\n Hayward       |       45 | 1994-11-29\n(3 rows)\n</screen> Notice how the <literal>AS</literal> clause is used to relabel the output column. (The <literal>AS</literal> clause is optional.)"
msgstr ""

#: /tmp/cicero-UbWe/query.xml:350(programlisting) 
#, no-wrap
msgid "\nSELECT * FROM weather\n    WHERE city = 'San Francisco' AND prcp &gt; 0.0;\n"
msgstr ""

#: /tmp/cicero-UbWe/query.xml:340(para) 
msgid "A query can be <quote>qualified</quote> by adding a <literal>WHERE</literal> clause that specifies which rows are wanted. The <literal>WHERE</literal> clause contains a Boolean (truth value) expression, and only rows for which the Boolean expression is true are returned. The usual Boolean operators (<literal>AND</literal>, <literal>OR</literal>, and <literal>NOT</literal>) are allowed in the qualification. For example, the following retrieves the weather of San Francisco on rainy days: <placeholder-1/> Result: <screen>\n     city      | temp_lo | temp_hi | prcp |    date\n---------------+---------+---------+------+------------\n San Francisco |      46 |      50 | 0.25 | 1994-11-27\n(1 row)\n</screen>"
msgstr ""

#: /tmp/cicero-UbWe/query.xml:369(programlisting) 
#, no-wrap
msgid "\nSELECT * FROM weather\n    ORDER BY city;\n"
msgstr ""

#: /tmp/cicero-UbWe/query.xml:386(programlisting) 
#, no-wrap
msgid "\nSELECT * FROM weather\n    ORDER BY city, temp_lo;\n"
msgstr ""

#: /tmp/cicero-UbWe/query.xml:363(para) 
msgid "<indexterm><primary>ORDER BY</primary></indexterm> You can request that the results of a query be returned in sorted order: <placeholder-1/><screen>\n     city      | temp_lo | temp_hi | prcp |    date\n---------------+---------+---------+------+------------\n Hayward       |      37 |      54 |      | 1994-11-29\n San Francisco |      43 |      57 |    0 | 1994-11-29\n San Francisco |      46 |      50 | 0.25 | 1994-11-27\n</screen> In this example, the sort order isn't fully specified, and so you might get the San Francisco rows in either order. But you'd always get the results shown above if you do: <placeholder-2/>"
msgstr ""

#: /tmp/cicero-UbWe/query.xml:399(programlisting) 
#, no-wrap
msgid "\nSELECT DISTINCT city\n    FROM weather;\n"
msgstr ""

#: /tmp/cicero-UbWe/query.xml:416(para) 
msgid "In some database systems, including older versions of <productname>PostgreSQL</productname>, the implementation of <literal>DISTINCT</literal> automatically orders the rows and so <literal>ORDER BY</literal> is unnecessary. But this is not required by the SQL standard, and current <productname>PostgreSQL</productname> does not guarantee that <literal>DISTINCT</literal> causes the rows to be ordered."
msgstr ""

#: /tmp/cicero-UbWe/query.xml:427(programlisting) 
#, no-wrap
msgid "\nSELECT DISTINCT city\n    FROM weather\n    ORDER BY city;\n"
msgstr ""

#: /tmp/cicero-UbWe/query.xml:392(para) 
msgid "<indexterm><primary>DISTINCT</primary></indexterm><indexterm><primary>duplicate</primary></indexterm> You can request that duplicate rows be removed from the result of a query: <placeholder-1/><screen>\n     city\n---------------\n Hayward\n San Francisco\n(2 rows)\n</screen> Here again, the result row ordering might vary. You can ensure consistent results by using <literal>DISTINCT</literal> and <literal>ORDER BY</literal> together: <placeholder-2/><placeholder-3/>"
msgstr ""

#: /tmp/cicero-UbWe/query.xml:437(title) 
msgid "Joins Between Tables"
msgstr ""

#: /tmp/cicero-UbWe/query.xml:440(primary) 
msgid "join"
msgstr ""

#: /tmp/cicero-UbWe/query.xml:456(para) 
msgid "This is only a conceptual model. The join is usually performed in a more efficient manner than actually comparing each possible pair of rows, but this is invisible to the user."
msgstr ""

#: /tmp/cicero-UbWe/query.xml:464(programlisting) 
#, no-wrap
msgid "\nSELECT *\n    FROM weather, cities\n    WHERE city = name;\n"
msgstr ""

#: /tmp/cicero-UbWe/query.xml:443(para) 
msgid "Thus far, our queries have only accessed one table at a time. Queries can access multiple tables at once, or access the same table in such a way that multiple rows of the table are being processed at the same time. A query that accesses multiple rows of the same or different tables at one time is called a <firstterm>join</firstterm> query. As an example, say you wish to list all the weather records together with the location of the associated city. To do that, we need to compare the <structfield>city</structfield> column of each row of the <structname>weather</structname> table with the <structfield>name</structfield> column of all rows in the <structname>cities</structname> table, and select the pairs of rows where these values match. <placeholder-1/> This would be accomplished by the following query: <placeholder-2/><screen>\n     city      | temp_lo | temp_hi | prcp |    date    |     name      | location\n---------------+---------+---------+------+------------+---------------+-----------\n San Francisco |      46 |      50 | 0.25 | 1994-11-27 | San Francisco | (-194,53)\n San Francisco |      43 |      57 |    0 | 1994-11-29 | San Francisco | (-194,53)\n(2 rows)\n</screen>"
msgstr ""

#: /tmp/cicero-UbWe/query.xml:484(para) 
msgid "There is no result row for the city of Hayward. This is because there is no matching entry in the <structname>cities</structname> table for Hayward, so the join ignores the unmatched rows in the <structname>weather</structname> table. We will see shortly how this can be fixed."
msgstr ""

#: /tmp/cicero-UbWe/query.xml:502(programlisting) 
#, no-wrap
msgid "\nSELECT city, temp_lo, temp_hi, prcp, date, location\n    FROM weather, cities\n    WHERE city = name;\n"
msgstr ""

#: /tmp/cicero-UbWe/query.xml:494(para) 
msgid "There are two columns containing the city name. This is correct because the lists of columns from the <structname>weather</structname> and <structname>cities</structname> tables are concatenated. In practice this is undesirable, though, so you will probably want to list the output columns explicitly rather than using <literal>*</literal>: <placeholder-1/>"
msgstr ""

#: /tmp/cicero-UbWe/query.xml:480(para) 
msgid "Observe two things about the result set: <placeholder-1/>"
msgstr ""

#: /tmp/cicero-UbWe/query.xml:513(title) /tmp/cicero-UbWe/query.xml:588(title) 
msgid "Exercise:"
msgstr ""

#: /tmp/cicero-UbWe/query.xml:515(para) 
msgid "Attempt to determine the semantics of this query when the <literal>WHERE</literal> clause is omitted."
msgstr ""

#: /tmp/cicero-UbWe/query.xml:528(programlisting) 
#, no-wrap
msgid "\nSELECT weather.city, weather.temp_lo, weather.temp_hi,\n       weather.prcp, weather.date, cities.location\n    FROM weather, cities\n    WHERE cities.name = weather.city;\n"
msgstr ""

#: /tmp/cicero-UbWe/query.xml:521(para) 
msgid "Since the columns all had different names, the parser automatically found which table they belong to. If there were duplicate column names in the two tables you'd need to <firstterm>qualify</firstterm> the column names to show which one you meant, as in: <placeholder-1/> It is widely considered good style to qualify all column names in a join query, so that the query won't fail if a duplicate column name is later added to one of the tables."
msgstr ""

#: /tmp/cicero-UbWe/query.xml:544(programlisting) 
#, no-wrap
msgid "\nSELECT *\n    FROM weather INNER JOIN cities ON (weather.city = cities.name);\n"
msgstr ""

#: /tmp/cicero-UbWe/query.xml:540(para) 
msgid "Join queries of the kind seen thus far can also be written in this alternative form: <placeholder-1/> This syntax is not as commonly used as the one above, but we show it here to help you understand the following topics."
msgstr ""

#: /tmp/cicero-UbWe/query.xml:566(programlisting) 
#, no-wrap
msgid "\nSELECT *\n    FROM weather LEFT OUTER JOIN cities ON (weather.city = cities.name);\n\n     city      | temp_lo | temp_hi | prcp |    date    |     name      | location\n---------------+---------+---------+------+------------+---------------+-----------\n Hayward       |      37 |      54 |      | 1994-11-29 |               |\n San Francisco |      46 |      50 | 0.25 | 1994-11-27 | San Francisco | (-194,53)\n San Francisco |      43 |      57 |    0 | 1994-11-29 | San Francisco | (-194,53)\n(3 rows)\n"
msgstr ""

#: /tmp/cicero-UbWe/query.xml:553(para) 
msgid "<indexterm><primary>join</primary><secondary>outer</secondary></indexterm> Now we will figure out how we can get the Hayward records back in. What we want the query to do is to scan the <structname>weather</structname> table and for each row to find the matching <structname>cities</structname> row(s). If no matching row is found we want some <quote>empty values</quote> to be substituted for the <structname>cities</structname> table's columns. This kind of query is called an <firstterm>outer join</firstterm>. (The joins we have seen so far are inner joins.) The command looks like this: <placeholder-1/> This query is called a <firstterm>left outer join</firstterm> because the table mentioned on the left of the join operator will have each of its rows in the output at least once, whereas the table on the right will only have those rows output that match some row of the left table. When outputting a left-table row for which there is no right-table match, empty (null) values are substituted for the right-table columns."
msgstr ""

#: /tmp/cicero-UbWe/query.xml:590(para) 
msgid "There are also right outer joins and full outer joins. Try to find out what those do."
msgstr ""

#: /tmp/cicero-UbWe/query.xml:611(programlisting) 
#, no-wrap
msgid "\nSELECT W1.city, W1.temp_lo AS low, W1.temp_hi AS high,\n    W2.city, W2.temp_lo AS low, W2.temp_hi AS high\n    FROM weather W1, weather W2\n    WHERE W1.temp_lo &lt; W2.temp_lo\n    AND W1.temp_hi &gt; W2.temp_hi;\n\n     city      | low | high |     city      | low | high\n---------------+-----+------+---------------+-----+------\n San Francisco |  43 |   57 | San Francisco |  46 |   50\n Hayward       |  37 |   54 | San Francisco |  46 |   50\n(2 rows)\n"
msgstr ""

#: /tmp/cicero-UbWe/query.xml:629(programlisting) 
#, no-wrap
msgid "\nSELECT *\n    FROM weather w, cities c\n    WHERE w.city = c.name;\n"
msgstr ""

#: /tmp/cicero-UbWe/query.xml:596(para) 
msgid "<indexterm><primary>join</primary><secondary>self</secondary></indexterm><indexterm><primary>alias</primary><secondary>for table name in query</secondary></indexterm> We can also join a table against itself. This is called a <firstterm>self join</firstterm>. As an example, suppose we wish to find all the weather records that are in the temperature range of other weather records. So we need to compare the <structfield>temp_lo</structfield> and <structfield>temp_hi</structfield> columns of each <structname>weather</structname> row to the <structfield>temp_lo</structfield> and <structfield>temp_hi</structfield> columns of all other <structname>weather</structname> rows. We can do this with the following query: <placeholder-1/> Here we have relabeled the weather table as <literal>W1</literal> and <literal>W2</literal> to be able to distinguish the left and right side of the join. You can also use these kinds of aliases in other queries to save some typing, e.g.: <placeholder-2/> You will encounter this style of abbreviating quite frequently."
msgstr ""

#: /tmp/cicero-UbWe/query.xml:640(title) 
msgid "Aggregate Functions"
msgstr ""

#: /tmp/cicero-UbWe/query.xml:643(primary) 
msgid "aggregate function"
msgstr ""

#: /tmp/cicero-UbWe/query.xml:646(para) 
msgid "Like most other relational database products, <productname>PostgreSQL</productname> supports <firstterm>aggregate functions</firstterm>. An aggregate function computes a single result from multiple input rows. For example, there are aggregates to compute the <function>count</function>, <function>sum</function>, <function>avg</function> (average), <function>max</function> (maximum) and <function>min</function> (minimum) over a set of rows."
msgstr ""

#: /tmp/cicero-UbWe/query.xml:661(programlisting) 
#, no-wrap
msgid "\nSELECT max(temp_lo) FROM weather;\n"
msgstr ""

#: /tmp/cicero-UbWe/query.xml:657(para) 
msgid "As an example, we can find the highest low-temperature reading anywhere with: <placeholder-1/><screen>\n max\n-----\n  46\n(1 row)\n</screen>"
msgstr ""

#: /tmp/cicero-UbWe/query.xml:679(programlisting) 
#, no-wrap
msgid "\nSELECT city FROM weather WHERE temp_lo = max(temp_lo);     <lineannotation>WRONG</lineannotation>\n"
msgstr ""

#: /tmp/cicero-UbWe/query.xml:693(programlisting) 
#, no-wrap
msgid "\nSELECT city FROM weather\n    WHERE temp_lo = (SELECT max(temp_lo) FROM weather);\n"
msgstr ""

#: /tmp/cicero-UbWe/query.xml:673(para) 
msgid "<indexterm><primary>subquery</primary></indexterm> If we wanted to know what city (or cities) that reading occurred in, we might try: <placeholder-1/> but this will not work since the aggregate <function>max</function> cannot be used in the <literal>WHERE</literal> clause. (This restriction exists because the <literal>WHERE</literal> clause determines which rows will be included in the aggregate calculation; so obviously it has to be evaluated before aggregate functions are computed.) However, as is often the case the query can be restated to accomplish the desired result, here by using a <firstterm>subquery</firstterm>: <placeholder-2/><screen>\n     city\n---------------\n San Francisco\n(1 row)\n</screen> This is OK because the subquery is an independent computation that computes its own aggregate separately from what is happening in the outer query."
msgstr ""

#: /tmp/cicero-UbWe/query.xml:718(programlisting) 
#, no-wrap
msgid "\nSELECT city, max(temp_lo)\n    FROM weather\n    GROUP BY city;\n"
msgstr ""

#: /tmp/cicero-UbWe/query.xml:737(programlisting) 
#, no-wrap
msgid "\nSELECT city, max(temp_lo)\n    FROM weather\n    GROUP BY city\n    HAVING max(temp_lo) &lt; 40;\n"
msgstr ""

#: /tmp/cicero-UbWe/query.xml:756(programlisting) 
#, no-wrap
msgid "\nSELECT city, max(temp_lo)\n    FROM weather\n    WHERE city LIKE 'S%'<co id=\"co.tutorial-agg-like\"></co>\n    GROUP BY city\n    HAVING max(temp_lo) &lt; 40;\n"
msgstr ""

#: /tmp/cicero-UbWe/query.xml:765(para) 
msgid "The <literal>LIKE</literal> operator does pattern matching and is explained in <xref linkend=\"functions-matching\"/>."
msgstr ""

#: /tmp/cicero-UbWe/query.xml:710(para) 
msgid "<indexterm><primary>GROUP BY</primary></indexterm><indexterm><primary>HAVING</primary></indexterm> Aggregates are also very useful in combination with <literal>GROUP BY</literal> clauses. For example, we can get the maximum low temperature observed in each city with: <placeholder-1/><screen>\n     city      | max\n---------------+-----\n Hayward       |  37\n San Francisco |  46\n(2 rows)\n</screen> which gives us one output row per city. Each aggregate result is computed over the table rows matching that city. We can filter these grouped rows using <literal>HAVING</literal>: <placeholder-2/><screen>\n  city   | max\n---------+-----\n Hayward |  37\n(1 row)\n</screen> which gives us the same results for only the cities that have all <structfield>temp_lo</structfield> values below 40. Finally, if we only care about cities whose names begin with <quote><literal>S</literal></quote>, we might do: <placeholder-3/><placeholder-4/>"
msgstr ""

#: /tmp/cicero-UbWe/query.xml:773(para) 
msgid "It is important to understand the interaction between aggregates and <acronym>SQL</acronym>'s <literal>WHERE</literal> and <literal>HAVING</literal> clauses. The fundamental difference between <literal>WHERE</literal> and <literal>HAVING</literal> is this: <literal>WHERE</literal> selects input rows before groups and aggregates are computed (thus, it controls which rows go into the aggregate computation), whereas <literal>HAVING</literal> selects group rows after groups and aggregates are computed. Thus, the <literal>WHERE</literal> clause must not contain aggregate functions; it makes no sense to try to use an aggregate to determine which rows will be inputs to the aggregates. On the other hand, the <literal>HAVING</literal> clause always contains aggregate functions. (Strictly speaking, you are allowed to write a <literal>HAVING</literal> clause that doesn't use aggregates, but it's seldom useful. The same condition could be used more efficiently at the <literal>WHERE</literal> stage.)"
msgstr ""

#: /tmp/cicero-UbWe/query.xml:792(para) 
msgid "In the previous example, we can apply the city name restriction in <literal>WHERE</literal>, since it needs no aggregate. This is more efficient than adding the restriction to <literal>HAVING</literal>, because we avoid doing the grouping and aggregate calculations for all rows that fail the <literal>WHERE</literal> check."
msgstr ""

#: /tmp/cicero-UbWe/query.xml:803(title) 
msgid "Updates"
msgstr ""

#: /tmp/cicero-UbWe/query.xml:806(primary) 
msgid "UPDATE"
msgstr ""

#: /tmp/cicero-UbWe/query.xml:816(programlisting) 
#, no-wrap
msgid "\nUPDATE weather\n    SET temp_hi = temp_hi - 2,  temp_lo = temp_lo - 2\n    WHERE date &gt; '1994-11-28';\n"
msgstr ""

#: /tmp/cicero-UbWe/query.xml:809(para) 
msgid "You can update existing rows using the <command>UPDATE</command> command. Suppose you discover the temperature readings are all off by 2 degrees after November 28. You can correct the data as follows: <placeholder-1/>"
msgstr ""

#: /tmp/cicero-UbWe/query.xml:825(programlisting) 
#, no-wrap
msgid "\nSELECT * FROM weather;\n\n     city      | temp_lo | temp_hi | prcp |    date\n---------------+---------+---------+------+------------\n San Francisco |      46 |      50 | 0.25 | 1994-11-27\n San Francisco |      41 |      55 |    0 | 1994-11-29\n Hayward       |      35 |      52 |      | 1994-11-29\n(3 rows)\n"
msgstr ""

#: /tmp/cicero-UbWe/query.xml:823(para) 
msgid "Look at the new state of the data: <placeholder-1/>"
msgstr ""

#: /tmp/cicero-UbWe/query.xml:839(title) 
msgid "Deletions"
msgstr ""

#: /tmp/cicero-UbWe/query.xml:842(primary) 
msgid "DELETE"
msgstr ""

#: /tmp/cicero-UbWe/query.xml:850(programlisting) 
#, no-wrap
msgid "\nDELETE FROM weather WHERE city = 'Hayward';\n"
msgstr ""

#: /tmp/cicero-UbWe/query.xml:845(para) 
msgid "Rows can be removed from a table using the <command>DELETE</command> command. Suppose you are no longer interested in the weather of Hayward. Then you can do the following to delete those rows from the table: <placeholder-1/> All weather records belonging to Hayward are removed. <placeholder-2/><screen>\n     city      | temp_lo | temp_hi | prcp |    date\n---------------+---------+---------+------+------------\n San Francisco |      46 |      50 | 0.25 | 1994-11-27\n San Francisco |      41 |      55 |    0 | 1994-11-29\n(2 rows)\n</screen>"
msgstr ""

#: /tmp/cicero-UbWe/query.xml:869(para) 
msgid "One should be wary of statements of the form <synopsis>\nDELETE FROM <replaceable>tablename</replaceable>;\n</synopsis> Without a qualification, <command>DELETE</command> will remove <emphasis>all</emphasis> rows from the given table, leaving it empty. The system will not request confirmation before doing this!"
msgstr ""

#. Put one translator per line, in the form of NAME <EMAIL>, YEAR1, YEAR2.
#: /tmp/cicero-UbWe/query.xml:0(None) 
msgid "translator-credits"
msgstr ""

