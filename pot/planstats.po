msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2011-08-25 06:59+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: /tmp/cicero-hjxh/planstats.xml:6(title) 
msgid "How the Planner Uses Statistics"
msgstr ""

#: /tmp/cicero-hjxh/planstats.xml:8(para) 
msgid "This chapter builds on the material covered in <xref linkend=\"using-explain\"/> and <xref linkend=\"planner-stats\"/> to show some additional details about how the planner uses the system statistics to estimate the number of rows each part of a query might return. This is a significant part of the planning process, providing much of the raw material for cost calculation."
msgstr ""

#: /tmp/cicero-hjxh/planstats.xml:17(para) 
msgid "The intent of this chapter is not to document the code in detail, but to present an overview of how it works. This will perhaps ease the learning curve for someone who subsequently wishes to read the code."
msgstr ""

#: /tmp/cicero-hjxh/planstats.xml:25(title) 
msgid "Row Estimation Examples"
msgstr ""

#: /tmp/cicero-hjxh/planstats.xml:28(primary) 
msgid "row estimation"
msgstr ""

#: /tmp/cicero-hjxh/planstats.xml:29(secondary) 
msgid "planner"
msgstr ""

#: /tmp/cicero-hjxh/planstats.xml:32(para) 
msgid "The examples shown below use tables in the <productname>PostgreSQL</productname> regression test database. The outputs shown are taken from version 8.3. The behavior of earlier (or later) versions might vary. Note also that since <command>ANALYZE</command> uses random sampling while producing statistics, the results will change slightly after any new <command>ANALYZE</command>."
msgstr ""

#: /tmp/cicero-hjxh/planstats.xml:45(programlisting) 
#, no-wrap
msgid "\nEXPLAIN SELECT * FROM tenk1;\n\n                         QUERY PLAN\n-------------------------------------------------------------\n Seq Scan on tenk1  (cost=0.00..458.00 rows=10000 width=244)\n"
msgstr ""

#: /tmp/cicero-hjxh/planstats.xml:58(programlisting) 
#, no-wrap
msgid "\nSELECT relpages, reltuples FROM pg_class WHERE relname = 'tenk1';\n\n relpages | reltuples\n----------+-----------\n      358 |     10000\n"
msgstr ""

#: /tmp/cicero-hjxh/planstats.xml:42(para) 
msgid "Let's start with a very simple query: <placeholder-1/> How the planner determines the cardinality of <structname>tenk1</structname> is covered in <xref linkend=\"planner-stats\"/>, but is repeated here for completeness. The number of pages and rows is looked up in <structname>pg_class</structname>: <placeholder-2/> These numbers are current as of the last <command>VACUUM</command> or <command>ANALYZE</command> on the table. The planner then fetches the actual current number of pages in the table (this is a cheap operation, not requiring a table scan). If that is different from <structfield>relpages</structfield> then <structfield>reltuples</structfield> is scaled accordingly to arrive at a current number-of-rows estimate. In this case the values are correct so the rows estimate is the same as <structfield>reltuples</structfield>."
msgstr ""

#: /tmp/cicero-hjxh/planstats.xml:81(programlisting) 
#, no-wrap
msgid "\nEXPLAIN SELECT * FROM tenk1 WHERE unique1 &lt; 1000;\n\n                                   QUERY PLAN\n--------------------------------------------------------------------------------\n Bitmap Heap Scan on tenk1  (cost=24.06..394.64 rows=1007 width=244)\n   Recheck Cond: (unique1 &lt; 1000)\n   -&gt;  Bitmap Index Scan on tenk1_unique1  (cost=0.00..23.80 rows=1007 width=0)\n         Index Cond: (unique1 &lt; 1000)\n"
msgstr ""

#: /tmp/cicero-hjxh/planstats.xml:103(programlisting) 
#, no-wrap
msgid "\nSELECT histogram_bounds FROM pg_stats\nWHERE tablename='tenk1' AND attname='unique1';\n\n                   histogram_bounds\n------------------------------------------------------\n {0,993,1997,3050,4040,5036,5957,7057,8029,9016,9995}\n"
msgstr ""

#: /tmp/cicero-hjxh/planstats.xml:120(programlisting) 
#, no-wrap
msgid "\nselectivity = (1 + (1000 - bucket[2].min)/(bucket[2].max - bucket[2].min))/num_buckets\n            = (1 + (1000 - 993)/(1997 - 993))/10\n            = 0.100697\n"
msgstr ""

#: /tmp/cicero-hjxh/planstats.xml:131(programlisting) 
#, no-wrap
msgid "\nrows = rel_cardinality * selectivity\n     = 10000 * 0.100697\n     = 1007  (rounding off)\n"
msgstr ""

#: /tmp/cicero-hjxh/planstats.xml:77(para) 
msgid "Let's move on to an example with a range condition in its <literal>WHERE</literal> clause: <placeholder-1/> The planner examines the <literal>WHERE</literal> clause condition and looks up the selectivity function for the operator <literal>&lt;</literal> in <structname>pg_operator</structname>. This is held in the column <structfield>oprrest</structfield>, and the entry in this case is <function>scalarltsel</function>. The <function>scalarltsel</function> function retrieves the histogram for <structfield>unique1</structfield> from <structname>pg_statistics</structname>. For manual queries it is more convenient to look in the simpler <structname>pg_stats</structname> view: <placeholder-2/> Next the fraction of the histogram occupied by <quote>&lt; 1000</quote> is worked out. This is the selectivity. The histogram divides the range into equal frequency buckets, so all we have to do is locate the bucket that our value is in and count <emphasis>part</emphasis> of it and <emphasis>all</emphasis> of the ones before. The value 1000 is clearly in the second bucket (993-1997). Assuming a linear distribution of values inside each bucket, we can calculate the selectivity as: <placeholder-3/> that is, one whole bucket plus a linear fraction of the second, divided by the number of buckets. The estimated number of rows can now be calculated as the product of the selectivity and the cardinality of <structname>tenk1</structname>: <placeholder-4/>"
msgstr ""

#: /tmp/cicero-hjxh/planstats.xml:142(programlisting) 
#, no-wrap
msgid "\nEXPLAIN SELECT * FROM tenk1 WHERE stringu1 = 'CRAAAA';\n\n                        QUERY PLAN\n----------------------------------------------------------\n Seq Scan on tenk1  (cost=0.00..483.00 rows=30 width=244)\n   Filter: (stringu1 = 'CRAAAA'::name)\n"
msgstr ""

#: /tmp/cicero-hjxh/planstats.xml:159(programlisting) 
#, no-wrap
msgid "\nSELECT null_frac, n_distinct, most_common_vals, most_common_freqs FROM pg_stats\nWHERE tablename='tenk1' AND attname='stringu1';\n\nnull_frac         | 0\nn_distinct        | 676\nmost_common_vals  | {EJAAAA,BBAAAA,CRAAAA,FCAAAA,FEAAAA,GSAAAA,JOAAAA,MCAAAA,NAAAAA,WGAAAA}\nmost_common_freqs | {0.00333333,0.003,0.003,0.003,0.003,0.003,0.003,0.003,0.003,0.003}\n\n"
msgstr ""

#: /tmp/cicero-hjxh/planstats.xml:174(programlisting) 
#, no-wrap
msgid "\nselectivity = mcf[3]\n            = 0.003\n"
msgstr ""

#: /tmp/cicero-hjxh/planstats.xml:182(programlisting) 
#, no-wrap
msgid "\nrows = 10000 * 0.003\n     = 30\n"
msgstr ""

#: /tmp/cicero-hjxh/planstats.xml:138(para) 
msgid "Next let's consider an example with an equality condition in its <literal>WHERE</literal> clause: <placeholder-1/> Again the planner examines the <literal>WHERE</literal> clause condition and looks up the selectivity function for <literal>=</literal>, which is <function>eqsel</function>. For equality estimation the histogram is not useful; instead the list of <firstterm>most common values</firstterm> (<acronym>MCV</acronym>s) is used to determine the selectivity. Let's have a look at the MCVs, with some additional columns that will be useful later: <placeholder-2/> Since <literal>CRAAAA</literal> appears in the list of MCVs, the selectivity is merely the corresponding entry in the list of most common frequencies (<acronym>MCF</acronym>s): <placeholder-3/> As before, the estimated number of rows is just the product of this with the cardinality of <structname>tenk1</structname>: <placeholder-4/>"
msgstr ""

#: /tmp/cicero-hjxh/planstats.xml:192(programlisting) 
#, no-wrap
msgid "\nEXPLAIN SELECT * FROM tenk1 WHERE stringu1 = 'xxx';\n\n                        QUERY PLAN\n----------------------------------------------------------\n Seq Scan on tenk1  (cost=0.00..483.00 rows=15 width=244)\n   Filter: (stringu1 = 'xxx'::name)\n"
msgstr ""

#: /tmp/cicero-hjxh/planstats.xml:207(programlisting) 
#, no-wrap
msgid "\nselectivity = (1 - sum(mvf))/(num_distinct - num_mcv)\n            = (1 - (0.00333333 + 0.003 + 0.003 + 0.003 + 0.003 + 0.003 +\n                    0.003 + 0.003 + 0.003 + 0.003))/(676 - 10)\n            = 0.0014559\n"
msgstr ""

#: /tmp/cicero-hjxh/planstats.xml:223(programlisting) 
#, no-wrap
msgid "\nrows = 10000 * 0.0014559\n     = 15  (rounding off)\n"
msgstr ""

#: /tmp/cicero-hjxh/planstats.xml:188(para) 
msgid "Now consider the same query, but with a constant that is not in the <acronym>MCV</acronym> list: <placeholder-1/> This is quite a different problem: how to estimate the selectivity when the value is <emphasis>not</emphasis> in the <acronym>MCV</acronym> list. The approach is to use the fact that the value is not in the list, combined with the knowledge of the frequencies for all of the <acronym>MCV</acronym>s: <placeholder-2/> That is, add up all the frequencies for the <acronym>MCV</acronym>s and subtract them from one, then divide by the number of <emphasis>other</emphasis> distinct values. This amounts to assuming that the fraction of the column that is not any of the MCVs is evenly distributed among all the other distinct values. Notice that there are no null values so we don't have to worry about those (otherwise we'd subtract the null fraction from the numerator as well). The estimated number of rows is then calculated as usual: <placeholder-3/>"
msgstr ""

#: /tmp/cicero-hjxh/planstats.xml:249(programlisting) 
#, no-wrap
msgid "\nEXPLAIN SELECT * FROM tenk1 WHERE stringu1 &lt; 'IAAAAA';\n\n                         QUERY PLAN\n------------------------------------------------------------\n Seq Scan on tenk1  (cost=0.00..483.00 rows=3077 width=244)\n   Filter: (stringu1 &lt; 'IAAAAA'::name)\n"
msgstr ""

#: /tmp/cicero-hjxh/planstats.xml:261(programlisting) 
#, no-wrap
msgid "\nSELECT histogram_bounds FROM pg_stats\nWHERE tablename='tenk1' AND attname='stringu1';\n\n                                histogram_bounds\n--------------------------------------------------------------------------------\n {AAAAAA,CQAAAA,FRAAAA,IBAAAA,KRAAAA,NFAAAA,PSAAAA,SGAAAA,VAAAAA,XLAAAA,ZZAAAA}\n"
msgstr ""

#: /tmp/cicero-hjxh/planstats.xml:274(programlisting) 
#, no-wrap
msgid "\nselectivity = sum(relevant mvfs)\n            = 0.00333333 + 0.003 + 0.003 + 0.003 + 0.003 + 0.003\n            = 0.01833333\n"
msgstr ""

#: /tmp/cicero-hjxh/planstats.xml:291(programlisting) 
#, no-wrap
msgid "\nselectivity = mcv_selectivity + histogram_selectivity * histogram_fraction\n            = 0.01833333 + 0.298387 * 0.96966667\n            = 0.307669\n\nrows        = 10000 * 0.307669\n            = 3077  (rounding off)\n"
msgstr ""

#: /tmp/cicero-hjxh/planstats.xml:229(para) 
msgid "The previous example with <literal>unique1 &lt; 1000</literal> was an oversimplification of what <function>scalarltsel</function> really does; now that we have seen an example of the use of MCVs, we can fill in some more detail. The example was correct as far as it went, because since <structfield>unique1</structfield> is a unique column it has no MCVs (obviously, no value is any more common than any other value). For a non-unique column, there will normally be both a histogram and an MCV list, and <emphasis>the histogram does not include the portion of the column population represented by the MCVs</emphasis>. We do things this way because it allows more precise estimation. In this situation <function>scalarltsel</function> directly applies the condition (e.g., <quote>&lt; 1000</quote>) to each value of the MCV list, and adds up the frequencies of the MCVs for which the condition is true. This gives an exact estimate of the selectivity within the portion of the table that is MCVs. The histogram is then used in the same way as above to estimate the selectivity in the portion of the table that is not MCVs, and then the two numbers are combined to estimate the overall selectivity. For example, consider <placeholder-1/> We already saw the MCV information for <structfield>stringu1</structfield>, and here is its histogram: <placeholder-2/> Checking the MCV list, we find that the condition <literal>stringu1 &lt; 'IAAAAA'</literal> is satisfied by the first six entries and not the last four, so the selectivity within the MCV part of the population is <placeholder-3/> Summing all the MCFs also tells us that the total fraction of the population represented by MCVs is 0.03033333, and therefore the fraction represented by the histogram is 0.96966667 (again, there are no nulls, else we'd have to exclude them here). We can see that the value <literal>IAAAAA</literal> falls nearly at the end of the third histogram bucket. Using some rather cheesy assumptions about the frequency of different characters, the planner arrives at the estimate 0.298387 for the portion of the histogram population that is less than <literal>IAAAAA</literal>. We then combine the estimates for the MCV and non-MCV populations: <placeholder-4/> In this particular example, the correction from the MCV list is fairly small, because the column distribution is actually quite flat (the statistics showing these particular values as being more common than others are mostly due to sampling error). In a more typical case where some values are significantly more common than others, this complicated process gives a useful improvement in accuracy because the selectivity for the most common values is found exactly."
msgstr ""

#: /tmp/cicero-hjxh/planstats.xml:313(programlisting) 
#, no-wrap
msgid "\nEXPLAIN SELECT * FROM tenk1 WHERE unique1 &lt; 1000 AND stringu1 = 'xxx';\n\n                                   QUERY PLAN\n--------------------------------------------------------------------------------\n Bitmap Heap Scan on tenk1  (cost=23.80..396.91 rows=1 width=244)\n   Recheck Cond: (unique1 &lt; 1000)\n   Filter: (stringu1 = 'xxx'::name)\n   -&gt;  Bitmap Index Scan on tenk1_unique1  (cost=0.00..23.80 rows=1007 width=0)\n         Index Cond: (unique1 &lt; 1000)\n"
msgstr ""

#: /tmp/cicero-hjxh/planstats.xml:328(programlisting) 
#, no-wrap
msgid "\nselectivity = selectivity(unique1 &lt; 1000) * selectivity(stringu1 = 'xxx')\n            = 0.100697 * 0.0014559\n            = 0.0001466\n\nrows        = 10000 * 0.0001466\n            = 1  (rounding off)\n"
msgstr ""

#: /tmp/cicero-hjxh/planstats.xml:309(para) 
msgid "Now let's consider a case with more than one condition in the <literal>WHERE</literal> clause: <placeholder-1/> The planner assumes that the two conditions are independent, so that the individual selectivities of the clauses can be multiplied together: <placeholder-2/> Notice that the number of rows estimated to be returned from the bitmap index scan reflects only the condition used with the index; this is important since it affects the cost estimate for the subsequent heap fetches."
msgstr ""

#: /tmp/cicero-hjxh/planstats.xml:346(programlisting) 
#, no-wrap
msgid "\nEXPLAIN SELECT * FROM tenk1 t1, tenk2 t2\nWHERE t1.unique1 &lt; 50 AND t1.unique2 = t2.unique2;\n\n                                      QUERY PLAN\n--------------------------------------------------------------------------------------\n Nested Loop  (cost=4.64..456.23 rows=50 width=488)\n   -&gt;  Bitmap Heap Scan on tenk1 t1  (cost=4.64..142.17 rows=50 width=244)\n         Recheck Cond: (unique1 &lt; 50)\n         -&gt;  Bitmap Index Scan on tenk1_unique1  (cost=0.00..4.63 rows=50 width=0)\n               Index Cond: (unique1 &lt; 50)\n   -&gt;  Index Scan using tenk2_unique2 on tenk2 t2  (cost=0.00..6.27 rows=1 width=244)\n         Index Cond: (unique2 = t1.unique2)\n"
msgstr ""

#: /tmp/cicero-hjxh/planstats.xml:368(programlisting) 
#, no-wrap
msgid "\nselectivity = (0 + (50 - bucket[1].min)/(bucket[1].max - bucket[1].min))/num_buckets\n            = (0 + (50 - 0)/(993 - 0))/10\n            = 0.005035\n\nrows        = 10000 * 0.005035\n            = 50  (rounding off)\n"
msgstr ""

#: /tmp/cicero-hjxh/planstats.xml:385(programlisting) 
#, no-wrap
msgid "\nSELECT tablename, null_frac,n_distinct, most_common_vals FROM pg_stats\nWHERE tablename IN ('tenk1', 'tenk2') AND attname='unique2';\n\ntablename  | null_frac | n_distinct | most_common_vals\n-----------+-----------+------------+------------------\n tenk1     |         0 |         -1 |\n tenk2     |         0 |         -1 |\n"
msgstr ""

#: /tmp/cicero-hjxh/planstats.xml:400(programlisting) 
#, no-wrap
msgid "\nselectivity = (1 - null_frac1) * (1 - null_frac2) * min(1/num_distinct1, 1/num_distinct2)\n            = (1 - 0) * (1 - 0) / max(10000, 10000)\n            = 0.0001\n"
msgstr ""

#: /tmp/cicero-hjxh/planstats.xml:413(programlisting) 
#, no-wrap
msgid "\nrows = (outer_cardinality * inner_cardinality) * selectivity\n     = (50 * 10000) * 0.0001\n     = 50\n"
msgstr ""

#: /tmp/cicero-hjxh/planstats.xml:343(para) 
msgid "Finally we will examine a query that involves a join: <placeholder-1/> The restriction on <structname>tenk1</structname>, <literal>unique1 &lt; 50</literal>, is evaluated before the nested-loop join. This is handled analogously to the previous range example. This time the value 50 falls into the first bucket of the <structfield>unique1</structfield> histogram: <placeholder-2/> The restriction for the join is <literal>t2.unique2 = t1.unique2</literal>. The operator is just our familiar <literal>=</literal>, however the selectivity function is obtained from the <structfield>oprjoin</structfield> column of <structname>pg_operator</structname>, and is <function>eqjoinsel</function>. <function>eqjoinsel</function> looks up the statistical information for both <structname>tenk2</structname> and <structname>tenk1</structname>: <placeholder-3/> In this case there is no <acronym>MCV</acronym> information for <structfield>unique2</structfield> because all the values appear to be unique, so we use an algorithm that relies only on the number of distinct values for both relations together with their null fractions: <placeholder-4/> This is, subtract the null fraction from one for each of the relations, and divide by the maximum of the numbers of distinct values. The number of rows that the join is likely to emit is calculated as the cardinality of the Cartesian product of the two inputs, multiplied by the selectivity: <placeholder-5/>"
msgstr ""

#: /tmp/cicero-hjxh/planstats.xml:420(para) 
msgid "Had there been MCV lists for the two columns, <function>eqjoinsel</function> would have used direct comparison of the MCV lists to determine the join selectivity within the part of the column populations represented by the MCVs. The estimate for the remainder of the populations follows the same approach shown here."
msgstr ""

#: /tmp/cicero-hjxh/planstats.xml:428(para) 
msgid "Notice that we showed <literal>inner_cardinality</literal> as 10000, that is, the unmodified size of <structname>tenk2</structname>. It might appear from inspection of the <command>EXPLAIN</command> output that the estimate of join rows comes from 50 * 1, that is, the number of outer rows times the estimated number of rows obtained by each inner index scan on <structname>tenk2</structname>. But this is not the case: the join relation size is estimated before any particular join plan has been considered. If everything is working well then the two ways of estimating the join size will produce about the same answer, but due to roundoff error and other factors they sometimes diverge significantly."
msgstr ""

#: /tmp/cicero-hjxh/planstats.xml:441(para) 
msgid "For those interested in further details, estimation of the size of a table (before any <literal>WHERE</literal> clauses) is done in <filename>src/backend/optimizer/util/plancat.c</filename>. The generic logic for clause selectivities is in <filename>src/backend/optimizer/path/clausesel.c</filename>. The operator-specific selectivity functions are mostly found in <filename>src/backend/utils/adt/selfuncs.c</filename>."
msgstr ""

#. Put one translator per line, in the form of NAME <EMAIL>, YEAR1, YEAR2.
#: /tmp/cicero-hjxh/planstats.xml:0(None) 
msgid "translator-credits"
msgstr ""

