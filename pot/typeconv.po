msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2011-09-28 11:01+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: /tmp/cicero-PyDp/typeconv.xml:5(title) 
msgid "Type Conversion"
msgstr ""

#: /tmp/cicero-PyDp/typeconv.xml:8(primary) /tmp/cicero-PyDp/typeconv.xml:151(primary) 
msgid "data type"
msgstr ""

#: /tmp/cicero-PyDp/typeconv.xml:9(secondary) 
msgid "conversion"
msgstr ""

#: /tmp/cicero-PyDp/typeconv.xml:12(para) 
msgid "<acronym>SQL</acronym> statements can, intentionally or not, require the mixing of different data types in the same expression. <productname>PostgreSQL</productname> has extensive facilities for evaluating mixed-type expressions."
msgstr ""

#: /tmp/cicero-PyDp/typeconv.xml:19(para) 
msgid "In many cases a user does not need to understand the details of the type conversion mechanism. However, implicit conversions done by <productname>PostgreSQL</productname> can affect the results of a query. When necessary, these results can be tailored by using <emphasis>explicit</emphasis> type conversion."
msgstr ""

#: /tmp/cicero-PyDp/typeconv.xml:27(para) 
msgid "This chapter introduces the <productname>PostgreSQL</productname> type conversion mechanisms and conventions. Refer to the relevant sections in <xref linkend=\"datatype\"/> and <xref linkend=\"functions\"/> for more information on specific data types and allowed functions and operators."
msgstr ""

#: /tmp/cicero-PyDp/typeconv.xml:36(title) 
msgid "Overview"
msgstr ""

#: /tmp/cicero-PyDp/typeconv.xml:38(para) 
msgid "<acronym>SQL</acronym> is a strongly typed language. That is, every data item has an associated data type which determines its behavior and allowed usage. <productname>PostgreSQL</productname> has an extensible type system that is more general and flexible than other <acronym>SQL</acronym> implementations. Hence, most type conversion behavior in <productname>PostgreSQL</productname> is governed by general rules rather than by <foreignphrase>ad hoc</foreignphrase> heuristics. This allows the use of mixed-type expressions even with user-defined types."
msgstr ""

#: /tmp/cicero-PyDp/typeconv.xml:49(para) 
msgid "The <productname>PostgreSQL</productname> scanner/parser divides lexical elements into five fundamental categories: integers, non-integer numbers, strings, identifiers, and key words. Constants of most non-numeric types are first classified as strings. The <acronym>SQL</acronym> language definition allows specifying type names with strings, and this mechanism can be used in <productname>PostgreSQL</productname> to start the parser down the correct path. For example, the query: <screen>\nSELECT text 'Origin' AS \"label\", point '(0,0)' AS \"value\";\n\n label  | value\n--------+-------\n Origin | (0,0)\n(1 row)\n</screen> has two literal constants, of type <type>text</type> and <type>point</type>. If a type is not specified for a string literal, then the placeholder type <type>unknown</type> is assigned initially, to be resolved in later stages as described below."
msgstr ""

#: /tmp/cicero-PyDp/typeconv.xml:80(term) 
msgid "Function calls"
msgstr ""

#: /tmp/cicero-PyDp/typeconv.xml:84(para) 
msgid "Much of the <productname>PostgreSQL</productname> type system is built around a rich set of functions. Functions can have one or more arguments. Since <productname>PostgreSQL</productname> permits function overloading, the function name alone does not uniquely identify the function to be called; the parser must select the right function based on the data types of the supplied arguments."
msgstr ""

#: /tmp/cicero-PyDp/typeconv.xml:95(term) /tmp/cicero-PyDp/typeconv.xml:202(title) 
msgid "Operators"
msgstr ""

#: /tmp/cicero-PyDp/typeconv.xml:99(para) 
msgid "<productname>PostgreSQL</productname> allows expressions with prefix and postfix unary (one-argument) operators, as well as binary (two-argument) operators. Like functions, operators can be overloaded, so the same problem of selecting the right operator exists."
msgstr ""

#: /tmp/cicero-PyDp/typeconv.xml:109(term) /tmp/cicero-PyDp/typeconv.xml:728(title) 
msgid "Value Storage"
msgstr ""

#: /tmp/cicero-PyDp/typeconv.xml:113(para) 
msgid "<acronym>SQL</acronym><command>INSERT</command> and <command>UPDATE</command> statements place the results of expressions into a table. The expressions in the statement must be matched up with, and perhaps converted to, the types of the target columns."
msgstr ""

#: /tmp/cicero-PyDp/typeconv.xml:121(term) 
msgid "<literal>UNION</literal>, <literal>CASE</literal>, and related constructs"
msgstr ""

#: /tmp/cicero-PyDp/typeconv.xml:125(para) 
msgid "Since all query results from a unionized <command>SELECT</command> statement must appear in a single set of columns, the types of the results of each <command>SELECT</command> clause must be matched up and converted to a uniform set. Similarly, the result expressions of a <literal>CASE</literal> construct must be converted to a common type so that the <literal>CASE</literal> expression as a whole has a known output type. The same holds for <literal>ARRAY</literal> constructs, and for the <function>GREATEST</function> and <function>LEAST</function> functions."
msgstr ""

#: /tmp/cicero-PyDp/typeconv.xml:73(para) 
msgid "There are four fundamental <acronym>SQL</acronym> constructs requiring distinct type conversion rules in the <productname>PostgreSQL</productname> parser: <placeholder-1/>"
msgstr ""

#: /tmp/cicero-PyDp/typeconv.xml:139(para) 
msgid "The system catalogs store information about which conversions, or <firstterm>casts</firstterm>, exist between which data types, and how to perform those conversions. Additional casts can be added by the user with the <xref linkend=\"sql-createcast\"/> command. (This is usually done in conjunction with defining new data types. The set of casts between built-in types has been carefully crafted and is best not altered.)"
msgstr ""

#: /tmp/cicero-PyDp/typeconv.xml:152(secondary) 
msgid "category"
msgstr ""

#: /tmp/cicero-PyDp/typeconv.xml:155(para) 
msgid "An additional heuristic provided by the parser allows improved determination of the proper casting behavior among groups of types that have implicit casts. Data types are divided into several basic <firstterm>type categories</firstterm>, including <type>boolean</type>, <type>numeric</type>, <type>string</type>, <type>bitstring</type>, <type>datetime</type>, <type>timespan</type>, <type>geometric</type>, <type>network</type>, and user-defined. (For a list see <xref linkend=\"catalog-typcategory-table\"/>; but note it is also possible to create custom type categories.) Within each category there can be one or more <firstterm>preferred types</firstterm>, which are preferred when there is a choice of possible types. With careful selection of preferred types and available implicit casts, it is possible to ensure that ambiguous expressions (those with multiple candidate parsing solutions) can be resolved in a useful way."
msgstr ""

#: /tmp/cicero-PyDp/typeconv.xml:176(para) 
msgid "Implicit conversions should never have surprising or unpredictable outcomes."
msgstr ""

#: /tmp/cicero-PyDp/typeconv.xml:182(para) 
msgid "There should be no extra overhead in the parser or executor if a query does not need implicit type conversion. That is, if a query is well-formed and the types already match, then the query should execute without spending extra time in the parser and without introducing unnecessary implicit conversion calls in the query."
msgstr ""

#: /tmp/cicero-PyDp/typeconv.xml:190(para) 
msgid "Additionally, if a query usually requires an implicit conversion for a function, and if then the user defines a new function with the correct argument types, the parser should use this new function and no longer do implicit conversion to use the old function."
msgstr ""

#: /tmp/cicero-PyDp/typeconv.xml:171(para) 
msgid "All type conversion rules are designed with several principles in mind: <placeholder-1/>"
msgstr ""

#: /tmp/cicero-PyDp/typeconv.xml:205(primary) 
msgid "operator"
msgstr ""

#: /tmp/cicero-PyDp/typeconv.xml:206(secondary) /tmp/cicero-PyDp/typeconv.xml:461(secondary) 
msgid "type resolution in an invocation"
msgstr ""

#: /tmp/cicero-PyDp/typeconv.xml:209(para) 
msgid "The specific operator that is referenced by an operator expression is determined using the following procedure. Note that this procedure is indirectly affected by the precedence of the involved operators, since that will determine which sub-expressions are taken to be the inputs of which operators. See <xref linkend=\"sql-precedence\"/> for more information."
msgstr ""

#: /tmp/cicero-PyDp/typeconv.xml:219(title) 
msgid "Operator Type Resolution"
msgstr ""

#: /tmp/cicero-PyDp/typeconv.xml:222(para) 
msgid "Select the operators to be considered from the <classname>pg_operator</classname> system catalog. If a non-schema-qualified operator name was used (the usual case), the operators considered are those with the matching name and argument count that are visible in the current search path (see <xref linkend=\"ddl-schemas-path\"/>). If a qualified operator name was given, only operators in the specified schema are considered."
msgstr ""

#: /tmp/cicero-PyDp/typeconv.xml:234(para) 
msgid "If the search path finds multiple operators with identical argument types, only the one appearing earliest in the path is considered. Operators with different argument types are considered on an equal footing regardless of search path position."
msgstr ""

#: /tmp/cicero-PyDp/typeconv.xml:245(para) 
msgid "Check for an operator accepting exactly the input argument types. If one exists (there can be only one exact match in the set of operators considered), use it."
msgstr ""

#: /tmp/cicero-PyDp/typeconv.xml:253(para) 
msgid "If one argument of a binary operator invocation is of the <type>unknown</type> type, then assume it is the same type as the other argument for this check. Invocations involving two <type>unknown</type> inputs, or a unary operator with an <type>unknown</type> input, will never find a match at this step."
msgstr ""

#: /tmp/cicero-PyDp/typeconv.xml:264(para) /tmp/cicero-PyDp/typeconv.xml:554(para) 
msgid "Look for the best match."
msgstr ""

#: /tmp/cicero-PyDp/typeconv.xml:269(para) 
msgid "Discard candidate operators for which the input types do not match and cannot be converted (using an implicit conversion) to match. <type>unknown</type> literals are assumed to be convertible to anything for this purpose. If only one candidate remains, use it; else continue to the next step."
msgstr ""

#: /tmp/cicero-PyDp/typeconv.xml:278(para) /tmp/cicero-PyDp/typeconv.xml:568(para) 
msgid "Run through all candidates and keep those with the most exact matches on input types. (Domains are considered the same as their base type for this purpose.) Keep all candidates if none have exact matches. If only one candidate remains, use it; else continue to the next step."
msgstr ""

#: /tmp/cicero-PyDp/typeconv.xml:286(para) /tmp/cicero-PyDp/typeconv.xml:576(para) 
msgid "Run through all candidates and keep those that accept preferred types (of the input data type's type category) at the most positions where type conversion will be required. Keep all candidates if none accept preferred types. If only one candidate remains, use it; else continue to the next step."
msgstr ""

#: /tmp/cicero-PyDp/typeconv.xml:295(para) /tmp/cicero-PyDp/typeconv.xml:585(para) 
msgid "If any input arguments are <type>unknown</type>, check the type categories accepted at those argument positions by the remaining candidates. At each position, select the <type>string</type> category if any candidate accepts that category. (This bias towards string is appropriate since an unknown-type literal looks like a string.) Otherwise, if all the remaining candidates accept the same type category, select that category; otherwise fail because the correct choice cannot be deduced without more clues. Now discard candidates that do not accept the selected type category. Furthermore, if any candidate accepts a preferred type in that category, discard candidates that accept non-preferred types for that argument."
msgstr ""

#: /tmp/cicero-PyDp/typeconv.xml:311(para) /tmp/cicero-PyDp/typeconv.xml:601(para) 
msgid "If only one candidate remains, use it. If no candidate or more than one candidate remains, then fail."
msgstr ""

#: /tmp/cicero-PyDp/typeconv.xml:321(para) /tmp/cicero-PyDp/typeconv.xml:903(para) 
msgid "Some examples follow."
msgstr ""

#: /tmp/cicero-PyDp/typeconv.xml:326(title) 
msgid "Factorial Operator Type Resolution"
msgstr ""

#: /tmp/cicero-PyDp/typeconv.xml:328(para) 
msgid "There is only one factorial operator (postfix <literal>!</literal>) defined in the standard catalog, and it takes an argument of type <type>bigint</type>. The scanner assigns an initial type of <type>integer</type> to the argument in this query expression: <screen>\nSELECT 40 ! AS \"40 factorial\";\n\n                   40 factorial\n--------------------------------------------------\n 815915283247897734345611269596115894272000000000\n(1 row)\n</screen> So the parser does a type conversion on the operand and the query is equivalent to: <screen>\nSELECT CAST(40 AS bigint) ! AS \"40 factorial\";\n</screen>"
msgstr ""

#: /tmp/cicero-PyDp/typeconv.xml:353(title) 
msgid "String Concatenation Operator Type Resolution"
msgstr ""

#: /tmp/cicero-PyDp/typeconv.xml:355(para) 
msgid "A string-like syntax is used for working with string types and for working with complex extension types. Strings with unspecified type are matched with likely operator candidates."
msgstr ""

#: /tmp/cicero-PyDp/typeconv.xml:361(para) 
msgid "An example with one unspecified argument: <screen>\nSELECT text 'abc' || 'def' AS \"text and unknown\";\n\n text and unknown\n------------------\n abcdef\n(1 row)\n</screen>"
msgstr ""

#: /tmp/cicero-PyDp/typeconv.xml:373(para) 
msgid "In this case the parser looks to see if there is an operator taking <type>text</type> for both arguments. Since there is, it assumes that the second argument should be interpreted as type <type>text</type>."
msgstr ""

#: /tmp/cicero-PyDp/typeconv.xml:379(para) 
msgid "Here is a concatenation on unspecified types: <screen>\nSELECT 'abc' || 'def' AS \"unspecified\";\n\n unspecified\n-------------\n abcdef\n(1 row)\n</screen>"
msgstr ""

#: /tmp/cicero-PyDp/typeconv.xml:391(para) 
msgid "In this case there is no initial hint for which type to use, since no types are specified in the query. So, the parser looks for all candidate operators and finds that there are candidates accepting both string-category and bit-string-category inputs. Since string category is preferred when available, that category is selected, and then the preferred type for strings, <type>text</type>, is used as the specific type to resolve the unknown literals as."
msgstr ""

#: /tmp/cicero-PyDp/typeconv.xml:403(title) 
msgid "Absolute-Value and Negation Operator Type Resolution"
msgstr ""

#: /tmp/cicero-PyDp/typeconv.xml:405(para) 
msgid "The <productname>PostgreSQL</productname> operator catalog has several entries for the prefix operator <literal>@</literal>, all of which implement absolute-value operations for various numeric data types. One of these entries is for type <type>float8</type>, which is the preferred type in the numeric category. Therefore, <productname>PostgreSQL</productname> will use that entry when faced with an <type>unknown</type> input: <screen>\nSELECT @ '-4.5' AS \"abs\";\n abs\n-----\n 4.5\n(1 row)\n</screen> Here the system has implicitly resolved the unknown-type literal as type <type>float8</type> before applying the chosen operator. We can verify that <type>float8</type> and not some other type was used: <screen>\nSELECT @ '-4.5e500' AS \"abs\";\n\nERROR:  \"-4.5e500\" is out of range for type double precision\n</screen>"
msgstr ""

#: /tmp/cicero-PyDp/typeconv.xml:429(para) 
msgid "On the other hand, the prefix operator <literal>~</literal> (bitwise negation) is defined only for integer data types, not for <type>float8</type>. So, if we try a similar case with <literal>~</literal>, we get: <screen>\nSELECT ~ '20' AS \"negation\";\n\nERROR:  operator is not unique: ~ \"unknown\"\nHINT:  Could not choose a best candidate operator. You might need to add\nexplicit type casts.\n</screen> This happens because the system cannot decide which of the several possible <literal>~</literal> operators should be preferred. We can help it out with an explicit cast: <screen>\nSELECT ~ CAST('20' AS int8) AS \"negation\";\n\n negation\n----------\n      -21\n(1 row)\n</screen>"
msgstr ""

#: /tmp/cicero-PyDp/typeconv.xml:457(title) 
msgid "Functions"
msgstr ""

#: /tmp/cicero-PyDp/typeconv.xml:460(primary) 
msgid "function"
msgstr ""

#: /tmp/cicero-PyDp/typeconv.xml:464(para) 
msgid "The specific function that is referenced by a function call is determined using the following procedure."
msgstr ""

#: /tmp/cicero-PyDp/typeconv.xml:470(title) 
msgid "Function Type Resolution"
msgstr ""

#: /tmp/cicero-PyDp/typeconv.xml:473(para) 
msgid "Select the functions to be considered from the <classname>pg_proc</classname> system catalog. If a non-schema-qualified function name was used, the functions considered are those with the matching name and argument count that are visible in the current search path (see <xref linkend=\"ddl-schemas-path\"/>). If a qualified function name was given, only functions in the specified schema are considered."
msgstr ""

#: /tmp/cicero-PyDp/typeconv.xml:485(para) 
msgid "If the search path finds multiple functions of identical argument types, only the one appearing earliest in the path is considered. Functions of different argument types are considered on an equal footing regardless of search path position."
msgstr ""

#: /tmp/cicero-PyDp/typeconv.xml:493(para) 
msgid "If a function is declared with a <literal>VARIADIC</literal> array parameter, and the call does not use the <literal>VARIADIC</literal> keyword, then the function is treated as if the array parameter were replaced by one or more occurrences of its element type, as needed to match the call. After such expansion the function might have effective argument types identical to some non-variadic function. In that case the function appearing earlier in the search path is used, or if the two functions are in the same schema, the non-variadic one is preferred."
msgstr ""

#: /tmp/cicero-PyDp/typeconv.xml:505(para) 
msgid "Functions that have default values for parameters are considered to match any call that omits zero or more of the defaultable parameter positions. If more than one such function matches a call, the one appearing earliest in the search path is used. If there are two or more such functions in the same schema with identical parameter types in the non-defaulted positions (which is possible if they have different sets of defaultable parameters), the system will not be able to determine which to prefer, and so an <quote>ambiguous function call</quote> error will result if no better match to the call can be found."
msgstr ""

#: /tmp/cicero-PyDp/typeconv.xml:521(para) 
msgid "Check for a function accepting exactly the input argument types. If one exists (there can be only one exact match in the set of functions considered), use it. (Cases involving <type>unknown</type> will never find a match at this step.)"
msgstr ""

#: /tmp/cicero-PyDp/typeconv.xml:542(para) 
msgid "The reason for this step is to support function-style cast specifications in cases where there is not an actual cast function. If there is a cast function, it is conventionally named after its output type, and so there is no need to have a special case. See <xref linkend=\"sql-createcast\"/> for additional commentary."
msgstr ""

#: /tmp/cicero-PyDp/typeconv.xml:531(para) 
msgid "If no exact match is found, see if the function call appears to be a special type conversion request. This happens if the function call has just one argument and the function name is the same as the (internal) name of some data type. Furthermore, the function argument must be either an unknown-type literal, or a type that is binary-coercible to the named data type, or a type that could be converted to the named data type by applying that type's I/O functions (that is, the conversion is either to or from one of the standard string types). When these conditions are met, the function call is treated as a form of <literal>CAST</literal> specification. <placeholder-1/>"
msgstr ""

#: /tmp/cicero-PyDp/typeconv.xml:559(para) 
msgid "Discard candidate functions for which the input types do not match and cannot be converted (using an implicit conversion) to match. <type>unknown</type> literals are assumed to be convertible to anything for this purpose. If only one candidate remains, use it; else continue to the next step."
msgstr ""

#: /tmp/cicero-PyDp/typeconv.xml:611(para) 
msgid "Note that the <quote>best match</quote> rules are identical for operator and function type resolution. Some examples follow."
msgstr ""

#: /tmp/cicero-PyDp/typeconv.xml:618(title) 
msgid "Rounding Function Argument Type Resolution"
msgstr ""

#: /tmp/cicero-PyDp/typeconv.xml:620(para) 
msgid "There is only one <function>round</function> function that takes two arguments; it takes a first argument of type <type>numeric</type> and a second argument of type <type>integer</type>. So the following query automatically converts the first argument of type <type>integer</type> to <type>numeric</type>: <screen>\nSELECT round(4, 4);\n\n round\n--------\n 4.0000\n(1 row)\n</screen> That query is actually transformed by the parser to: <screen>\nSELECT round(CAST (4 AS numeric), 4);\n</screen>"
msgstr ""

#: /tmp/cicero-PyDp/typeconv.xml:643(para) 
msgid "Since numeric constants with decimal points are initially assigned the type <type>numeric</type>, the following query will require no type conversion and therefore might be slightly more efficient: <screen>\nSELECT round(4.0, 4);\n</screen>"
msgstr ""

#: /tmp/cicero-PyDp/typeconv.xml:654(title) 
msgid "Substring Function Type Resolution"
msgstr ""

#: /tmp/cicero-PyDp/typeconv.xml:656(para) 
msgid "There are several <function>substr</function> functions, one of which takes types <type>text</type> and <type>integer</type>. If called with a string constant of unspecified type, the system chooses the candidate function that accepts an argument of the preferred category <literal>string</literal> (namely of type <type>text</type>). <screen>\nSELECT substr('1234', 3);\n\n substr\n--------\n     34\n(1 row)\n</screen>"
msgstr ""

#: /tmp/cicero-PyDp/typeconv.xml:673(para) 
msgid "If the string is declared to be of type <type>varchar</type>, as might be the case if it comes from a table, then the parser will try to convert it to become <type>text</type>: <screen>\nSELECT substr(varchar '1234', 3);\n\n substr\n--------\n     34\n(1 row)\n</screen> This is transformed by the parser to effectively become: <screen>\nSELECT substr(CAST (varchar '1234' AS text), 3);\n</screen>"
msgstr ""

#: /tmp/cicero-PyDp/typeconv.xml:692(para) 
msgid "The parser learns from the <structname>pg_cast</structname> catalog that <type>text</type> and <type>varchar</type> are binary-compatible, meaning that one can be passed to a function that accepts the other without doing any physical conversion. Therefore, no type conversion call is really inserted in this case."
msgstr ""

#: /tmp/cicero-PyDp/typeconv.xml:702(para) 
msgid "And, if the function is called with an argument of type <type>integer</type>, the parser will try to convert that to <type>text</type>: <screen>\nSELECT substr(1234, 3);\nERROR:  function substr(integer, integer) does not exist\nHINT:  No function matches the given name and argument types. You might need\nto add explicit type casts.\n</screen> This does not work because <type>integer</type> does not have an implicit cast to <type>text</type>. An explicit cast will work, however: <screen>\nSELECT substr(CAST (1234 AS text), 3);\n\n substr\n--------\n     34\n(1 row)\n</screen>"
msgstr ""

#: /tmp/cicero-PyDp/typeconv.xml:730(para) 
msgid "Values to be inserted into a table are converted to the destination column's data type according to the following steps."
msgstr ""

#: /tmp/cicero-PyDp/typeconv.xml:737(title) 
msgid "Value Storage Type Conversion"
msgstr ""

#: /tmp/cicero-PyDp/typeconv.xml:740(para) 
msgid "Check for an exact match with the target."
msgstr ""

#: /tmp/cicero-PyDp/typeconv.xml:746(para) 
msgid "Otherwise, try to convert the expression to the target type. This will succeed if there is a registered cast between the two types. If the expression is an unknown-type literal, the contents of the literal string will be fed to the input conversion routine for the target type."
msgstr ""

#: /tmp/cicero-PyDp/typeconv.xml:756(para) 
msgid "Check to see if there is a sizing cast for the target type. A sizing cast is a cast from that type to itself. If one is found in the <structname>pg_cast</structname> catalog, apply it to the expression before storing into the destination column. The implementation function for such a cast always takes an extra parameter of type <type>integer</type>, which receives the destination column's declared length (actually, its <structfield>atttypmod</structfield> value; the interpretation of <structfield>atttypmod</structfield> varies for different data types). The cast function is responsible for applying any length-dependent semantics such as size checking or truncation."
msgstr ""

#: /tmp/cicero-PyDp/typeconv.xml:773(title) 
msgid "<type>character</type> Storage Type Conversion"
msgstr ""

#: /tmp/cicero-PyDp/typeconv.xml:775(para) 
msgid "For a target column declared as <type>character(20)</type> the following statement ensures that the stored value is sized correctly: <screen>\nCREATE TABLE vv (v character(20));\nINSERT INTO vv SELECT 'abc' || 'def';\nSELECT v, length(v) FROM vv;\n\n          v           | length\n----------------------+--------\n abcdef               |     20\n(1 row)\n</screen>"
msgstr ""

#: /tmp/cicero-PyDp/typeconv.xml:791(para) 
msgid "What has really happened here is that the two unknown literals are resolved to <type>text</type> by default, allowing the <literal>||</literal> operator to be resolved as <type>text</type> concatenation. Then the <type>text</type> result of the operator is converted to <type>bpchar</type> (<quote>blank-padded char</quote>, the internal name of the <type>character</type> data type) to match the target column type. (Since the conversion from <type>text</type> to <type>bpchar</type> is binary-coercible, this conversion does not insert any real function call.) Finally, the sizing function <literal>bpchar(bpchar, integer)</literal> is found in the system catalog and applied to the operator's result and the stored column length. This type-specific function performs the required length check and addition of padding spaces."
msgstr ""

#: /tmp/cicero-PyDp/typeconv.xml:809(title) 
msgid "<literal>UNION</literal>, <literal>CASE</literal>, and Related Constructs"
msgstr ""

#: /tmp/cicero-PyDp/typeconv.xml:812(primary) 
msgid "UNION"
msgstr ""

#: /tmp/cicero-PyDp/typeconv.xml:813(secondary) /tmp/cicero-PyDp/typeconv.xml:818(secondary) /tmp/cicero-PyDp/typeconv.xml:823(secondary) /tmp/cicero-PyDp/typeconv.xml:828(secondary) /tmp/cicero-PyDp/typeconv.xml:833(secondary) /tmp/cicero-PyDp/typeconv.xml:838(secondary) 
msgid "determination of result type"
msgstr ""

#: /tmp/cicero-PyDp/typeconv.xml:817(primary) 
msgid "CASE"
msgstr ""

#: /tmp/cicero-PyDp/typeconv.xml:822(primary) 
msgid "ARRAY"
msgstr ""

#: /tmp/cicero-PyDp/typeconv.xml:827(primary) 
msgid "VALUES"
msgstr ""

#: /tmp/cicero-PyDp/typeconv.xml:832(primary) 
msgid "GREATEST"
msgstr ""

#: /tmp/cicero-PyDp/typeconv.xml:837(primary) 
msgid "LEAST"
msgstr ""

#: /tmp/cicero-PyDp/typeconv.xml:841(para) 
msgid "SQL <literal>UNION</literal> constructs must match up possibly dissimilar types to become a single result set. The resolution algorithm is applied separately to each output column of a union query. The <literal>INTERSECT</literal> and <literal>EXCEPT</literal> constructs resolve dissimilar types in the same way as <literal>UNION</literal>. The <literal>CASE</literal>, <literal>ARRAY</literal>, <literal>VALUES</literal>, <function>GREATEST</function> and <function>LEAST</function> constructs use the identical algorithm to match up their component expressions and select a result data type."
msgstr ""

#: /tmp/cicero-PyDp/typeconv.xml:854(title) 
msgid "Type Resolution for <literal>UNION</literal>, <literal>CASE</literal>, and Related Constructs"
msgstr ""

#: /tmp/cicero-PyDp/typeconv.xml:858(para) 
msgid "If all inputs are of the same type, and it is not <type>unknown</type>, resolve as that type. Otherwise, replace any domain types in the list with their underlying base types."
msgstr ""

#: /tmp/cicero-PyDp/typeconv.xml:866(para) 
msgid "If all inputs are of type <type>unknown</type>, resolve as type <type>text</type> (the preferred type of the string category). Otherwise, <type>unknown</type> inputs are ignored."
msgstr ""

#: /tmp/cicero-PyDp/typeconv.xml:874(para) 
msgid "If the non-unknown inputs are not all of the same type category, fail."
msgstr ""

#: /tmp/cicero-PyDp/typeconv.xml:880(para) 
msgid "Choose the first non-unknown input type which is a preferred type in that category, if there is one."
msgstr ""

#: /tmp/cicero-PyDp/typeconv.xml:887(para) 
msgid "Otherwise, choose the last non-unknown input type that allows all the preceding non-unknown inputs to be implicitly converted to it. (There always is such a type, since at least the first type in the list must satisfy this condition.)"
msgstr ""

#: /tmp/cicero-PyDp/typeconv.xml:896(para) 
msgid "Convert all inputs to the selected type. Fail if there is not a conversion from a given input to the selected type."
msgstr ""

#: /tmp/cicero-PyDp/typeconv.xml:908(title) 
msgid "Type Resolution with Underspecified Types in a Union"
msgstr ""

#: /tmp/cicero-PyDp/typeconv.xml:910(para) 
msgid "<screen>\nSELECT text 'a' AS \"text\" UNION SELECT 'b';\n\n text\n------\n a\n b\n(2 rows)\n</screen> Here, the unknown-type literal <literal>'b'</literal> will be resolved to type <type>text</type>."
msgstr ""

#: /tmp/cicero-PyDp/typeconv.xml:925(title) 
msgid "Type Resolution in a Simple Union"
msgstr ""

#: /tmp/cicero-PyDp/typeconv.xml:927(para) 
msgid "<screen>\nSELECT 1.2 AS \"numeric\" UNION SELECT 1;\n\n numeric\n---------\n       1\n     1.2\n(2 rows)\n</screen> The literal <literal>1.2</literal> is of type <type>numeric</type>, and the <type>integer</type> value <literal>1</literal> can be cast implicitly to <type>numeric</type>, so that type is used."
msgstr ""

#: /tmp/cicero-PyDp/typeconv.xml:944(title) 
msgid "Type Resolution in a Transposed Union"
msgstr ""

#: /tmp/cicero-PyDp/typeconv.xml:946(para) 
msgid "<screen>\nSELECT 1 AS \"real\" UNION SELECT CAST('2.2' AS REAL);\n\n real\n------\n    1\n  2.2\n(2 rows)\n</screen> Here, since type <type>real</type> cannot be implicitly cast to <type>integer</type>, but <type>integer</type> can be implicitly cast to <type>real</type>, the union result type is resolved as <type>real</type>."
msgstr ""

#. Put one translator per line, in the form of NAME <EMAIL>, YEAR1, YEAR2.
#: /tmp/cicero-PyDp/typeconv.xml:0(None) 
msgid "translator-credits"
msgstr ""

