msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2011-09-26 06:57+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: /tmp/cicero-cCcM/rowtypes.xml:5(title) 
msgid "Composite Types"
msgstr ""

#: /tmp/cicero-cCcM/rowtypes.xml:8(primary) /tmp/cicero-cCcM/rowtypes.xml:97(primary) 
msgid "composite type"
msgstr ""

#: /tmp/cicero-cCcM/rowtypes.xml:12(primary) 
msgid "row type"
msgstr ""

#: /tmp/cicero-cCcM/rowtypes.xml:15(para) 
msgid "A <firstterm>composite type</firstterm> represents the structure of a row or record; it is essentially just a list of field names and their data types. <productname>PostgreSQL</productname> allows composite types to be used in many of the same ways that simple types can be used. For example, a column of a table can be declared to be of a composite type."
msgstr ""

#: /tmp/cicero-cCcM/rowtypes.xml:24(title) 
msgid "Declaration of Composite Types"
msgstr ""

#: /tmp/cicero-cCcM/rowtypes.xml:28(programlisting) 
#, no-wrap
msgid "\nCREATE TYPE complex AS (\n    r       double precision,\n    i       double precision\n);\n\nCREATE TYPE inventory_item AS (\n    name            text,\n    supplier_id     integer,\n    price           numeric\n);\n"
msgstr ""

#: /tmp/cicero-cCcM/rowtypes.xml:26(para) 
msgid "Here are two simple examples of defining composite types: <placeholder-1/> The syntax is comparable to <command>CREATE TABLE</command>, except that only field names and types can be specified; no constraints (such as <literal>NOT NULL</literal>) can presently be included. Note that the <literal>AS</literal> keyword is essential; without it, the system will think a different kind of <command>CREATE TYPE</command> command is meant, and you will get odd syntax errors."
msgstr ""

#: /tmp/cicero-cCcM/rowtypes.xml:51(programlisting) 
#, no-wrap
msgid "\nCREATE TABLE on_hand (\n    item      inventory_item,\n    count     integer\n);\n\nINSERT INTO on_hand VALUES (ROW('fuzzy dice', 42, 1.99), 1000);\n"
msgstr ""

#: /tmp/cicero-cCcM/rowtypes.xml:62(programlisting) 
#, no-wrap
msgid "\nCREATE FUNCTION price_extension(inventory_item, integer) RETURNS numeric\nAS 'SELECT $1.price * $2' LANGUAGE SQL;\n\nSELECT price_extension(item, 10) FROM on_hand;\n"
msgstr ""

#: /tmp/cicero-cCcM/rowtypes.xml:48(para) 
msgid "Having defined the types, we can use them to create tables: <placeholder-1/> or functions: <placeholder-2/>"
msgstr ""

#: /tmp/cicero-cCcM/rowtypes.xml:75(programlisting) 
#, no-wrap
msgid "\nCREATE TABLE inventory_item (\n    name            text,\n    supplier_id     integer REFERENCES suppliers,\n    price           numeric CHECK (price &gt; 0)\n);\n"
msgstr ""

#: /tmp/cicero-cCcM/rowtypes.xml:71(para) 
msgid "Whenever you create a table, a composite type is also automatically created, with the same name as the table, to represent the table's row type. For example, had we said: <placeholder-1/> then the same <literal>inventory_item</literal> composite type shown above would come into being as a byproduct, and could be used just as above. Note however an important restriction of the current implementation: since no constraints are associated with a composite type, the constraints shown in the table definition <emphasis>do not apply</emphasis> to values of the composite type outside the table. (A partial workaround is to use domain types as members of composite types.)"
msgstr ""

#: /tmp/cicero-cCcM/rowtypes.xml:94(title) 
msgid "Composite Value Input"
msgstr ""

#: /tmp/cicero-cCcM/rowtypes.xml:98(secondary) 
msgid "constant"
msgstr ""

#: /tmp/cicero-cCcM/rowtypes.xml:111(programlisting) 
#, no-wrap
msgid "\n'(\"fuzzy dice\",42,1.99)'\n"
msgstr ""

#: /tmp/cicero-cCcM/rowtypes.xml:118(programlisting) 
#, no-wrap
msgid "\n'(\"fuzzy dice\",42,)'\n"
msgstr ""

#: /tmp/cicero-cCcM/rowtypes.xml:122(programlisting) 
#, no-wrap
msgid "\n'(\"\",42,)'\n"
msgstr ""

#: /tmp/cicero-cCcM/rowtypes.xml:101(para) 
msgid "To write a composite value as a literal constant, enclose the field values within parentheses and separate them by commas. You can put double quotes around any field value, and must do so if it contains commas or parentheses. (More details appear below.) Thus, the general format of a composite constant is the following: <synopsis>\n'( <replaceable>val1</replaceable> , <replaceable>val2</replaceable> , ... )'\n</synopsis> An example is: <placeholder-1/> which would be a valid value of the <literal>inventory_item</literal> type defined above. To make a field be NULL, write no characters at all in its position in the list. For example, this constant specifies a NULL third field: <placeholder-2/> If you want an empty string rather than NULL, write double quotes: <placeholder-3/> Here the first field is a non-NULL empty string, the third is NULL."
msgstr ""

#: /tmp/cicero-cCcM/rowtypes.xml:128(para) 
msgid "(These constants are actually only a special case of the generic type constants discussed in <xref linkend=\"sql-syntax-constants-generic\"/>. The constant is initially treated as a string and passed to the composite-type input conversion routine. An explicit type specification might be necessary.)"
msgstr ""

#: /tmp/cicero-cCcM/rowtypes.xml:142(programlisting) 
#, no-wrap
msgid "\nROW('fuzzy dice', 42, 1.99)\nROW('', 42, NULL)\n"
msgstr ""

#: /tmp/cicero-cCcM/rowtypes.xml:148(programlisting) 
#, no-wrap
msgid "\n('fuzzy dice', 42, 1.99)\n('', 42, NULL)\n"
msgstr ""

#: /tmp/cicero-cCcM/rowtypes.xml:136(para) 
msgid "The <literal>ROW</literal> expression syntax can also be used to construct composite values. In most cases this is considerably simpler to use than the string-literal syntax since you don't have to worry about multiple layers of quoting. We already used this method above: <placeholder-1/> The ROW keyword is actually optional as long as you have more than one field in the expression, so these can simplify to: <placeholder-2/> The <literal>ROW</literal> expression syntax is discussed in more detail in <xref linkend=\"sql-syntax-row-constructors\"/>."
msgstr ""

#: /tmp/cicero-cCcM/rowtypes.xml:158(title) 
msgid "Accessing Composite Types"
msgstr ""

#: /tmp/cicero-cCcM/rowtypes.xml:168(programlisting) 
#, no-wrap
msgid "\nSELECT item.name FROM on_hand WHERE item.price &gt; 9.99;\n"
msgstr ""

#: /tmp/cicero-cCcM/rowtypes.xml:176(programlisting) 
#, no-wrap
msgid "\nSELECT (item).name FROM on_hand WHERE (item).price &gt; 9.99;\n"
msgstr ""

#: /tmp/cicero-cCcM/rowtypes.xml:183(programlisting) 
#, no-wrap
msgid "\nSELECT (on_hand.item).name FROM on_hand WHERE (on_hand.item).price &gt; 9.99;\n"
msgstr ""

#: /tmp/cicero-cCcM/rowtypes.xml:160(para) 
msgid "To access a field of a composite column, one writes a dot and the field name, much like selecting a field from a table name. In fact, it's so much like selecting from a table name that you often have to use parentheses to keep from confusing the parser. For example, you might try to select some subfields from our <literal>on_hand</literal> example table with something like: <placeholder-1/> This will not work since the name <literal>item</literal> is taken to be a table name, not a column name of <literal>on_hand</literal>, per SQL syntax rules. You must write it like this: <placeholder-2/> or if you need to use the table name as well (for instance in a multitable query), like this: <placeholder-3/> Now the parenthesized object is correctly interpreted as a reference to the <literal>item</literal> column, and then the subfield can be selected from it."
msgstr ""

#: /tmp/cicero-cCcM/rowtypes.xml:196(programlisting) 
#, no-wrap
msgid "\nSELECT (my_func(...)).field FROM ...\n"
msgstr ""

#: /tmp/cicero-cCcM/rowtypes.xml:191(para) 
msgid "Similar syntactic issues apply whenever you select a field from a composite value. For instance, to select just one field from the result of a function that returns a composite value, you'd need to write something like: <placeholder-1/> Without the extra parentheses, this will generate a syntax error."
msgstr ""

#: /tmp/cicero-cCcM/rowtypes.xml:205(title) 
msgid "Modifying Composite Types"
msgstr ""

#: /tmp/cicero-cCcM/rowtypes.xml:212(programlisting) 
#, no-wrap
msgid "\nINSERT INTO mytab (complex_col) VALUES((1.1,2.2));\n\nUPDATE mytab SET complex_col = ROW(1.1,2.2) WHERE ...;\n"
msgstr ""

#: /tmp/cicero-cCcM/rowtypes.xml:207(para) 
msgid "Here are some examples of the proper syntax for inserting and updating composite columns. First, inserting or updating a whole column: <placeholder-1/> The first example omits <literal>ROW</literal>, the second uses it; we could have done it either way."
msgstr ""

#: /tmp/cicero-cCcM/rowtypes.xml:225(programlisting) 
#, no-wrap
msgid "\nUPDATE mytab SET complex_col.r = (complex_col).r + 1 WHERE ...;\n"
msgstr ""

#: /tmp/cicero-cCcM/rowtypes.xml:222(para) 
msgid "We can update an individual subfield of a composite column: <placeholder-1/> Notice here that we don't need to (and indeed cannot) put parentheses around the column name appearing just after <literal>SET</literal>, but we do need parentheses when referencing the same column in the expression to the right of the equal sign."
msgstr ""

#: /tmp/cicero-cCcM/rowtypes.xml:238(programlisting) 
#, no-wrap
msgid "\nINSERT INTO mytab (complex_col.r, complex_col.i) VALUES(1.1, 2.2);\n"
msgstr ""

#: /tmp/cicero-cCcM/rowtypes.xml:235(para) 
msgid "And we can specify subfields as targets for <command>INSERT</command>, too: <placeholder-1/> Had we not supplied values for all the subfields of the column, the remaining subfields would have been filled with null values."
msgstr ""

#: /tmp/cicero-cCcM/rowtypes.xml:248(title) 
msgid "Composite Type Input and Output Syntax"
msgstr ""

#: /tmp/cicero-cCcM/rowtypes.xml:260(programlisting) 
#, no-wrap
msgid "\n'(  42)'\n"
msgstr ""

#: /tmp/cicero-cCcM/rowtypes.xml:250(para) 
msgid "The external text representation of a composite value consists of items that are interpreted according to the I/O conversion rules for the individual field types, plus decoration that indicates the composite structure. The decoration consists of parentheses (<literal>(</literal> and <literal>)</literal>) around the whole value, plus commas (<literal>,</literal>) between adjacent items. Whitespace outside the parentheses is ignored, but within the parentheses it is considered part of the field value, and might or might not be significant depending on the input conversion rules for the field data type. For example, in: <placeholder-1/> the whitespace will be ignored if the field type is integer, but not if it is text."
msgstr ""

#: /tmp/cicero-cCcM/rowtypes.xml:267(para) 
msgid "As shown previously, when writing a composite value you can write double quotes around any individual field value. You <emphasis>must</emphasis> do so if the field value would otherwise confuse the composite-value parser. In particular, fields containing parentheses, commas, double quotes, or backslashes must be double-quoted. To put a double quote or backslash in a quoted composite field value, precede it with a backslash. (Also, a pair of double quotes within a double-quoted field value is taken to represent a double quote character, analogously to the rules for single quotes in SQL literal strings.) Alternatively, you can avoid quoting and use backslash-escaping to protect all data characters that would otherwise be taken as composite syntax."
msgstr ""

#: /tmp/cicero-cCcM/rowtypes.xml:282(para) 
msgid "A completely empty field value (no characters at all between the commas or parentheses) represents a NULL. To write a value that is an empty string rather than NULL, write <literal>\"\"</literal>."
msgstr ""

#: /tmp/cicero-cCcM/rowtypes.xml:288(para) 
msgid "The composite output routine will put double quotes around field values if they are empty strings or contain parentheses, commas, double quotes, backslashes, or white space. (Doing so for white space is not essential, but aids legibility.) Double quotes and backslashes embedded in field values will be doubled."
msgstr ""

#: /tmp/cicero-cCcM/rowtypes.xml:304(programlisting) 
#, no-wrap
msgid "\nINSERT ... VALUES (E'(\"\\\\\"\\\\\\\\\")');\n"
msgstr ""

#: /tmp/cicero-cCcM/rowtypes.xml:297(para) 
msgid "Remember that what you write in an SQL command will first be interpreted as a string literal, and then as a composite. This doubles the number of backslashes you need (assuming escape string syntax is used). For example, to insert a <type>text</type> field containing a double quote and a backslash in a composite value, you'd need to write: <placeholder-1/> The string-literal processor removes one level of backslashes, so that what arrives at the composite-value parser looks like <literal>(\"\\\"\\\\\")</literal>. In turn, the string fed to the <type>text</type> data type's input routine becomes <literal>\"\\</literal>. (If we were working with a data type whose input routine also treated backslashes specially, <type>bytea</type> for example, we might need as many as eight backslashes in the command to get one backslash into the stored composite field.) Dollar quoting (see <xref linkend=\"sql-syntax-dollar-quoting\"/>) can be used to avoid the need to double backslashes."
msgstr ""

#: /tmp/cicero-cCcM/rowtypes.xml:321(para) 
msgid "The <literal>ROW</literal> constructor syntax is usually easier to work with than the composite-literal syntax when writing composite values in SQL commands. In <literal>ROW</literal>, individual field values are written the same way they would be written when not members of a composite."
msgstr ""

#. Put one translator per line, in the form of NAME <EMAIL>, YEAR1, YEAR2.
#: /tmp/cicero-cCcM/rowtypes.xml:0(None) 
msgid "translator-credits"
msgstr ""

